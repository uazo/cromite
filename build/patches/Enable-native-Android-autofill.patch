From: uazo <uazo@users.noreply.github.com>
Date: Sun, 24 Oct 2021 16:54:04 +0000
Subject: Enable native Android autofill

There are 2 different types of autofill: one managed via GCM and the
native Android one that uses the provider assigned by the user
(which can be any user installed app like Bitwarden for example).
In chromium GCM is active while in the WebView the latter.
This patch uses WebView code to enable native Android autofill
along with browser-managed autofill.
A separate toggle is introduced to enable autofill in incognito mode.

See also: https://github.com/bromite/bromite/issues/547

Original License: GPL-2.0-or-later - https://spdx.org/licenses/GPL-2.0-or-later.html
License: GPL-3.0-only - https://spdx.org/licenses/GPL-3.0-only.html
---
 .../settings/PasswordSettings.java            | 84 +++++++++++++++++-
 .../chrome/browser/settings/MainSettings.java | 17 +---
 .../chromium/chrome/browser/tab/TabImpl.java  | 42 +++++++--
 chrome/browser/android/tab_android.cc         |  4 +-
 chrome/browser/autofill/android/BUILD.gn      |  2 +-
 .../autofill/AutofillClientProviderUtils.java |  2 +-
 ...AutofillThirdPartyModeContentProvider.java |  1 +
 .../glic/actor_form_filling_service_impl.cc   | 16 ++--
 .../strings/android_chrome_strings.grd        |  6 ++
 .../ui/autofill/autofill_client_provider.cc   | 87 +------------------
 .../ui/autofill/autofill_client_provider.h    |  6 --
 chrome/browser/ui/tab_helpers.cc              |  4 +-
 components/android_autofill/browser/BUILD.gn  |  1 +
 .../browser/android_autofill_manager.cc       |  2 +
 .../browser/android_autofill_manager.h        |  2 +
 .../autofill/AutofillManagerWrapper.java      |  5 +-
 .../components/autofill/AutofillProvider.java |  7 ++
 .../BrowserSelectionActionMenuDelegate.java   | 27 ++++++
 .../browser/content_autofill_driver.cc        | 11 +++
 .../content/browser/content_autofill_driver.h | 10 +++
 .../content_autofill_driver_factory.cc        | 12 +++
 .../content/renderer/autofill_agent.cc        |  5 ++
 .../renderer/password_autofill_agent.cc       |  5 +-
 .../browser/foundations/autofill_driver.h     |  2 +
 .../foundations/autofill_driver_factory.cc    |  4 +
 .../browser/foundations/autofill_manager.h    |  2 +
 .../foundations/browser_autofill_manager.cc   |  2 +
 .../foundations/browser_autofill_manager.h    |  2 +
 .../autofill/core/common/autofill_prefs.cc    |  4 +-
 .../autofill/core/common/autofill_prefs.h     |  5 ++
 30 files changed, 246 insertions(+), 133 deletions(-)
 create mode 100644 components/android_autofill/browser/java/src/org/chromium/components/autofill/BrowserSelectionActionMenuDelegate.java

diff --git a/chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java b/chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java
@@ -27,6 +27,8 @@ import androidx.preference.Preference;
 import androidx.preference.PreferenceCategory;
 import androidx.preference.PreferenceGroup;
 
+import org.chromium.base.StrictModeContext;
+import java.util.function.Supplier;
 import org.chromium.base.supplier.ObservableSupplier;
 import org.chromium.base.supplier.ObservableSupplierImpl;
 import org.chromium.build.annotations.Nullable;
@@ -60,6 +62,11 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Locale;
 
+import org.chromium.chrome.browser.ui.messages.snackbar.SnackbarManager;
+import org.chromium.chrome.browser.ui.messages.snackbar.INeedSnackbarManager;
+import org.chromium.chrome.browser.ui.messages.snackbar.Snackbar;
+import org.chromium.chrome.browser.lifetime.ApplicationLifetime;
+
 /**
  * The "Passwords" screen in Settings, which allows the user to enable or disable password saving,
  * to view saved passwords (just the username and URL), and to delete saved passwords.
@@ -67,7 +74,7 @@ import java.util.Locale;
 public class PasswordSettings extends ChromeBaseSettingsFragment
         implements PasswordListObserver,
                 Preference.OnPreferenceClickListener, SearchViewProvider,
-                SyncService.SyncStateChangedListener {
+                SyncService.SyncStateChangedListener, INeedSnackbarManager {
     @IntDef({
         TrustedVaultBannerState.NOT_SHOWN,
         TrustedVaultBannerState.OFFER_OPT_IN,
@@ -97,6 +104,12 @@ public class PasswordSettings extends ChromeBaseSettingsFragment
     public static final String PREF_TRUSTED_VAULT_BANNER = "trusted_vault_banner";
     public static final String PREF_KEY_MANAGE_ACCOUNT_LINK = "manage_account_link";
 
+    public static final String PREF_ANDROID_AUTOFILL_SWITCH = "android_autofill_switch";
+    public static final String PREF_ANDROID_AUTOFILL_INCOGNITO_SWITCH = "android_autofill_incognito_switch";
+
+    private Supplier<SnackbarManager> mSnackbarManagerSupplier;
+    private Snackbar mSnackbar;
+
     private static final String PREF_KEY_CATEGORY_SAVED_PASSWORDS = "saved_passwords";
     private static final String PREF_KEY_CATEGORY_EXCEPTIONS = "exceptions";
     private static final String PREF_KEY_SAVED_PASSWORDS_NO_TEXT = "saved_passwords_no_text";
@@ -129,6 +142,9 @@ public class PasswordSettings extends ChromeBaseSettingsFragment
     private Preference mLinkPref;
     private Menu mMenu;
 
+    private ChromeSwitchPreference mEnableAndroidAutofillSwitch;
+    private ChromeSwitchPreference mEnableAndroidAutofillIncognitoSwitch;
+
     private final ObservableSupplierImpl<String> mPageTitle = new ObservableSupplierImpl<>();
 
     /** For controlling the UX flow of exporting passwords. */
@@ -315,6 +331,7 @@ public class PasswordSettings extends ChromeBaseSettingsFragment
 
         createSavePasswordsSwitch();
         createAutoSignInCheckbox();
+        createEnableAndroidAutofillSwitch();
 
         PasswordManagerHandlerProvider.getForProfile(getProfile())
                 .getPasswordManagerHandler()
@@ -577,6 +594,71 @@ public class PasswordSettings extends ChromeBaseSettingsFragment
                 getPrefService().getBoolean(Pref.CREDENTIALS_ENABLE_SERVICE));
     }
 
+    private void createEnableAndroidAutofillSwitch() {
+        if (mSnackbar == null) {
+            mSnackbar = Snackbar.make(getActivity().getString(R.string.ui_relaunch_notice),
+                    new SnackbarManager.SnackbarController() {
+                            @Override
+                            public void onDismissNoAction(Object actionData) { }
+
+                            @Override
+                            public void onAction(Object actionData) {
+                                ApplicationLifetime.terminate(true);
+                            }
+                    }, Snackbar.TYPE_NOTIFICATION, Snackbar.UMA_UNKNOWN)
+                    .setDefaultLines(false)
+                    .setAction(getActivity().getString(R.string.relaunch),
+                            /*actionData*/null)
+                    .setDuration(/*durationMs*/70000);
+        }
+
+        mEnableAndroidAutofillSwitch = new ChromeSwitchPreference(getStyledContext(), null);
+        mEnableAndroidAutofillSwitch.setKey(PREF_ANDROID_AUTOFILL_SWITCH);
+        mEnableAndroidAutofillSwitch.setTitle(R.string.enable_android_autofill);
+        mEnableAndroidAutofillSwitch.setOrder(ORDER_SWITCH);
+        mEnableAndroidAutofillSwitch.setSummaryOn(R.string.text_on);
+        mEnableAndroidAutofillSwitch.setSummaryOff(R.string.text_off);
+
+        try (StrictModeContext ignored = StrictModeContext.allowDiskReads()) {
+            getPreferenceScreen().addPreference(mEnableAndroidAutofillSwitch);
+        }
+
+        mEnableAndroidAutofillSwitch.setChecked(
+                getPrefService().getBoolean(Pref.AUTOFILL_ANDROID_ENABLED));
+
+        mEnableAndroidAutofillSwitch.setOnPreferenceChangeListener((preference, newValue) -> {
+            getPrefService().setBoolean(Pref.AUTOFILL_ANDROID_ENABLED, (boolean) newValue);
+            if (!mSnackbarManagerSupplier.get().isShowing())
+                mSnackbarManagerSupplier.get().showSnackbar(mSnackbar);
+            return true;
+        });
+
+        mEnableAndroidAutofillIncognitoSwitch = new ChromeSwitchPreference(getStyledContext(), null);
+        mEnableAndroidAutofillIncognitoSwitch.setKey(PREF_ANDROID_AUTOFILL_INCOGNITO_SWITCH);
+        mEnableAndroidAutofillIncognitoSwitch.setTitle(R.string.enable_android_autofill_incognito);
+        mEnableAndroidAutofillIncognitoSwitch.setOrder(ORDER_SWITCH);
+        mEnableAndroidAutofillIncognitoSwitch.setSummaryOn(R.string.text_on);
+        mEnableAndroidAutofillIncognitoSwitch.setSummaryOff(R.string.text_off);
+
+        try (StrictModeContext ignored = StrictModeContext.allowDiskReads()) {
+            getPreferenceScreen().addPreference(mEnableAndroidAutofillIncognitoSwitch);
+        }
+
+        mEnableAndroidAutofillIncognitoSwitch.setChecked(
+                getPrefService().getBoolean(Pref.AUTOFILL_ANDROID_INCOGNITO_ENABLED));
+
+        mEnableAndroidAutofillIncognitoSwitch.setOnPreferenceChangeListener((preference, newValue) -> {
+            getPrefService().setBoolean(Pref.AUTOFILL_ANDROID_INCOGNITO_ENABLED, (boolean) newValue);
+            if (!mSnackbarManagerSupplier.get().isShowing())
+                mSnackbarManagerSupplier.get().showSnackbar(mSnackbar);
+            return true;
+        });
+    }
+
+    public void setSnackbarManagerSupplier(Supplier<SnackbarManager> manager) {
+        mSnackbarManagerSupplier = manager;
+    }
+
     private void createAutoSignInCheckbox() {
         ChromeSwitchPreference autoSignInSwitch =
                 new ChromeSwitchPreference(getStyledContext(), null);
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/settings/MainSettings.java b/chrome/android/java/src/org/chromium/chrome/browser/settings/MainSettings.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/settings/MainSettings.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/settings/MainSettings.java
@@ -596,21 +596,8 @@ public class MainSettings extends ChromeBaseSettingsFragment
     }
 
     private void updateAutofillPreferences() {
-        addPreferenceIfAbsent(PREF_AUTOFILL_SECTION);
-        addPreferenceIfAbsent(PREF_AUTOFILL_OPTIONS);
-        Preference autofillOptionsPreference = findPreference(PREF_AUTOFILL_OPTIONS);
-        autofillOptionsPreference.setFragment(null);
-        autofillOptionsPreference.setOnPreferenceClickListener(
-                preference -> {
-                    onPreferenceSelected(preference);
-                    SettingsNavigationFactory.createSettingsNavigation()
-                            .startSettings(
-                                    getContext(),
-                                    AutofillOptionsFragment.class,
-                                    AutofillOptionsFragment.createRequiredArgs(
-                                            AutofillOptionsReferrer.SETTINGS));
-                    return true; // Means event is consumed.
-                });
+        removePreferenceIfPresent(PREF_AUTOFILL_SECTION);
+        removePreferenceIfPresent(PREF_AUTOFILL_OPTIONS);
         findPreference(PREF_AUTOFILL_PAYMENTS)
                 .setOnPreferenceClickListener(
                         preference -> {
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tab/TabImpl.java b/chrome/android/java/src/org/chromium/chrome/browser/tab/TabImpl.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/tab/TabImpl.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tab/TabImpl.java
@@ -122,6 +122,13 @@ import java.nio.ByteBuffer;
 import java.util.Objects;
 import java.util.function.Supplier;
 
+import org.chromium.components.autofill.AutofillSelectionMenuItemHelper;
+import org.chromium.components.autofill.BrowserSelectionActionMenuDelegate;
+import org.chromium.content_public.browser.SelectionPopupController;
+import org.chromium.chrome.browser.preferences.Pref;
+import org.chromium.chrome.browser.profiles.ProfileManager;
+import org.chromium.components.user_prefs.UserPrefs;
+
 /**
  * Implementation of the interface {@link Tab}. Contains and manages a {@link ContentView}. This
  * class is not intended to be extended.
@@ -1331,6 +1338,11 @@ class TabImpl implements Tab {
         }
 
         mObservers.clear();
+        if (mAutofillProvider != null) {
+            mAutofillProvider.destroy();
+            mAutofillProvider = null;
+        }
+
         if (!abortNavigationsFromTabClosures) mUserDataHost.destroy();
         mTabViewManager.destroy();
         hideNativePage(false, null);
@@ -1717,7 +1729,7 @@ class TabImpl implements Tab {
      * @return iff the AutofillProvider should provide a ViewStructure when prompted.
      */
     boolean providesAutofillStructure() {
-
+        if ((true)) return true;
         if (mProfile == null || !mProfile.isNativeInitialized()) {
             return false;
         }
@@ -2483,16 +2495,21 @@ class TabImpl implements Tab {
      * @return true if the the provider is available for the given WebContents.
      */
     private boolean prepareAutofillProvider(WebContents newWebContents) {
-        assert isInitialized();
-        if (!providesAutofillStructure()) {
+        boolean autofillEnabled = false;
+        if (isIncognito()) {
+            autofillEnabled = UserPrefs.get(ProfileManager.getLastUsedRegularProfile())
+                                        .getBoolean(Pref.AUTOFILL_ANDROID_INCOGNITO_ENABLED);
+        } else {
+            autofillEnabled = UserPrefs.get(ProfileManager.getLastUsedRegularProfile())
+                                        .getBoolean(Pref.AUTOFILL_ANDROID_ENABLED);
+        }
+        if (!autofillEnabled) {
             maybeLogAutofillProviderDoesntUseVirtualStructureMetric();
             mAutofillProvider = null;
             return false; // Autofill provider can't be prepared.
         }
-        if (mAutofillProvider != null) {
-            // Provider already existed. Swapping contents suffices.
-            mAutofillProvider.setWebContents(newWebContents);
-        } else {
+        assert isInitialized();
+        if (mAutofillProvider == null) {
             // TODO: crbug.com/432447902 â€” Provide only an activity context and push changes.
             mAutofillProvider =
                     new AutofillProvider(
@@ -2502,7 +2519,16 @@ class TabImpl implements Tab {
                             getContext().getString(R.string.app_name));
             TabImplJni.get().initializeAutofillIfNecessary(mNativeTabAndroid);
         }
-        addAutofillItemsToSelectionActionMenu(newWebContents);
+        SelectionPopupController selectionController =
+                SelectionPopupController.fromWebContents(newWebContents);
+        mAutofillProvider.setWebContents(newWebContents);
+        mContentView.setWebContents(newWebContents);
+        BrowserSelectionActionMenuDelegate selectionActionMenuDelegate =
+                new BrowserSelectionActionMenuDelegate();
+        selectionActionMenuDelegate.setAutofillSelectionMenuItemHelper(
+                new AutofillSelectionMenuItemHelper(mAutofillProvider));
+        selectionController.setSelectionActionMenuDelegate(selectionActionMenuDelegate);
+
         return true;
     }
 
diff --git a/chrome/browser/android/tab_android.cc b/chrome/browser/android/tab_android.cc
--- a/chrome/browser/android/tab_android.cc
+++ b/chrome/browser/android/tab_android.cc
@@ -38,6 +38,7 @@
 #include "chrome/browser/resource_coordinator/tab_load_tracker.h"
 #include "chrome/browser/sync/glue/synced_tab_delegate_android.h"
 #include "chrome/browser/tab_contents/tab_util.h"
+#include "chrome/browser/ui/autofill/chrome_autofill_client.h"
 #include "chrome/browser/ui/android/context_menu_helper.h"
 #include "chrome/browser/ui/android/tab_model/tab_model.h"
 #include "chrome/browser/ui/android/tab_model/tab_model_list.h"
@@ -461,8 +462,7 @@ void TabAndroid::InitializeAutofillIfNecessary() {
         ->MaybeInitKeyboardSuppressor();
     return;
   }
-  android_autofill::AndroidAutofillClient::CreateForWebContents(
-      web_contents_.get());
+  autofill::ChromeAutofillClient::CreateForWebContents(web_contents_.get());
 
   // We need to initialize the keyboard suppressor before creating any
   // AutofillManagers and after the autofill client is available.
diff --git a/chrome/browser/autofill/android/BUILD.gn b/chrome/browser/autofill/android/BUILD.gn
--- a/chrome/browser/autofill/android/BUILD.gn
+++ b/chrome/browser/autofill/android/BUILD.gn
@@ -167,7 +167,7 @@ android_library("bottom_sheet_utils_java") {
 generate_jni("jni_headers") {
   sources = [
     "java/src/org/chromium/chrome/browser/autofill/AddressNormalizerFactory.java",
-    "java/src/org/chromium/chrome/browser/autofill/AutofillClientProviderUtils.java",
+    #"java/src/org/chromium/chrome/browser/autofill/AutofillClientProviderUtils.java",
     "java/src/org/chromium/chrome/browser/autofill/AutofillImageFetcher.java",
     "java/src/org/chromium/chrome/browser/autofill/AutofillImageFetcherFactory.java",
     "java/src/org/chromium/chrome/browser/autofill/AutofillProfileBridge.java",
diff --git a/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/AutofillClientProviderUtils.java b/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/AutofillClientProviderUtils.java
--- a/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/AutofillClientProviderUtils.java
+++ b/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/AutofillClientProviderUtils.java
@@ -76,9 +76,9 @@ public class AutofillClientProviderUtils {
      * @return {@link AndroidAutofillAvailabilityStatus.AVAILABLE} if Android Autofill can be used
      *     or a reason why it can't.
      */
-    @CalledByNative
     public static int getAndroidAutofillFrameworkAvailability(
             @JniType("PrefService*") PrefService prefs) {
+        if ((true)) return AndroidAutofillAvailabilityStatus.AVAILABLE;
         if (sAndroidAutofillFrameworkAvailabilityForTesting != null) {
             return sAndroidAutofillFrameworkAvailabilityForTesting;
         }
diff --git a/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/AutofillThirdPartyModeContentProvider.java b/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/AutofillThirdPartyModeContentProvider.java
--- a/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/AutofillThirdPartyModeContentProvider.java
+++ b/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/AutofillThirdPartyModeContentProvider.java
@@ -75,6 +75,7 @@ public final class AutofillThirdPartyModeContentProvider extends ContentProvider
             @Nullable String selection,
             String @Nullable [] selectionArgs,
             @Nullable String sortOrder) {
+        if ((true)) return null;
         if (createContentUri().equals(uri)) {
             final String[] columns = {AUTOFILL_THIRD_PARTY_MODE_COLUMN};
             MatrixCursor cursor = new MatrixCursor(columns, 1);
diff --git a/chrome/browser/autofill/glic/actor_form_filling_service_impl.cc b/chrome/browser/autofill/glic/actor_form_filling_service_impl.cc
--- a/chrome/browser/autofill/glic/actor_form_filling_service_impl.cc
+++ b/chrome/browser/autofill/glic/actor_form_filling_service_impl.cc
@@ -379,14 +379,14 @@ GetAutofillManager(const tabs::TabInterface& tab) {
   if (!profile) {
     return base::unexpected(kAutofillNotAvailable);
   }
-  if (AutofillClientProviderFactory::GetForProfile(profile)
-          .uses_platform_autofill()) {
-    // This is currently only possible on Android platforms, but this check
-    // guards against this becoming applicable for Desktop platforms as well.
-    // It is a requirement for the cast to `BrowserAutofillManager` to be
-    // safe.
-    return base::unexpected(kAutofillNotAvailable);
-  }
+  // if (AutofillClientProviderFactory::GetForProfile(profile)
+  //         .uses_platform_autofill()) {
+  //   // This is currently only possible on Android platforms, but this check
+  //   // guards against this becoming applicable for Desktop platforms as well.
+  //   // It is a requirement for the cast to `BrowserAutofillManager` to be
+  //   // safe.
+  //   return base::unexpected(kAutofillNotAvailable);
+  // }
 
   ContentAutofillClient* const client =
       ContentAutofillClient::FromWebContents(tab.GetContents());
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings.grd b/chrome/browser/ui/android/strings/android_chrome_strings.grd
--- a/chrome/browser/ui/android/strings/android_chrome_strings.grd
+++ b/chrome/browser/ui/android/strings/android_chrome_strings.grd
@@ -332,6 +332,12 @@ CHAR_LIMIT guidelines:
       <message name="IDS_PREFS_SECTION_ACCOUNT_AND_GOOGLE_SERVICES" desc="Title for the group of account-related entries and google services in Settings. [CHAR_LIMIT=32]">
         You and Google
       </message>
+      <message name="IDS_ENABLE_ANDROID_AUTOFILL" desc="Title for the checkbox toggling whether enable Android native autofill or not. [CHAR_LIMIT=32]">
+        Enable native Android autofill
+      </message>
+      <message name="IDS_ENABLE_ANDROID_AUTOFILL_INCOGNITO" desc="Title for the checkbox toggling whether enable Android native autofill or not in incognito mode. [CHAR_LIMIT=32]">
+        Enable native Android autofill in incognito
+      </message>
       <message name="IDS_SIGN_IN_TO_CHROME" meaning="Button" desc="Title for the button to sign in to Chrome using one's Google account. [CHAR_LIMIT=27]">
         Sign in to Chrome
       </message>
diff --git a/chrome/browser/ui/autofill/autofill_client_provider.cc b/chrome/browser/ui/autofill/autofill_client_provider.cc
--- a/chrome/browser/ui/autofill/autofill_client_provider.cc
+++ b/chrome/browser/ui/autofill/autofill_client_provider.cc
@@ -17,85 +17,14 @@
 #include "chrome/browser/autofill/android/android_autofill_availability_status.h"
 #include "components/android_autofill/browser/android_autofill_client.h"
 #include "components/prefs/android/pref_service_android.h"
-
-// Must come after all headers that specialize FromJniType() / ToJniType().
-#include "chrome/browser/autofill/android/jni_headers/AutofillClientProviderUtils_jni.h"
 #endif  // BUILDFLAG(IS_ANDROID)
 
 namespace autofill {
-namespace {
-
-#if BUILDFLAG(IS_ANDROID)
-void RecordAvailabilityStatus(AndroidAutofillAvailabilityStatus availability) {
-  base::UmaHistogramEnumeration("Autofill.AndroidAutofillAvailabilityStatus",
-                                availability);
-}
-
-// Counts how often the Chrome pref is reset because an platform autofill
-// isn't allowed or doesn't fulfill all preconditions.
-void RecordWhetherAndroidPrefResets(PrefService& prefs,
-                                    bool uses_platform_autofill) {
-  const bool will_reset_pref =
-      prefs.GetBoolean(prefs::kAutofillUsingVirtualViewStructure) &&
-      !uses_platform_autofill;
-  base::UmaHistogramBoolean("Autofill.ResetAutofillPrefToChrome",
-                            will_reset_pref);
-}
-
-// Sets a ahread pref that allows to learn whether deep-links into Chrome's
-// settings are available to use.
-void SetSharedPrefForDeepLink() {
-  Java_AutofillClientProviderUtils_setAutofillOptionsDeepLinkPref(
-      base::android::AttachCurrentThread(),
-
-      base::FeatureList::IsEnabled(
-          autofill::features::kAutofillDeepLinkAutofillOptions));
-}
-
-// Sets a shared pref that allows external apps to use a ContentResolver to
-// figure out whether Chrome is using platform autofill over the default.
-void SetSharedPrefForSettingsContentProvider(bool uses_platform_autofill) {
-  if (base::FeatureList::IsEnabled(
-          autofill::features::kAutofillThirdPartyModeContentProvider)) {
-    Java_AutofillClientProviderUtils_setThirdPartyModePref(
-        base::android::AttachCurrentThread(), uses_platform_autofill);
-  } else {
-    Java_AutofillClientProviderUtils_unsetThirdPartyModePref(
-        base::android::AttachCurrentThread());
-  }
-}
 
-AndroidAutofillAvailabilityStatus GetAndroidAutofillAvailabilityStatus(
-    PrefService& prefs) {
-  return static_cast<AndroidAutofillAvailabilityStatus>(
-      Java_AutofillClientProviderUtils_getAndroidAutofillFrameworkAvailability(
-          base::android::AttachCurrentThread(), &prefs));
-}
-#endif  // BUILDFLAG(IS_ANDROID)
-
-bool UsesVirtualViewStructureForAutofill(PrefService& prefs) {
+AutofillClientProvider::AutofillClientProvider(PrefService* prefs) {
 #if BUILDFLAG(IS_ANDROID)
-  const AndroidAutofillAvailabilityStatus availability =
-      GetAndroidAutofillAvailabilityStatus(prefs);
-  RecordAvailabilityStatus(availability);
-  return availability == AndroidAutofillAvailabilityStatus::kAvailable;
-#else
-  return false;
-#endif  // BUILDFLAG(IS_ANDROID)
-}
-
-}  // namespace
-
-AutofillClientProvider::AutofillClientProvider(PrefService* prefs)
-    : uses_platform_autofill_(
-          UsesVirtualViewStructureForAutofill(CHECK_DEREF(prefs))) {
-#if BUILDFLAG(IS_ANDROID)
-  RecordWhetherAndroidPrefResets(*prefs, uses_platform_autofill_);
-  // Ensure the pref is reset if platform autofill is restricted.
   prefs->SetBoolean(prefs::kAutofillUsingVirtualViewStructure,
-                    uses_platform_autofill_);
-  SetSharedPrefForSettingsContentProvider(uses_platform_autofill_);
-  SetSharedPrefForDeepLink();
+                    true);
 #endif  // BUILDFLAG(IS_ANDROID)
 }
 
@@ -103,19 +32,7 @@ AutofillClientProvider::~AutofillClientProvider() = default;
 
 void AutofillClientProvider::CreateClientForWebContents(
     content::WebContents* web_contents) {
-  if (uses_platform_autofill()) {
-#if BUILDFLAG(IS_ANDROID)
-    android_autofill::AndroidAutofillClient::CreateForWebContents(web_contents);
-#else
-    NOTREACHED();
-#endif
-  } else {
     ChromeAutofillClient::CreateForWebContents(web_contents);
-  }
 }
 
 }  // namespace autofill
-
-#if BUILDFLAG(IS_ANDROID)
-DEFINE_JNI(AutofillClientProviderUtils)
-#endif
diff --git a/chrome/browser/ui/autofill/autofill_client_provider.h b/chrome/browser/ui/autofill/autofill_client_provider.h
--- a/chrome/browser/ui/autofill/autofill_client_provider.h
+++ b/chrome/browser/ui/autofill/autofill_client_provider.h
@@ -33,13 +33,7 @@ class AutofillClientProvider : public KeyedService {
   // given `web_contents`.
   void CreateClientForWebContents(content::WebContents* web_contents);
 
-  // The return value is constant once this provider has been created. The
-  // method returns true iff platform autofill should be used instead of
-  // built-in autofill.
-  bool uses_platform_autofill() const { return uses_platform_autofill_; }
-
  private:
-  const bool uses_platform_autofill_;
 };
 
 }  // namespace autofill
diff --git a/chrome/browser/ui/tab_helpers.cc b/chrome/browser/ui/tab_helpers.cc
--- a/chrome/browser/ui/tab_helpers.cc
+++ b/chrome/browser/ui/tab_helpers.cc
@@ -369,9 +369,7 @@ void TabHelpers::AttachTabHelpers(WebContents* web_contents) {
       web_contents);
   ChainedBackNavigationTracker::CreateForWebContents(web_contents);
   chrome_browser_net::NetErrorTabHelper::CreateForWebContents(web_contents);
-  if (!autofill_client_provider.uses_platform_autofill()) {
-    ChromePasswordManagerClient::CreateForWebContents(web_contents);
-  }
+  ChromePasswordManagerClient::CreateForWebContents(web_contents);
 #if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   ChromePasswordReuseDetectionManagerClient::CreateForWebContents(web_contents);
 #endif
diff --git a/components/android_autofill/browser/BUILD.gn b/components/android_autofill/browser/BUILD.gn
--- a/components/android_autofill/browser/BUILD.gn
+++ b/components/android_autofill/browser/BUILD.gn
@@ -42,6 +42,7 @@ android_library("java") {
     "java/src/org/chromium/components/autofill/AutofillRequest.java",
     "java/src/org/chromium/components/autofill/AutofillSelectionActionMenuDelegate.java",
     "java/src/org/chromium/components/autofill/AutofillSelectionMenuItemHelper.java",
+    "java/src/org/chromium/components/autofill/BrowserSelectionActionMenuDelegate.java",
     "java/src/org/chromium/components/autofill/FormData.java",
     "java/src/org/chromium/components/autofill/FormFieldData.java",
     "java/src/org/chromium/components/autofill/PrefillRequest.java",
diff --git a/components/android_autofill/browser/android_autofill_manager.cc b/components/android_autofill/browser/android_autofill_manager.cc
--- a/components/android_autofill/browser/android_autofill_manager.cc
+++ b/components/android_autofill/browser/android_autofill_manager.cc
@@ -36,6 +36,8 @@ AndroidAutofillManager::~AndroidAutofillManager() {
   Reset();
 }
 
+bool AndroidAutofillManager::IsAndroidAutofill() const { return true; }
+
 base::WeakPtr<AutofillManager> AndroidAutofillManager::GetWeakPtr() {
   return weak_ptr_factory_.GetWeakPtr();
 }
diff --git a/components/android_autofill/browser/android_autofill_manager.h b/components/android_autofill/browser/android_autofill_manager.h
--- a/components/android_autofill/browser/android_autofill_manager.h
+++ b/components/android_autofill/browser/android_autofill_manager.h
@@ -33,6 +33,8 @@ class AndroidAutofillManager : public AutofillManager,
 
   ~AndroidAutofillManager() override;
 
+  bool IsAndroidAutofill() const override;
+
   base::WeakPtr<AndroidAutofillManager> GetWeakPtrToLeafClass() {
     return weak_ptr_factory_.GetWeakPtr();
   }
diff --git a/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillManagerWrapper.java b/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillManagerWrapper.java
--- a/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillManagerWrapper.java
+++ b/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillManagerWrapper.java
@@ -59,6 +59,7 @@ public class AutofillManagerWrapper {
             AutofillManagerWrapper manager = mManager.get();
             if (manager == null) return;
             manager.mIsAutofillInputUiShowing = (event == EVENT_INPUT_SHOWN);
+            if (manager.isLoggable()) manager.log("onAutofillEvent isAutofillInputUIShowing: " + manager.mIsAutofillInputUiShowing);
             if (event == EVENT_INPUT_SHOWN) manager.notifyInputUiChange();
         }
     }
@@ -120,6 +121,7 @@ public class AutofillManagerWrapper {
 
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
             ComponentName componentName = getAutofillServiceComponentName(mAutofillManager);
+            if (isLoggable()) log("componentName=" + componentName);
             if (componentName != null) {
                 mPackageName = componentName.getPackageName();
                 mIsAwGCurrentAutofillService =
@@ -352,7 +354,7 @@ public class AutofillManagerWrapper {
     /** Always check isLoggable() before call this method. */
     public static void log(String log) {
         // Log.i() instead of Log.d() is used here because Log.d() is stripped out in release build.
-        Log.i(TAG, log);
+        Log.i(TAG, "---" + log);
     }
 
     public static boolean isLoggable() {
@@ -366,5 +368,6 @@ public class AutofillManagerWrapper {
         // NOTE: See the comment on TAG above for why this is still AwAutofillManager.
         // Check the system setting directly.
         sIsLoggable = android.util.Log.isLoggable(TAG, Log.DEBUG);
+        // sIsLoggable = true; // to force enable the log
     }
 }
diff --git a/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillProvider.java b/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillProvider.java
--- a/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillProvider.java
+++ b/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillProvider.java
@@ -252,6 +252,10 @@ public class AutofillProvider {
      * @return whether query autofill suggestion.
      */
     public boolean shouldQueryAutofillSuggestion() {
+        AutofillManagerWrapper.log("---shouldQueryAutofillSuggestion" +
+            "  mRequest != null=" + (mRequest != null) +
+            "  mRequest.getFocusField() != null=" + (mRequest != null && mRequest.getFocusField() != null) +
+            "  !mAutofillManager.isAutofillInputUIShowing()=" + (!mAutofillManager.isAutofillInputUiShowing()));
         return mRequest != null
                 && mRequest.getFocusField() != null
                 && !getAutofillManagerWrapper().isAutofillInputUiShowing();
@@ -260,6 +264,7 @@ public class AutofillProvider {
     public boolean shouldOfferPasskeyEntry() {
         if (!AndroidAutofillFeatures.ANDROID_AUTOFILL_VIRTUAL_VIEW_STRUCTURE_PASSKEY_LONG_PRESS
                 .isEnabled()) {
+            AutofillManagerWrapper.log("calling requestAutofill");
             return false;
         }
         return AutofillProviderJni.get().hasPasskeyRequest(mNativeAutofillProvider);
@@ -272,6 +277,7 @@ public class AutofillProvider {
     }
 
     public void queryAutofillSuggestion() {
+        AutofillManagerWrapper.log("queryAutofillSuggestion start");
         if (shouldQueryAutofillSuggestion()) {
             FocusField focusField = mRequest.getFocusField();
             getAutofillManagerWrapper()
@@ -334,6 +340,7 @@ public class AutofillProvider {
             float width,
             float height,
             boolean hasServerPrediction) {
+        AutofillManagerWrapper.log("startAutofillSession");
         Rect absBound = transformToWindowBounds(new RectF(x, y, x + width, y + height));
         if (mRequest != null) notifyViewExitBeforeDestroyRequest();
 
diff --git a/components/android_autofill/browser/java/src/org/chromium/components/autofill/BrowserSelectionActionMenuDelegate.java b/components/android_autofill/browser/java/src/org/chromium/components/autofill/BrowserSelectionActionMenuDelegate.java
new file mode 100644
--- /dev/null
+++ b/components/android_autofill/browser/java/src/org/chromium/components/autofill/BrowserSelectionActionMenuDelegate.java
@@ -0,0 +1,27 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.components.autofill;
+
+import android.content.pm.ResolveInfo;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+
+import org.chromium.base.metrics.RecordHistogram;
+import org.chromium.components.autofill.AutofillSelectionActionMenuDelegate;
+import org.chromium.content_public.browser.SelectionMenuItem;
+import org.chromium.content_public.browser.SelectionPopupController;
+import org.chromium.content_public.browser.selection.SelectionActionMenuDelegate;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.chromium.base.Log;
+
+/** Interface for customizing text selection menu items in {@link SelectionPopupController} */
+public class BrowserSelectionActionMenuDelegate extends AutofillSelectionActionMenuDelegate {
+}
diff --git a/components/autofill/content/browser/content_autofill_driver.cc b/components/autofill/content/browser/content_autofill_driver.cc
--- a/components/autofill/content/browser/content_autofill_driver.cc
+++ b/components/autofill/content/browser/content_autofill_driver.cc
@@ -279,6 +279,13 @@ void RouteToManager(ContentAutofillDriver& source,
         AutofillManager& manager = target.GetAutofillManager();
         (manager.*
          manager_fun)(WithNewVersion(std::forward<ManagerArgs>(args))...);
+
+        raw_ptr<AutofillManager> secondary_autofill_manager =
+                                    target.secondary_autofill_manager();
+        if (secondary_autofill_manager) {
+          (secondary_autofill_manager->*
+           manager_fun)(WithNewVersion(std::forward<ManagerArgs>(args))...);
+        }
       },
       source, Lift(source, std::forward<ActualArgs>(args))...);
 }
@@ -694,6 +701,10 @@ ContentAutofillDriver::GetAutofillAgent() {
   return autofill_agent_;
 }
 
+raw_ptr<AutofillManager> ContentAutofillDriver::secondary_autofill_manager() {
+  return secondary_autofill_manager_.get();
+}
+
 void ContentAutofillDriver::LiftForTest(FormData& form) {
   form = Lift(*this, form);
 }
diff --git a/components/autofill/content/browser/content_autofill_driver.h b/components/autofill/content/browser/content_autofill_driver.h
--- a/components/autofill/content/browser/content_autofill_driver.h
+++ b/components/autofill/content/browser/content_autofill_driver.h
@@ -136,6 +136,12 @@ class ContentAutofillDriver : public AutofillDriver,
   // AutofillDriverFactory. Called on certain types of navigations.
   void Reset(ContentAutofillDriverFactoryPassKey pass_key);
 
+  void set_secondary_autofill_manager(
+      std::unique_ptr<AutofillManager> secondary_autofill_manager) {
+    secondary_autofill_manager_ = std::move(secondary_autofill_manager);
+  }
+  raw_ptr<AutofillManager> secondary_autofill_manager() override;
+
   content::RenderFrameHost* render_frame_host() { return &*render_frame_host_; }
   const content::RenderFrameHost* render_frame_host() const {
     return &*render_frame_host_;
@@ -315,6 +321,10 @@ class ContentAutofillDriver : public AutofillDriver,
   // The factory that created this driver. Outlives `this`.
   const raw_ref<ContentAutofillDriverFactory> owner_;
 
+  // adds a reference for AndroidAutofillManager, since native autofill works in
+  // conjunction with browser autofill in Bromite
+  std::unique_ptr<AutofillManager> secondary_autofill_manager_ = nullptr;
+
   mojo::AssociatedReceiver<mojom::AutofillDriver> receiver_{this};
 
   mojo::AssociatedRemote<mojom::AutofillAgent> autofill_agent_;
diff --git a/components/autofill/content/browser/content_autofill_driver_factory.cc b/components/autofill/content/browser/content_autofill_driver_factory.cc
--- a/components/autofill/content/browser/content_autofill_driver_factory.cc
+++ b/components/autofill/content/browser/content_autofill_driver_factory.cc
@@ -25,6 +25,12 @@
 #include "content/public/browser/web_contents.h"
 #include "third_party/blink/public/common/features.h"
 
+#if BUILDFLAG(IS_ANDROID)
+#include "components/android_autofill/browser/android_autofill_manager.h"
+#include "components/android_autofill/browser/autofill_provider.h"
+#include "components/android_autofill/browser/android_autofill_provider.h"
+#endif
+
 namespace autofill {
 
 class ScopedAutofillManagersObservation;
@@ -134,6 +140,12 @@ ContentAutofillDriver* ContentAutofillDriverFactory::DriverForFrame(
       return nullptr;
     }
     driver = std::make_unique<ContentAutofillDriver>(render_frame_host, this);
+#if BUILDFLAG(IS_ANDROID)
+    if (!driver->GetAutofillManager().IsAndroidAutofill()) {
+      driver->set_secondary_autofill_manager(
+          base::WrapUnique(new AndroidAutofillManager(driver.get())));
+    }
+#endif
     DCHECK_EQ(driver->GetLifecycleState(), LifecycleState::kInactive);
     for (auto& observer : observers()) {
       observer.OnAutofillDriverCreated(*this, *driver);
diff --git a/components/autofill/content/renderer/autofill_agent.cc b/components/autofill/content/renderer/autofill_agent.cc
--- a/components/autofill/content/renderer/autofill_agent.cc
+++ b/components/autofill/content/renderer/autofill_agent.cc
@@ -1483,14 +1483,19 @@ void AutofillAgent::ShowSuggestions(
         password_generation_agent_->ShowPasswordGenerationSuggestions(
             input_element, form_cache)) {
       is_popup_possibly_visible_ = true;
+#if !BUILDFLAG(IS_ANDROID)
       return;
+#endif
     }
+    [[maybe_unused]]
     bool password_agent_handled_request = TryShowPasswordSuggestions(
         input_element, IsPasswordsAutofillManuallyTriggered(trigger_source),
         password_request);
+#if !BUILDFLAG(IS_ANDROID)
     if (password_agent_handled_request) {
       return;
     }
+#endif
   }
 
   if (config_.secure_context_required &&
diff --git a/components/autofill/content/renderer/password_autofill_agent.cc b/components/autofill/content/renderer/password_autofill_agent.cc
--- a/components/autofill/content/renderer/password_autofill_agent.cc
+++ b/components/autofill/content/renderer/password_autofill_agent.cc
@@ -851,7 +851,10 @@ void PasswordAutofillAgent::UpdatePasswordStateForTextChange(
 
 void PasswordAutofillAgent::TrackAutofilledElement(
     const WebFormControlElement& element) {
-  autofill_agent_->TrackAutofilledElement(element);
+  // fix for https://github.com/bromite/bromite/issues/1570
+  AutofillAgent* agent = autofill_agent_.get();
+  if (agent)
+    agent->TrackAutofilledElement(element);
 }
 
 void PasswordAutofillAgent::FillPasswordSuggestion(
diff --git a/components/autofill/core/browser/foundations/autofill_driver.h b/components/autofill/core/browser/foundations/autofill_driver.h
--- a/components/autofill/core/browser/foundations/autofill_driver.h
+++ b/components/autofill/core/browser/foundations/autofill_driver.h
@@ -172,6 +172,8 @@ class AutofillDriver {
   // Returns the AutofillManager owned by the AutofillDriver.
   virtual AutofillManager& GetAutofillManager() = 0;
 
+  virtual raw_ptr<AutofillManager> secondary_autofill_manager() = 0;
+
   // Gets the UKM source ID associated with this driver's outermost main frame's
   // document.
   //
diff --git a/components/autofill/core/browser/foundations/autofill_driver_factory.cc b/components/autofill/core/browser/foundations/autofill_driver_factory.cc
--- a/components/autofill/core/browser/foundations/autofill_driver_factory.cc
+++ b/components/autofill/core/browser/foundations/autofill_driver_factory.cc
@@ -25,6 +25,10 @@ void AutofillDriverFactory::SetLifecycleStateAndNotifyObservers(
   }
   driver.GetAutofillManager().OnAutofillDriverLifecycleStateChanged(
       old_state, new_state, /*pass_key=*/{});
+  if (auto secondary = driver.secondary_autofill_manager()) {
+    secondary->OnAutofillDriverLifecycleStateChanged(
+      old_state, new_state, /*pass_key=*/{});
+  }
 }
 
 }  // namespace autofill
diff --git a/components/autofill/core/browser/foundations/autofill_manager.h b/components/autofill/core/browser/foundations/autofill_manager.h
--- a/components/autofill/core/browser/foundations/autofill_manager.h
+++ b/components/autofill/core/browser/foundations/autofill_manager.h
@@ -239,6 +239,8 @@ class AutofillManager
       LifecycleState new_state,
       base::PassKey<AutofillDriverFactory> pass_key);
 
+  virtual bool IsAndroidAutofill() const = 0;
+
   AutofillClient& client() { return driver_->GetAutofillClient(); }
   const AutofillClient& client() const { return driver_->GetAutofillClient(); }
 
diff --git a/components/autofill/core/browser/foundations/browser_autofill_manager.cc b/components/autofill/core/browser/foundations/browser_autofill_manager.cc
--- a/components/autofill/core/browser/foundations/browser_autofill_manager.cc
+++ b/components/autofill/core/browser/foundations/browser_autofill_manager.cc
@@ -903,6 +903,8 @@ base::WeakPtr<AutofillManager> BrowserAutofillManager::GetWeakPtr() {
   return weak_ptr_factory_.GetWeakPtr();
 }
 
+bool BrowserAutofillManager::IsAndroidAutofill() const { return false; }
+
 CreditCardAccessManager* BrowserAutofillManager::GetCreditCardAccessManager() {
   if (!credit_card_access_manager_) {
     credit_card_access_manager_ =
diff --git a/components/autofill/core/browser/foundations/browser_autofill_manager.h b/components/autofill/core/browser/foundations/browser_autofill_manager.h
--- a/components/autofill/core/browser/foundations/browser_autofill_manager.h
+++ b/components/autofill/core/browser/foundations/browser_autofill_manager.h
@@ -464,6 +464,8 @@ class BrowserAutofillManager : public AutofillManager {
   // latter check is needed because IPC messages can arrive out of order.
   void UpdateInitialInteractionTimestamp(base::TimeTicks interaction_timestamp);
 
+  bool IsAndroidAutofill() const override;
+
   // Whether the `trigger_field` should show an entry to scan a credit card.
   bool ShouldShowScanCreditCard(const FormStructure& form,
                                 const AutofillField& trigger_field);
diff --git a/components/autofill/core/common/autofill_prefs.cc b/components/autofill/core/common/autofill_prefs.cc
--- a/components/autofill/core/common/autofill_prefs.cc
+++ b/components/autofill/core/common/autofill_prefs.cc
@@ -85,6 +85,8 @@ void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry) {
   registry->RegisterBooleanPref(kAutofillCreditCardFidoAuthOfferCheckboxState,
                                 true);
 #endif
+  registry->RegisterBooleanPref(prefs::kAutofillAndroidEnabled, true);
+  registry->RegisterBooleanPref(prefs::kAutofillAndroidIncognitoEnabled, false);
   registry->RegisterIntegerPref(kAutocompleteLastVersionRetentionPolicy, 0);
   registry->RegisterStringPref(kAutofillUploadEncodingSeed, "");
   registry->RegisterDictionaryPref(kAutofillVoteUploadEvents);
@@ -124,7 +126,7 @@ void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry) {
 #endif  // BUILDFLAG(IS_ANDROID)
 
 #if BUILDFLAG(IS_ANDROID)
-  registry->RegisterBooleanPref(kAutofillUsingVirtualViewStructure, false);
+  registry->RegisterBooleanPref(kAutofillUsingVirtualViewStructure, true);
   registry->RegisterBooleanPref(kAutofillThirdPartyPasswordManagersAllowed,
                                 true);
   registry->RegisterBooleanPref(
diff --git a/components/autofill/core/common/autofill_prefs.h b/components/autofill/core/common/autofill_prefs.h
--- a/components/autofill/core/common/autofill_prefs.h
+++ b/components/autofill/core/common/autofill_prefs.h
@@ -162,6 +162,11 @@ inline constexpr char kAutofillWasNameAndEmailProfileUsed[] =
 // retention policy was run.
 inline constexpr char kAutocompleteLastVersionRetentionPolicy[] =
     "autocomplete.retention_policy_last_version";
+// Boolean that is true to enable native Android Autofill
+inline constexpr char kAutofillAndroidEnabled[] =
+    "autofill.android_autofill_enabled";
+inline constexpr char kAutofillAndroidIncognitoEnabled[] =
+    "autofill.android_autofill_incognito_enabled";
 #if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_WIN) || BUILDFLAG(IS_ANDROID) || \
     BUILDFLAG(IS_IOS) || BUILDFLAG(IS_CHROMEOS)
 // Boolean that is set when payment methods mandatory re-auth is enabled by the
--
