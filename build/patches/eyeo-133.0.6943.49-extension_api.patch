From: chromium-sdk <project_26591639_bot@noreply.gitlab.com>
Date: Fri, 14 Feb 2025 08:26:41 +0100
Subject: eyeo Browser Ad filtering Solution: Extension API Module

Based on Chromium 133.0.6943.49

Pre-requisites: eyeo Browser Ad filtering Solution: Base Module
---
 chrome/browser/extensions/BUILD.gn            |  11 +
 chrome/browser/extensions/api/BUILD.gn        |   4 +
 .../adblock_private/adblock_private_api.cc    | 693 +++++++++++++++
 .../api/adblock_private/adblock_private_api.h | 360 ++++++++
 .../adblock_private_apitest.cc                | 174 ++++
 .../adblock_private_apitest_backgroundpage.cc | 398 +++++++++
 .../adblock_private_apitest_base.cc           | 103 +++
 .../adblock_private_apitest_base.h            |  62 ++
 ...e_filter_lists_with_http_server_apitest.cc | 188 ++++
 ...browser_context_keyed_service_factories.cc |   8 +
 .../eyeo_filtering_private_api.cc             | 819 ++++++++++++++++++
 .../eyeo_filtering_private_api.h              | 392 +++++++++
 .../eyeo_filtering_private_apitest.cc         | 173 ++++
 .../extension_function_registration_test.cc   |  10 +
 .../common/extensions/api/_api_features.json  |  22 +
 .../extensions/api/_permission_features.json  |  18 +
 .../common/extensions/api/adblock_private.idl | 180 ++++
 chrome/common/extensions/api/api_sources.gni  |   5 +
 .../extensions/api/eyeo_filtering_private.idl | 207 +++++
 .../permissions/chrome_api_permissions.cc     |   8 +
 .../permissions/permission_set_unittest.cc    |   8 +
 chrome/test/BUILD.gn                          |  14 +
 .../api_test/adblock_private/empty.js         |  14 +
 .../api_test/adblock_private/main.html        |  29 +
 .../api_test/adblock_private/manifest.json    |  32 +
 .../api_test/adblock_private/some-popup.html  |  24 +
 .../api_test/adblock_private/test.html        |  25 +
 .../api_test/adblock_private/test.js          | 609 +++++++++++++
 .../api_test/eyeo_filtering_private/empty.js  |  14 +
 .../api_test/eyeo_filtering_private/main.html |  29 +
 .../eyeo_filtering_private/manifest.json      |  31 +
 .../api_test/eyeo_filtering_private/test.js   | 429 +++++++++
 .../browser/extension_event_histogram_value.h |   7 +-
 .../common/mojom/api_permission_id.mojom      |   6 +
 tools/metrics/histograms/enums.xml            |   3 +
 .../definitions/adblock_private.d.ts          | 182 ++++
 .../definitions/eyeo_filtering_private.d.ts   | 266 ++++++
 37 files changed, 5556 insertions(+), 1 deletion(-)
 create mode 100644 chrome/browser/extensions/api/adblock_private/adblock_private_api.cc
 create mode 100644 chrome/browser/extensions/api/adblock_private/adblock_private_api.h
 create mode 100644 chrome/browser/extensions/api/adblock_private/adblock_private_apitest.cc
 create mode 100644 chrome/browser/extensions/api/adblock_private/adblock_private_apitest_backgroundpage.cc
 create mode 100644 chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.cc
 create mode 100644 chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h
 create mode 100644 chrome/browser/extensions/api/adblock_private/adblock_private_filter_lists_with_http_server_apitest.cc
 create mode 100644 chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.cc
 create mode 100644 chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.h
 create mode 100644 chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_apitest.cc
 create mode 100644 chrome/common/extensions/api/adblock_private.idl
 create mode 100644 chrome/common/extensions/api/eyeo_filtering_private.idl
 create mode 100644 chrome/test/data/extensions/api_test/adblock_private/empty.js
 create mode 100644 chrome/test/data/extensions/api_test/adblock_private/main.html
 create mode 100644 chrome/test/data/extensions/api_test/adblock_private/manifest.json
 create mode 100644 chrome/test/data/extensions/api_test/adblock_private/some-popup.html
 create mode 100644 chrome/test/data/extensions/api_test/adblock_private/test.html
 create mode 100644 chrome/test/data/extensions/api_test/adblock_private/test.js
 create mode 100644 chrome/test/data/extensions/api_test/eyeo_filtering_private/empty.js
 create mode 100644 chrome/test/data/extensions/api_test/eyeo_filtering_private/main.html
 create mode 100644 chrome/test/data/extensions/api_test/eyeo_filtering_private/manifest.json
 create mode 100644 chrome/test/data/extensions/api_test/eyeo_filtering_private/test.js
 create mode 100644 tools/typescript/definitions/adblock_private.d.ts
 create mode 100644 tools/typescript/definitions/eyeo_filtering_private.d.ts

diff --git a/chrome/browser/extensions/BUILD.gn b/chrome/browser/extensions/BUILD.gn
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -828,6 +828,17 @@ source_set("extensions") {
       ]
     }
 
+    ### Extensions API module start
+    sources += [
+      "api/adblock_private/adblock_private_api.cc",
+      "api/adblock_private/adblock_private_api.h",
+      "api/eyeo_filtering_private/eyeo_filtering_private_api.cc",
+      "api/eyeo_filtering_private/eyeo_filtering_private_api.h",
+    ]
+
+    deps += [ "//components/adblock/content:browser" ]
+
+    ### Extensions API module end
 
     # Chrome OS does not support Native Messaging policies.
     if (!is_chromeos) {
diff --git a/chrome/browser/extensions/api/BUILD.gn b/chrome/browser/extensions/api/BUILD.gn
--- a/chrome/browser/extensions/api/BUILD.gn
+++ b/chrome/browser/extensions/api/BUILD.gn
@@ -1,6 +1,9 @@
 # Copyright 2018 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//chrome/common/extensions/api/api_sources.gni")
 import("//chrome/common/features.gni")
@@ -142,6 +145,7 @@ function_registration("api_registration") {
     # include generated headers from these targets.
     # TODO(brettw) this should be made unnecessary if possible.
     "//chrome/common/extensions/api",
+    "//components/adblock/content:browser",
     "//components/sync",
     "//skia",
     "//third_party/metrics_proto",
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_api.cc b/chrome/browser/extensions/api/adblock_private/adblock_private_api.cc
new file mode 100644
--- /dev/null
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_api.cc
@@ -0,0 +1,693 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "chrome/browser/extensions/api/adblock_private/adblock_private_api.h"
+
+#include "base/containers/flat_map.h"
+#include "base/i18n/time_formatting.h"
+#include "base/logging.h"
+#include "base/no_destructor.h"
+#include "base/values.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/common/extensions/api/tabs.h"
+#include "components/adblock/content/browser/factories/resource_classification_runner_factory.h"
+#include "components/adblock/content/browser/factories/session_stats_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/resource_classification_runner.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/common/adblock_prefs.h"
+#include "components/adblock/core/common/adblock_utils.h"
+#include "components/adblock/core/common/content_type.h"
+#include "components/adblock/core/session_stats.h"
+#include "components/adblock/core/subscription/subscription_config.h"
+#include "components/prefs/pref_service.h"
+#include "components/sessions/core/session_id.h"
+#include "content/public/browser/web_contents.h"
+#include "url/gurl.h"
+
+namespace extensions {
+
+namespace {
+
+enum class SubscriptionAction { kInstall, kUninstall };
+
+content::BrowserContext* GetOriginalBrowserContext(
+    content::BrowserContext* browser_context) {
+  return Profile::FromBrowserContext(browser_context)->GetOriginalProfile();
+}
+
+adblock::FilteringConfiguration* GetAdblockConfiguration(
+    content::BrowserContext* browser_context) {
+  auto* adblock_configuration =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context))
+          ->GetFilteringConfiguration(
+              adblock::kAdblockFilteringConfigurationName);
+  DCHECK(adblock_configuration)
+      << "adblock_private expects \"adblock\" configuration";
+  return adblock_configuration;
+}
+
+std::string RunSubscriptionAction(SubscriptionAction action,
+                                  content::BrowserContext* browser_context,
+                                  const GURL& url) {
+  if (!url.is_valid()) {
+    return "Invalid URL";
+  }
+  auto* adblock_configuration = GetAdblockConfiguration(browser_context);
+  switch (action) {
+    case SubscriptionAction::kInstall:
+      adblock_configuration->AddFilterList(url);
+      break;
+    case SubscriptionAction::kUninstall:
+      adblock_configuration->RemoveFilterList(url);
+      break;
+    default:
+      NOTREACHED();
+  }
+
+  return {};
+}
+
+std::vector<api::adblock_private::SessionStatsEntry> CopySessionsStats(
+    const std::map<GURL, long>& source) {
+  std::vector<api::adblock_private::SessionStatsEntry> result;
+  for (auto& entry : source) {
+    api::adblock_private::SessionStatsEntry js_entry;
+    js_entry.url = entry.first.spec();
+    js_entry.count = entry.second;
+    result.emplace_back(std::move(js_entry));
+  }
+  return result;
+}
+
+std::string SubscriptionInstallationStateToString(
+    adblock::Subscription::InstallationState state) {
+  using State = adblock::Subscription::InstallationState;
+  switch (state) {
+    case State::Installed:
+      return "Installed";
+    case State::AutoInstalled:
+      return "AutoInstalled";
+    case State::Preloaded:
+      return "Preloaded";
+    case State::Installing:
+      return "Installing";
+    case State::Unknown:
+      return "Unknown";
+  }
+  return "";
+}
+
+std::vector<api::adblock_private::Subscription> CopySubscriptions(
+    const std::vector<scoped_refptr<adblock::Subscription>>
+        current_subscriptions) {
+  std::vector<api::adblock_private::Subscription> result;
+  for (auto& sub : current_subscriptions) {
+    api::adblock_private::Subscription js_sub;
+    js_sub.url = sub->GetSourceUrl().spec();
+    js_sub.title = sub->GetTitle();
+    js_sub.current_version = sub->GetCurrentVersion();
+    js_sub.installation_state =
+        SubscriptionInstallationStateToString(sub->GetInstallationState());
+    const auto installation_time = sub->GetInstallationTime();
+    js_sub.last_installation_time =
+        installation_time.is_null()
+            ? ""
+            : base::TimeFormatAsIso8601(sub->GetInstallationTime());
+    result.emplace_back(std::move(js_sub));
+  }
+  return result;
+}
+
+}  // namespace
+
+template <>
+void BrowserContextKeyedAPIFactory<
+    AdblockPrivateAPI>::DeclareFactoryDependencies() {
+  DependsOn(adblock::SubscriptionServiceFactory::GetInstance());
+  DependsOn(adblock::ResourceClassificationRunnerFactory::GetInstance());
+  DependsOn(adblock::SessionStatsFactory::GetInstance());
+}
+
+// static
+BrowserContextKeyedAPIFactory<AdblockPrivateAPI>*
+AdblockPrivateAPI::GetFactoryInstance() {
+  static base::NoDestructor<BrowserContextKeyedAPIFactory<AdblockPrivateAPI>>
+      instance;
+  return instance.get();
+}
+
+class AdblockPrivateAPI::AdblockAPIEventRouter
+    : public adblock::ResourceClassificationRunner::Observer,
+      public adblock::SubscriptionService::SubscriptionObserver,
+      public adblock::FilteringConfiguration::Observer {
+ public:
+  explicit AdblockAPIEventRouter(content::BrowserContext* context)
+      : context_(GetOriginalBrowserContext(context)) {
+    adblock::ResourceClassificationRunnerFactory::GetForBrowserContext(context_)
+        ->AddObserver(this);
+    auto* subscription_service =
+        adblock::SubscriptionServiceFactory::GetForBrowserContext(context_);
+    subscription_service->AddObserver(this);
+    GetAdblockConfiguration(context_)->AddObserver(this);
+  }
+
+  ~AdblockAPIEventRouter() override {
+    adblock::ResourceClassificationRunnerFactory::GetForBrowserContext(context_)
+        ->RemoveObserver(this);
+    auto* subscription_service =
+        adblock::SubscriptionServiceFactory::GetForBrowserContext(context_);
+    subscription_service->RemoveObserver(this);
+    GetAdblockConfiguration(context_)->RemoveObserver(this);
+  }
+
+  // adblock::ResourceClassificationRunner::Observer:
+  void OnRequestMatched(const GURL& url,
+                        adblock::FilterMatchResult match_result,
+                        const std::vector<GURL>& parent_frame_urls,
+                        adblock::ContentType content_type,
+                        content::RenderFrameHost* render_frame_host,
+                        const GURL& subscription,
+                        const std::string& configuration_name) override {
+    std::unique_ptr<Event> event;
+    api::adblock_private::AdInfo info = CreateAdInfoObject(
+        url, subscription, configuration_name, render_frame_host);
+    info.parent_frame_urls = adblock::utils::ConvertURLs(parent_frame_urls);
+    info.content_type = adblock::ContentTypeToString(content_type);
+
+    if (match_result == adblock::FilterMatchResult::kBlockRule) {
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT, api::adblock_private::OnAdBlocked::kEventName,
+          api::adblock_private::OnAdBlocked::Create(info));
+    } else {
+      DCHECK(match_result == adblock::FilterMatchResult::kAllowRule);
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT, api::adblock_private::OnAdAllowed::kEventName,
+          api::adblock_private::OnAdAllowed::Create(info));
+    }
+
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnPageAllowed(const GURL& url,
+                     content::RenderFrameHost* render_frame_host,
+                     const GURL& subscription,
+                     const std::string& configuration_name) override {
+    api::adblock_private::AdInfo info = CreateAdInfoObject(
+        url, subscription, configuration_name, render_frame_host);
+    info.parent_frame_urls = std::vector<std::string>{};
+    info.content_type = "";
+
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT, api::adblock_private::OnPageAllowed::kEventName,
+        api::adblock_private::OnPageAllowed::Create(info));
+
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnPopupMatched(const GURL& url,
+                      adblock::FilterMatchResult match_result,
+                      const GURL& opener_url,
+                      content::RenderFrameHost* render_frame_host,
+                      const GURL& subscription,
+                      const std::string& configuration_name) override {
+    std::unique_ptr<Event> event;
+    api::adblock_private::AdInfo info = CreateAdInfoObject(
+        url, subscription, configuration_name, render_frame_host);
+    info.parent_frame_urls = std::vector<std::string>{opener_url.spec()};
+    info.content_type = "";
+
+    if (match_result == adblock::FilterMatchResult::kBlockRule) {
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT, api::adblock_private::OnPopupBlocked::kEventName,
+          api::adblock_private::OnPopupBlocked::Create(info));
+    } else {
+      DCHECK(match_result == adblock::FilterMatchResult::kAllowRule);
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT, api::adblock_private::OnPopupAllowed::kEventName,
+          api::adblock_private::OnPopupAllowed::Create(info));
+    }
+
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  // adblock::SubscriptionService::SubscriptionObserver:
+  void OnSubscriptionInstalled(const GURL& url) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::adblock_private::OnSubscriptionUpdated::kEventName,
+        api::adblock_private::OnSubscriptionUpdated::Create(url.spec()));
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  // adblock::FilteringConfiguration::Observer:
+  void OnEnabledStateChanged(adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::adblock_private::OnEnabledStateChanged::kEventName,
+        api::adblock_private::OnEnabledStateChanged::Create());
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnFilterListsChanged(adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::adblock_private::OnFilterListsChanged::kEventName,
+        api::adblock_private::OnFilterListsChanged::Create());
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnAllowedDomainsChanged(
+      adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::adblock_private::OnAllowedDomainsChanged::kEventName,
+        api::adblock_private::OnAllowedDomainsChanged::Create());
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnCustomFiltersChanged(
+      adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::adblock_private::OnCustomFiltersChanged::kEventName,
+        api::adblock_private::OnCustomFiltersChanged::Create());
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+ private:
+  api::adblock_private::AdInfo CreateAdInfoObject(
+      const GURL& url,
+      const GURL& subscription,
+      const std::string& configuration_name,
+      content::RenderFrameHost* render_frame_host) {
+    DCHECK(render_frame_host);
+    api::adblock_private::AdInfo info;
+    info.url = url.spec();
+    info.subscription = subscription.spec();
+    info.configuration_name = configuration_name;
+    info.tab_id = api::tabs::TAB_ID_NONE;
+    info.window_id = SessionID::InvalidValue().id();
+    const content::WebContents* wc =
+        content::WebContents::FromRenderFrameHost(render_frame_host);
+    if (wc) {
+      info.tab_id = ExtensionTabUtil::GetTabId(wc);
+      info.window_id = ExtensionTabUtil::GetWindowIdOfTab(wc);
+    }
+    return info;
+  }
+
+  raw_ptr<content::BrowserContext> context_;
+};
+
+void AdblockPrivateAPI::Shutdown() {
+  // EventRouter can be null in tests
+  if (EventRouter::Get(context_)) {
+    EventRouter::Get(context_)->UnregisterObserver(this);
+  }
+  event_router_.reset();
+}
+
+// static
+AdblockPrivateAPI* AdblockPrivateAPI::Get(content::BrowserContext* context) {
+  return GetFactoryInstance()->Get(context);
+}
+
+AdblockPrivateAPI::AdblockPrivateAPI(content::BrowserContext* context)
+    : context_(context) {
+  // EventRouter can be null in tests
+  if (EventRouter::Get(context_)) {
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnAdAllowed::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnAdBlocked::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnPageAllowed::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnPopupAllowed::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnPopupBlocked::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnSubscriptionUpdated::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnEnabledStateChanged::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnFilterListsChanged::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnAllowedDomainsChanged::kEventName);
+    EventRouter::Get(context_)->RegisterObserver(
+        this, api::adblock_private::OnCustomFiltersChanged::kEventName);
+  }
+  // Make sure SessionStats is created so it will start collectings stats
+  adblock::SessionStatsFactory::GetForBrowserContext(context);
+}
+
+AdblockPrivateAPI::~AdblockPrivateAPI() = default;
+
+void AdblockPrivateAPI::OnListenerAdded(
+    const extensions::EventListenerInfo& details) {
+  event_router_ =
+      std::make_unique<AdblockPrivateAPI::AdblockAPIEventRouter>(context_);
+  EventRouter::Get(context_)->UnregisterObserver(this);
+}
+
+namespace api {
+
+AdblockPrivateSetEnabledFunction::AdblockPrivateSetEnabledFunction() {}
+
+AdblockPrivateSetEnabledFunction::~AdblockPrivateSetEnabledFunction() {}
+
+ExtensionFunction::ResponseAction AdblockPrivateSetEnabledFunction::Run() {
+  absl::optional<api::adblock_private::SetEnabled::Params> params =
+      api::adblock_private::SetEnabled::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  adblock_configuration->SetEnabled(params->enabled);
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateIsEnabledFunction::AdblockPrivateIsEnabledFunction() {}
+
+AdblockPrivateIsEnabledFunction::~AdblockPrivateIsEnabledFunction() {}
+
+ExtensionFunction::ResponseAction AdblockPrivateIsEnabledFunction::Run() {
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  return RespondNow(
+      ArgumentList(api::adblock_private::IsEnabled::Results::Create(
+          adblock_configuration->IsEnabled())));
+}
+
+AdblockPrivateSetAcceptableAdsEnabledFunction::
+    AdblockPrivateSetAcceptableAdsEnabledFunction() {}
+
+AdblockPrivateSetAcceptableAdsEnabledFunction::
+    ~AdblockPrivateSetAcceptableAdsEnabledFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateSetAcceptableAdsEnabledFunction::Run() {
+  absl::optional<api::adblock_private::SetAcceptableAdsEnabled::Params> params =
+      api::adblock_private::SetAcceptableAdsEnabled::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  if (params->enabled) {
+    adblock_configuration->AddFilterList(adblock::AcceptableAdsUrl());
+  } else {
+    adblock_configuration->RemoveFilterList(adblock::AcceptableAdsUrl());
+  }
+
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateIsAcceptableAdsEnabledFunction::
+    AdblockPrivateIsAcceptableAdsEnabledFunction() {}
+
+AdblockPrivateIsAcceptableAdsEnabledFunction::
+    ~AdblockPrivateIsAcceptableAdsEnabledFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateIsAcceptableAdsEnabledFunction::Run() {
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  return RespondNow(ArgumentList(
+      api::adblock_private::IsAcceptableAdsEnabled::Results::Create(
+          std::ranges::any_of(adblock_configuration->GetFilterLists(),
+                              [&](const auto& url) {
+                                return url == adblock::AcceptableAdsUrl();
+                              }))));
+}
+
+AdblockPrivateSetAutoInstallEnabledFunction::
+    AdblockPrivateSetAutoInstallEnabledFunction() {}
+
+AdblockPrivateSetAutoInstallEnabledFunction::
+    ~AdblockPrivateSetAutoInstallEnabledFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateSetAutoInstallEnabledFunction::Run() {
+  absl::optional<api::adblock_private::SetAutoInstallEnabled::Params> params =
+      api::adblock_private::SetAutoInstallEnabled::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+
+  subscription_service->SetAutoInstallEnabled(params->enabled);
+
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateIsAutoInstallEnabledFunction::
+    AdblockPrivateIsAutoInstallEnabledFunction() {}
+
+AdblockPrivateIsAutoInstallEnabledFunction::
+    ~AdblockPrivateIsAutoInstallEnabledFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateIsAutoInstallEnabledFunction::Run() {
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+
+  return RespondNow(
+      ArgumentList(api::adblock_private::IsAutoInstallEnabled::Results::Create(
+          subscription_service->IsAutoInstallEnabled())));
+}
+
+AdblockPrivateGetBuiltInSubscriptionsFunction::
+    AdblockPrivateGetBuiltInSubscriptionsFunction() {}
+
+AdblockPrivateGetBuiltInSubscriptionsFunction::
+    ~AdblockPrivateGetBuiltInSubscriptionsFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateGetBuiltInSubscriptionsFunction::Run() {
+  auto recommended = adblock::config::GetKnownSubscriptions();
+  std::vector<api::adblock_private::BuiltInSubscription> result;
+  for (auto& recommended_one : recommended) {
+    if (recommended_one.ui_visibility ==
+        adblock::SubscriptionUiVisibility::Visible) {
+      api::adblock_private::BuiltInSubscription js_recommended;
+      js_recommended.url = recommended_one.url.spec();
+      js_recommended.title = recommended_one.title;
+      js_recommended.languages = recommended_one.languages;
+      result.emplace_back(std::move(js_recommended));
+    }
+  }
+  return RespondNow(ArgumentList(
+      api::adblock_private::GetBuiltInSubscriptions::Results::Create(result)));
+}
+
+AdblockPrivateInstallSubscriptionFunction::
+    AdblockPrivateInstallSubscriptionFunction() {}
+
+AdblockPrivateInstallSubscriptionFunction::
+    ~AdblockPrivateInstallSubscriptionFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateInstallSubscriptionFunction::Run() {
+  absl::optional<api::adblock_private::InstallSubscription::Params> params =
+      api::adblock_private::InstallSubscription::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto url = GURL{params->url};
+  auto status =
+      RunSubscriptionAction(SubscriptionAction::kInstall,
+                            GetOriginalBrowserContext(browser_context()), url);
+  if (!status.empty()) {
+    return RespondNow(Error(status));
+  }
+
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateUninstallSubscriptionFunction::
+    AdblockPrivateUninstallSubscriptionFunction() {}
+
+AdblockPrivateUninstallSubscriptionFunction::
+    ~AdblockPrivateUninstallSubscriptionFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateUninstallSubscriptionFunction::Run() {
+  absl::optional<api::adblock_private::UninstallSubscription::Params> params =
+      api::adblock_private::UninstallSubscription::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto url = GURL{params->url};
+  auto status =
+      RunSubscriptionAction(SubscriptionAction::kUninstall,
+                            GetOriginalBrowserContext(browser_context()), url);
+  if (!status.empty()) {
+    return RespondNow(Error(status));
+  }
+
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateGetInstalledSubscriptionsFunction::
+    AdblockPrivateGetInstalledSubscriptionsFunction() {}
+
+AdblockPrivateGetInstalledSubscriptionsFunction::
+    ~AdblockPrivateGetInstalledSubscriptionsFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateGetInstalledSubscriptionsFunction::Run() {
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  return RespondNow(ArgumentList(
+      api::adblock_private::GetInstalledSubscriptions::Results::Create(
+          CopySubscriptions(subscription_service->GetCurrentSubscriptions(
+              adblock_configuration)))));
+}
+
+AdblockPrivateAddAllowedDomainFunction::
+    AdblockPrivateAddAllowedDomainFunction() {}
+
+AdblockPrivateAddAllowedDomainFunction::
+    ~AdblockPrivateAddAllowedDomainFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateAddAllowedDomainFunction::Run() {
+  absl::optional<api::adblock_private::AddAllowedDomain::Params> params =
+      api::adblock_private::AddAllowedDomain::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  adblock_configuration->AddAllowedDomain(params->domain);
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateRemoveAllowedDomainFunction::
+    AdblockPrivateRemoveAllowedDomainFunction() {}
+
+AdblockPrivateRemoveAllowedDomainFunction::
+    ~AdblockPrivateRemoveAllowedDomainFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateRemoveAllowedDomainFunction::Run() {
+  absl::optional<api::adblock_private::RemoveAllowedDomain::Params> params =
+      api::adblock_private::RemoveAllowedDomain::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  adblock_configuration->RemoveAllowedDomain(params->domain);
+
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateGetAllowedDomainsFunction::
+    AdblockPrivateGetAllowedDomainsFunction() {}
+
+AdblockPrivateGetAllowedDomainsFunction::
+    ~AdblockPrivateGetAllowedDomainsFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateGetAllowedDomainsFunction::Run() {
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  return RespondNow(
+      ArgumentList(api::adblock_private::GetAllowedDomains::Results::Create(
+          adblock_configuration->GetAllowedDomains())));
+}
+
+AdblockPrivateAddCustomFilterFunction::AdblockPrivateAddCustomFilterFunction() {
+}
+
+AdblockPrivateAddCustomFilterFunction::
+    ~AdblockPrivateAddCustomFilterFunction() {}
+
+ExtensionFunction::ResponseAction AdblockPrivateAddCustomFilterFunction::Run() {
+  absl::optional<api::adblock_private::AddCustomFilter::Params> params =
+      api::adblock_private::AddCustomFilter::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  adblock_configuration->AddCustomFilter(params->filter);
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateRemoveCustomFilterFunction::
+    AdblockPrivateRemoveCustomFilterFunction() {}
+
+AdblockPrivateRemoveCustomFilterFunction::
+    ~AdblockPrivateRemoveCustomFilterFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateGetCustomFiltersFunction::Run() {
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  return RespondNow(
+      ArgumentList(api::adblock_private::GetCustomFilters::Results::Create(
+          adblock_configuration->GetCustomFilters())));
+}
+
+AdblockPrivateGetCustomFiltersFunction::
+    AdblockPrivateGetCustomFiltersFunction() {}
+
+AdblockPrivateGetCustomFiltersFunction::
+    ~AdblockPrivateGetCustomFiltersFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateRemoveCustomFilterFunction::Run() {
+  absl::optional<api::adblock_private::RemoveCustomFilter::Params> params =
+      api::adblock_private::RemoveCustomFilter::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* adblock_configuration =
+      GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
+  adblock_configuration->RemoveCustomFilter(params->filter);
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateGetSessionAllowedAdsCountFunction::
+    AdblockPrivateGetSessionAllowedAdsCountFunction() {}
+
+AdblockPrivateGetSessionAllowedAdsCountFunction::
+    ~AdblockPrivateGetSessionAllowedAdsCountFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateGetSessionAllowedAdsCountFunction::Run() {
+  auto* session_stats_ = adblock::SessionStatsFactory::GetForBrowserContext(
+      GetOriginalBrowserContext(browser_context()));
+  return RespondNow(ArgumentList(
+      api::adblock_private::GetSessionAllowedAdsCount::Results::Create(
+          CopySessionsStats(
+              session_stats_->GetSessionAllowedResourcesCount()))));
+}
+
+AdblockPrivateGetSessionBlockedAdsCountFunction::
+    AdblockPrivateGetSessionBlockedAdsCountFunction() {}
+
+AdblockPrivateGetSessionBlockedAdsCountFunction::
+    ~AdblockPrivateGetSessionBlockedAdsCountFunction() {}
+
+ExtensionFunction::ResponseAction
+AdblockPrivateGetSessionBlockedAdsCountFunction::Run() {
+  auto* session_stats_ = adblock::SessionStatsFactory::GetForBrowserContext(
+      GetOriginalBrowserContext(browser_context()));
+  return RespondNow(ArgumentList(
+      api::adblock_private::GetSessionAllowedAdsCount::Results::Create(
+          CopySessionsStats(
+              session_stats_->GetSessionBlockedResourcesCount()))));
+}
+
+}  // namespace api
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_api.h b/chrome/browser/extensions/api/adblock_private/adblock_private_api.h
new file mode 100644
--- /dev/null
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_api.h
@@ -0,0 +1,360 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_ADBLOCK_PRIVATE_ADBLOCK_PRIVATE_API_H_
+#define CHROME_BROWSER_EXTENSIONS_API_ADBLOCK_PRIVATE_ADBLOCK_PRIVATE_API_H_
+
+#include "base/memory/raw_ptr.h"
+#include "chrome/common/extensions/api/adblock_private.h"
+#include "extensions/browser/browser_context_keyed_api_factory.h"
+#include "extensions/browser/event_router.h"
+#include "extensions/browser/extension_function.h"
+
+class Profile;
+
+namespace extensions {
+
+class AdblockPrivateAPI : public BrowserContextKeyedAPI,
+                          public EventRouter::Observer {
+ public:
+  static BrowserContextKeyedAPIFactory<AdblockPrivateAPI>* GetFactoryInstance();
+
+  static AdblockPrivateAPI* Get(content::BrowserContext* context);
+
+  explicit AdblockPrivateAPI(content::BrowserContext* context);
+  ~AdblockPrivateAPI() override;
+  friend class BrowserContextKeyedAPIFactory<AdblockPrivateAPI>;
+
+  // BrowserContextKeyedAPI implementation.
+  static const char* service_name() { return "AdblockPrivateAPI"; }
+  static const bool kServiceRedirectedInIncognito = true;
+  static const bool kServiceIsCreatedWithBrowserContext = true;
+  void Shutdown() override;
+
+  // EventRouter::Observer:
+  void OnListenerAdded(const extensions::EventListenerInfo& details) override;
+
+ private:
+  raw_ptr<content::BrowserContext> context_;
+  class AdblockAPIEventRouter;
+  std::unique_ptr<AdblockAPIEventRouter> event_router_;
+};
+
+template <>
+void BrowserContextKeyedAPIFactory<
+    AdblockPrivateAPI>::DeclareFactoryDependencies();
+
+namespace api {
+
+class AdblockPrivateSetEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.setEnabled", UNKNOWN)
+  AdblockPrivateSetEnabledFunction();
+
+ private:
+  ~AdblockPrivateSetEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateSetEnabledFunction(const AdblockPrivateSetEnabledFunction&) =
+      delete;
+  AdblockPrivateSetEnabledFunction& operator=(
+      const AdblockPrivateSetEnabledFunction&) = delete;
+};
+
+class AdblockPrivateIsEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.isEnabled", UNKNOWN)
+  AdblockPrivateIsEnabledFunction();
+
+ private:
+  ~AdblockPrivateIsEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateIsEnabledFunction(const AdblockPrivateIsEnabledFunction&) =
+      delete;
+  AdblockPrivateIsEnabledFunction& operator=(
+      const AdblockPrivateIsEnabledFunction&) = delete;
+};
+
+class AdblockPrivateSetAcceptableAdsEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.setAcceptableAdsEnabled", UNKNOWN)
+  AdblockPrivateSetAcceptableAdsEnabledFunction();
+
+ private:
+  ~AdblockPrivateSetAcceptableAdsEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateSetAcceptableAdsEnabledFunction(
+      const AdblockPrivateSetAcceptableAdsEnabledFunction&) = delete;
+  AdblockPrivateSetAcceptableAdsEnabledFunction& operator=(
+      const AdblockPrivateSetAcceptableAdsEnabledFunction&) = delete;
+};
+
+class AdblockPrivateIsAcceptableAdsEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.isAcceptableAdsEnabled", UNKNOWN)
+  AdblockPrivateIsAcceptableAdsEnabledFunction();
+
+ private:
+  ~AdblockPrivateIsAcceptableAdsEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateIsAcceptableAdsEnabledFunction(
+      const AdblockPrivateIsAcceptableAdsEnabledFunction&) = delete;
+  AdblockPrivateIsAcceptableAdsEnabledFunction& operator=(
+      const AdblockPrivateIsAcceptableAdsEnabledFunction&) = delete;
+};
+
+class AdblockPrivateSetAutoInstallEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.setAutoInstallEnabled", UNKNOWN)
+  AdblockPrivateSetAutoInstallEnabledFunction();
+
+ private:
+  ~AdblockPrivateSetAutoInstallEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateSetAutoInstallEnabledFunction(
+      const AdblockPrivateSetAutoInstallEnabledFunction&) = delete;
+  AdblockPrivateSetAutoInstallEnabledFunction& operator=(
+      const AdblockPrivateSetAutoInstallEnabledFunction&) = delete;
+};
+
+class AdblockPrivateIsAutoInstallEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.isAutoInstallEnabled", UNKNOWN)
+  AdblockPrivateIsAutoInstallEnabledFunction();
+
+ private:
+  ~AdblockPrivateIsAutoInstallEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateIsAutoInstallEnabledFunction(
+      const AdblockPrivateIsAutoInstallEnabledFunction&) = delete;
+  AdblockPrivateIsAutoInstallEnabledFunction& operator=(
+      const AdblockPrivateIsAutoInstallEnabledFunction&) = delete;
+};
+
+class AdblockPrivateGetBuiltInSubscriptionsFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.getBuiltInSubscriptions", UNKNOWN)
+  AdblockPrivateGetBuiltInSubscriptionsFunction();
+
+ private:
+  ~AdblockPrivateGetBuiltInSubscriptionsFunction() override;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+
+  AdblockPrivateGetBuiltInSubscriptionsFunction(
+      const AdblockPrivateGetBuiltInSubscriptionsFunction&) = delete;
+  AdblockPrivateGetBuiltInSubscriptionsFunction& operator=(
+      const AdblockPrivateGetBuiltInSubscriptionsFunction&) = delete;
+};
+
+class AdblockPrivateInstallSubscriptionFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.installSubscription", UNKNOWN)
+  AdblockPrivateInstallSubscriptionFunction();
+
+ private:
+  ~AdblockPrivateInstallSubscriptionFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateInstallSubscriptionFunction(
+      const AdblockPrivateInstallSubscriptionFunction&) = delete;
+  AdblockPrivateInstallSubscriptionFunction& operator=(
+      const AdblockPrivateInstallSubscriptionFunction&) = delete;
+};
+
+class AdblockPrivateUninstallSubscriptionFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.uninstallSubscription", UNKNOWN)
+  AdblockPrivateUninstallSubscriptionFunction();
+
+ private:
+  ~AdblockPrivateUninstallSubscriptionFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateUninstallSubscriptionFunction(
+      const AdblockPrivateUninstallSubscriptionFunction&) = delete;
+  AdblockPrivateUninstallSubscriptionFunction& operator=(
+      const AdblockPrivateUninstallSubscriptionFunction&) = delete;
+};
+
+class AdblockPrivateGetInstalledSubscriptionsFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.getInstalledSubscriptions",
+                             UNKNOWN)
+  AdblockPrivateGetInstalledSubscriptionsFunction();
+
+ private:
+  ~AdblockPrivateGetInstalledSubscriptionsFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateGetInstalledSubscriptionsFunction(
+      const AdblockPrivateGetInstalledSubscriptionsFunction&) = delete;
+  AdblockPrivateGetInstalledSubscriptionsFunction& operator=(
+      const AdblockPrivateGetInstalledSubscriptionsFunction&) = delete;
+};
+
+class AdblockPrivateAddAllowedDomainFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.addAllowedDomain", UNKNOWN)
+  AdblockPrivateAddAllowedDomainFunction();
+
+ private:
+  ~AdblockPrivateAddAllowedDomainFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateAddAllowedDomainFunction(
+      const AdblockPrivateAddAllowedDomainFunction&) = delete;
+  AdblockPrivateAddAllowedDomainFunction& operator=(
+      const AdblockPrivateAddAllowedDomainFunction&) = delete;
+};
+
+class AdblockPrivateRemoveAllowedDomainFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.removeAllowedDomain", UNKNOWN)
+  AdblockPrivateRemoveAllowedDomainFunction();
+
+ private:
+  ~AdblockPrivateRemoveAllowedDomainFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateRemoveAllowedDomainFunction(
+      const AdblockPrivateRemoveAllowedDomainFunction&) = delete;
+  AdblockPrivateRemoveAllowedDomainFunction& operator=(
+      const AdblockPrivateRemoveAllowedDomainFunction&) = delete;
+};
+
+class AdblockPrivateGetAllowedDomainsFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.getAllowedDomains", UNKNOWN)
+  AdblockPrivateGetAllowedDomainsFunction();
+
+ private:
+  ~AdblockPrivateGetAllowedDomainsFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateGetAllowedDomainsFunction(
+      const AdblockPrivateGetAllowedDomainsFunction&) = delete;
+  AdblockPrivateGetAllowedDomainsFunction& operator=(
+      const AdblockPrivateGetAllowedDomainsFunction&) = delete;
+};
+
+class AdblockPrivateAddCustomFilterFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.addCustomFilter", UNKNOWN)
+  AdblockPrivateAddCustomFilterFunction();
+
+ private:
+  ~AdblockPrivateAddCustomFilterFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateAddCustomFilterFunction(
+      const AdblockPrivateAddCustomFilterFunction&) = delete;
+  AdblockPrivateAddCustomFilterFunction& operator=(
+      const AdblockPrivateAddCustomFilterFunction&) = delete;
+};
+
+class AdblockPrivateRemoveCustomFilterFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.removeCustomFilter", UNKNOWN)
+  AdblockPrivateRemoveCustomFilterFunction();
+
+ private:
+  ~AdblockPrivateRemoveCustomFilterFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateRemoveCustomFilterFunction(
+      const AdblockPrivateRemoveCustomFilterFunction&) = delete;
+  AdblockPrivateRemoveCustomFilterFunction& operator=(
+      const AdblockPrivateRemoveCustomFilterFunction&) = delete;
+};
+
+class AdblockPrivateGetCustomFiltersFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.getCustomFilters", UNKNOWN)
+  AdblockPrivateGetCustomFiltersFunction();
+
+ private:
+  ~AdblockPrivateGetCustomFiltersFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateGetCustomFiltersFunction(
+      const AdblockPrivateGetCustomFiltersFunction&) = delete;
+  AdblockPrivateGetCustomFiltersFunction& operator=(
+      const AdblockPrivateGetCustomFiltersFunction&) = delete;
+};
+
+class AdblockPrivateGetSessionAllowedAdsCountFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.getSessionAllowedAdsCount",
+                             UNKNOWN)
+  AdblockPrivateGetSessionAllowedAdsCountFunction();
+
+ private:
+  ~AdblockPrivateGetSessionAllowedAdsCountFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateGetSessionAllowedAdsCountFunction(
+      const AdblockPrivateGetSessionAllowedAdsCountFunction&) = delete;
+  AdblockPrivateGetSessionAllowedAdsCountFunction& operator=(
+      const AdblockPrivateGetSessionAllowedAdsCountFunction&) = delete;
+};
+
+class AdblockPrivateGetSessionBlockedAdsCountFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.getSessionBlockedAdsCount",
+                             UNKNOWN)
+  AdblockPrivateGetSessionBlockedAdsCountFunction();
+
+ private:
+  ~AdblockPrivateGetSessionBlockedAdsCountFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateGetSessionBlockedAdsCountFunction(
+      const AdblockPrivateGetSessionBlockedAdsCountFunction&) = delete;
+  AdblockPrivateGetSessionBlockedAdsCountFunction& operator=(
+      const AdblockPrivateGetSessionBlockedAdsCountFunction&) = delete;
+};
+
+}  // namespace api
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_ADBLOCK_PRIVATE_ADBLOCK_PRIVATE_API_H_
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_apitest.cc b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest.cc
new file mode 100644
--- /dev/null
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest.cc
@@ -0,0 +1,174 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <map>
+#include <string>
+
+#include "chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/test/adblock_browsertest_base.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+
+namespace extensions {
+
+class AdblockPrivateApiTest
+    : public AdblockPrivateApiTestBase,
+      public testing::WithParamInterface<
+          std::tuple<AdblockPrivateApiTestBase::EyeoExtensionApi,
+                     AdblockPrivateApiTestBase::Mode>> {
+ public:
+  AdblockPrivateApiTest() {}
+  ~AdblockPrivateApiTest() override = default;
+  AdblockPrivateApiTest(const AdblockPrivateApiTest&) = delete;
+  AdblockPrivateApiTest& operator=(const AdblockPrivateApiTest&) = delete;
+
+  bool IsIncognito() override {
+    return std::get<1>(GetParam()) ==
+           AdblockPrivateApiTestBase::Mode::Incognito;
+  }
+
+  std::string GetApiEndpoint() override {
+    return std::get<0>(GetParam()) ==
+                   AdblockPrivateApiTestBase::EyeoExtensionApi::Old
+               ? "adblockPrivate"
+               : "eyeoFilteringPrivate";
+  }
+
+  std::map<std::string, std::string> FindExpectedDefaultFilterLists() {
+    DCHECK(browser()->profile()->GetOriginalProfile());
+    auto selected = adblock::SubscriptionServiceFactory::GetForBrowserContext(
+                        browser()->profile()->GetOriginalProfile())
+                        ->GetFilteringConfiguration(
+                            adblock::kAdblockFilteringConfigurationName)
+                        ->GetFilterLists();
+    const auto easylist = std::find_if(
+        selected.begin(), selected.end(), [&](const GURL& subscription) {
+          return base::EndsWith(subscription.path_piece(), "easylist.txt");
+        });
+    const auto exceptions = std::find_if(
+        selected.begin(), selected.end(), [&](const GURL& subscription) {
+          return base::EndsWith(subscription.path_piece(),
+                                "exceptionrules.txt");
+        });
+    const auto snippets = std::find_if(
+        selected.begin(), selected.end(), [&](const GURL& subscription) {
+          return base::EndsWith(subscription.path_piece(),
+                                "abp-filters-anti-cv.txt");
+        });
+    if (easylist == selected.end() || exceptions == selected.end() ||
+        snippets == selected.end()) {
+      return std::map<std::string, std::string>{};
+    }
+    return std::map<std::string, std::string>{
+        {"easylist", easylist->spec()},
+        {"exceptions", exceptions->spec()},
+        {"snippets", snippets->spec()}};
+  }
+};
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, SetAndCheckEnabled) {
+  EXPECT_TRUE(RunTest("setEnabled_isEnabled")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, SetAndCheckAAEnabled) {
+  EXPECT_TRUE(RunTest(GetApiEndpoint() == "adblockPrivate"
+                          ? "setAAEnabled_isAAEnabled"
+                          : "setAAEnabled_isAAEnabled_newAPI"))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, GetBuiltInSubscriptions) {
+  if (GetApiEndpoint() == "adblockPrivate") {
+    EXPECT_TRUE(RunTest("getBuiltInSubscriptions")) << message_;
+  }
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, InstallSubscriptionInvalidURL) {
+  EXPECT_TRUE(RunTest("installSubscriptionInvalidURL")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, UninstallSubscriptionInvalidURL) {
+  EXPECT_TRUE(RunTest("uninstallSubscriptionInvalidURL")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, SubscriptionsManagement) {
+  auto params = FindExpectedDefaultFilterLists();
+  if (params.empty()) {
+    // Since default configuration has been changed let's skip this test
+    return;
+  }
+  EXPECT_TRUE(RunTestWithParams("subscriptionsManagement", params)) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest,
+                       SubscriptionsManagementConfigDisabled) {
+  auto params = FindExpectedDefaultFilterLists();
+  if (params.empty()) {
+    // Since default configuration has been changed let's skip this test
+    return;
+  }
+  params.insert({"disabled", "true"});
+  EXPECT_TRUE(RunTestWithParams("subscriptionsManagement", params)) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, AllowedDomainsManagement) {
+  EXPECT_TRUE(RunTest("allowedDomainsManagement")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, CustomFiltersManagement) {
+  EXPECT_TRUE(RunTest("customFiltersManagement")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, AdBlockedEvents) {
+  EXPECT_TRUE(RunTest("adBlockedEvents")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, AdAllowedEvents) {
+  EXPECT_TRUE(RunTest("adAllowedEvents")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, SessionStats) {
+  EXPECT_TRUE(RunTest("sessionStats")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, AllowedDomainsEvent) {
+  EXPECT_TRUE(RunTest("allowedDomainsEvent")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, EnabledStateEvent) {
+  EXPECT_TRUE(RunTest("enabledStateEvent")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, FilterListsEvent) {
+  EXPECT_TRUE(RunTest("filterListsEvent")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiTest, CustomFiltersEvent) {
+  EXPECT_TRUE(RunTest("customFiltersEvent")) << message_;
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    ,
+    AdblockPrivateApiTest,
+    testing::Combine(
+        testing::Values(AdblockPrivateApiTestBase::EyeoExtensionApi::Old,
+                        AdblockPrivateApiTestBase::EyeoExtensionApi::New),
+        testing::Values(AdblockPrivateApiTestBase::Mode::Normal,
+                        AdblockPrivateApiTestBase::Mode::Incognito)));
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_backgroundpage.cc b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_backgroundpage.cc
new file mode 100644
--- /dev/null
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_backgroundpage.cc
@@ -0,0 +1,398 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/test/base/ui_test_utils.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/test/adblock_browsertest_base.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "content/public/test/content_mock_cert_verifier.h"
+#include "extensions/browser/background_script_executor.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+
+namespace extensions {
+
+// Here are extension API tests for PageAllowed event and popup
+// events and stats, which are difficult to implement like other
+// tests in AdblockPrivateAPI class (purely in JS in test.js file).
+// Tests here require a background page to run script code.
+class AdblockPrivateApiBackgroundPageTest
+    : public AdblockPrivateApiTestBase,
+      public testing::WithParamInterface<
+          std::tuple<AdblockPrivateApiTestBase::EyeoExtensionApi,
+                     AdblockPrivateApiTestBase::Mode>> {
+ public:
+  AdblockPrivateApiBackgroundPageTest() {}
+  ~AdblockPrivateApiBackgroundPageTest() override = default;
+  AdblockPrivateApiBackgroundPageTest(
+      const AdblockPrivateApiBackgroundPageTest&) = delete;
+  AdblockPrivateApiBackgroundPageTest& operator=(
+      const AdblockPrivateApiBackgroundPageTest&) = delete;
+
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    AdblockPrivateApiTestBase::SetUpCommandLine(command_line);
+    mock_cert_verifier_.SetUpCommandLine(command_line);
+  }
+
+ protected:
+  void SetUpOnMainThread() override {
+    ExtensionApiTest::SetUpOnMainThread();
+
+    // Map example.com to localhost.
+    host_resolver()->AddRule("example.com", "127.0.0.1");
+
+    mock_cert_verifier_.mock_cert_verifier()->set_default_result(net::OK);
+
+    https_test_server_ = std::make_unique<net::EmbeddedTestServer>(
+        net::EmbeddedTestServer::TYPE_HTTPS);
+    https_test_server_->SetSSLConfig(net::EmbeddedTestServer::CERT_OK);
+    https_test_server_->ServeFilesFromSourceDirectory(GetChromeTestDataDir());
+    ASSERT_TRUE(https_test_server_->Start());
+
+    ASSERT_TRUE(StartEmbeddedTestServer());
+    adblock::SubscriptionServiceFactory::GetForBrowserContext(
+        browser()->profile()->GetOriginalProfile())
+        ->GetFilteringConfiguration(adblock::kAdblockFilteringConfigurationName)
+        ->RemoveCustomFilter(adblock::kAllowlistEverythingFilter);
+
+    extension_ = LoadExtension(test_data_dir_.AppendASCII("adblock_private"),
+                               {.allow_in_incognito = IsIncognito()});
+    ASSERT_TRUE(extension_);
+  }
+
+  bool IsOldApi() { return std::get<0>(GetParam()) == EyeoExtensionApi::Old; }
+
+  std::string GetApiEndpoint() override {
+    return IsOldApi() ? "adblockPrivate" : "eyeoFilteringPrivate";
+  }
+
+  bool IsIncognito() override {
+    return std::get<1>(GetParam()) ==
+           AdblockPrivateApiBackgroundPageTest::Mode::Incognito;
+  }
+
+  void ExecuteScript(const std::string& js_code) const {
+    content::WebContents* web_contents =
+        browser()->tab_strip_model()->GetWebContentsAt(0);
+    ASSERT_TRUE(content::ExecJs(web_contents->GetPrimaryMainFrame(), js_code));
+  }
+
+  int ExecuteScriptIAndGetInt(const std::string& extension_id,
+                              const std::string& script) {
+    return ExtensionApiTest::ExecuteScriptInBackgroundPage(extension_id, script)
+        .GetInt();
+  }
+
+  void SetupApiObjectAndMethods(const std::string& extension_id) {
+    std::string setup_script;
+    if (IsOldApi()) {
+      setup_script =
+          "let apiObject = chrome.adblockPrivate;"
+          "let sessionAllowedCount = 'getSessionAllowedAdsCount';"
+          "let sessionBlockedCount = 'getSessionBlockedAdsCount';"
+          "let onAllowedEvent = 'onAdAllowed';"
+          "let onBlockedEvent = 'onAdBlocked';"
+          "chrome.test.sendScriptResult(0);";
+    } else {
+      setup_script =
+          "let apiObject = chrome.eyeoFilteringPrivate;"
+          "let sessionAllowedCount = 'getSessionAllowedRequestsCount';"
+          "let sessionBlockedCount = 'getSessionBlockedRequestsCount';"
+          "let onAllowedEvent = 'onRequestAllowed';"
+          "let onBlockedEvent = 'onRequestBlocked';"
+          "chrome.test.sendScriptResult(0);";
+    }
+    ExecuteScriptIAndGetInt(extension_id, setup_script);
+  }
+
+  const ExtensionId& GetExtensionId() const { return extension_->id(); }
+
+  std::unique_ptr<net::EmbeddedTestServer> https_test_server_;
+  content::ContentMockCertVerifier mock_cert_verifier_;
+  raw_ptr<const Extension, DanglingUntriaged> extension_;
+};
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiBackgroundPageTest, PageAllowedEvents) {
+  constexpr char kSetListenersScript[] = R"(
+    let testData = {};
+    testData.pageAllowedCount = 0;
+    apiObject.onPageAllowed.addListener(function(e) {
+      if (!e.url.endsWith('test.html')) {
+        return;
+      }
+      testData.pageAllowedCount = testData.pageAllowedCount + 1;
+    });
+    chrome.test.sendScriptResult(0);
+  )";
+
+  constexpr char kReadCountersScript[] = R"(
+    var intervalId = setInterval(function() {
+      if (testData.pageAllowedCount == %d) {
+        if (intervalId) {
+          clearInterval(intervalId);
+          intervalId = null;
+        }
+        chrome.test.sendScriptResult(testData.pageAllowedCount);
+      }
+    }, 100);
+  )";
+
+  constexpr char kAllowDomainScript[] = R"(
+    apiObject.addAllowedDomain(%s'example.com');
+    chrome.test.sendScriptResult(0);
+  )";
+
+  const GURL test_url = https_test_server_->GetURL(
+      "example.com", "/extensions/api_test/adblock_private/test.html");
+
+  SetupApiObjectAndMethods(GetExtensionId());
+
+  ExecuteScriptIAndGetInt(GetExtensionId(), kSetListenersScript);
+
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), test_url));
+  ASSERT_EQ(
+      0, ExecuteScriptIAndGetInt(GetExtensionId(),
+                                 base::StringPrintf(kReadCountersScript, 0)));
+
+  ExecuteScriptIAndGetInt(
+      GetExtensionId(),
+      base::StringPrintf(kAllowDomainScript, IsOldApi() ? "" : "'adblock', "));
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), test_url));
+  ASSERT_EQ(
+      1, ExecuteScriptIAndGetInt(GetExtensionId(),
+                                 base::StringPrintf(kReadCountersScript, 1)));
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiBackgroundPageTest, PageAllowedStats) {
+  constexpr char kReadAllowedStatsScript[] = R"(
+    var intervalId = setInterval(function() {
+      apiObject[sessionAllowedCount](function(sessionStats) {
+        let count = 0;
+        for (const entry of sessionStats) {
+          if (entry.url === 'adblock:custom') {
+            count = entry.count;
+          }
+        }
+        if (%d == 0 || count == %d) {
+          if (intervalId) {
+            clearInterval(intervalId);
+            intervalId = null;
+          }
+          chrome.test.sendScriptResult(count);
+        }
+      });
+    }, 100);
+  )";
+
+  constexpr char kAllowDomainScript[] = R"(
+    apiObject.addAllowedDomain(%s'example.com');
+    chrome.test.sendScriptResult(0);
+  )";
+
+  const GURL test_url = https_test_server_->GetURL(
+      "example.com", "/extensions/api_test/adblock_private/test.html");
+
+  SetupApiObjectAndMethods(GetExtensionId());
+
+  int initial_value = ExecuteScriptIAndGetInt(
+      GetExtensionId(), base::StringPrintf(kReadAllowedStatsScript, 0, 0));
+
+  ExecuteScriptIAndGetInt(
+      GetExtensionId(),
+      base::StringPrintf(kAllowDomainScript, IsOldApi() ? "" : "'adblock', "));
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), test_url));
+
+  EXPECT_EQ(
+      initial_value + 1,
+      ExecuteScriptIAndGetInt(
+          GetExtensionId(), base::StringPrintf(kReadAllowedStatsScript, 1, 1)));
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiBackgroundPageTest, PopupEvents) {
+  constexpr char kSetListenersScript[] = R"(
+    let testData = {};
+    testData.popupBlockedCount = 0;
+    testData.popupAllowedCount = 0;
+    apiObject.onPopupAllowed.addListener(function(e, blocked) {
+      if (!e.url.endsWith('some-popup.html')) {
+        return;
+      }
+      testData.popupAllowedCount = testData.popupAllowedCount + 1;
+    });
+    apiObject.onPopupBlocked.addListener(function(e, blocked) {
+      if (!e.url.endsWith('some-popup.html')) {
+        return;
+      }
+      testData.popupBlockedCount = testData.popupBlockedCount + 1;
+    });
+    chrome.test.sendScriptResult(0);
+  )";
+
+  constexpr char verify_stats_script_tmpl[] = R"(
+        var intervalId = setInterval(function() {
+          let result = testData.%s;
+          if (result == %d) {
+            if (intervalId) {
+              clearInterval(intervalId);
+              intervalId = null;
+            }
+            chrome.test.sendScriptResult(result);
+          }
+        }, 100);
+  )";
+
+  auto read_allowed_stats_script = [verify_stats_script_tmpl](int expected) {
+    std::string script = base::StringPrintf(verify_stats_script_tmpl,
+                                            "popupAllowedCount", expected);
+    return script;
+  };
+
+  auto read_blocked_stats_script = [verify_stats_script_tmpl](int expected) {
+    std::string script = base::StringPrintf(verify_stats_script_tmpl,
+                                            "popupBlockedCount", expected);
+    return script;
+  };
+
+  constexpr char kBlockPopupScript[] = R"(
+    apiObject.addCustomFilter(%s'some-popup.html^$popup');
+    chrome.test.sendScriptResult(0);
+  )";
+
+  constexpr char kAllowPopupScript[] = R"(
+    apiObject.addCustomFilter(%s'@@some-popup.html^$popup');
+    chrome.test.sendScriptResult(0);
+  )";
+
+  const GURL test_url = https_test_server_->GetURL(
+      "example.com", "/extensions/api_test/adblock_private/test.html");
+  constexpr char kOpenPopupScript[] =
+      "document.getElementById('popup_id').click()";
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), test_url));
+  SetupApiObjectAndMethods(GetExtensionId());
+
+  ExecuteScriptIAndGetInt(GetExtensionId(), kSetListenersScript);
+
+  ExecuteScriptIAndGetInt(
+      GetExtensionId(),
+      base::StringPrintf(kBlockPopupScript, IsOldApi() ? "" : "'adblock', "));
+  ExecuteScript(kOpenPopupScript);
+  EXPECT_EQ(0, ExecuteScriptIAndGetInt(GetExtensionId(),
+                                       read_allowed_stats_script(0)));
+  EXPECT_EQ(1, ExecuteScriptIAndGetInt(GetExtensionId(),
+                                       read_blocked_stats_script(1)));
+
+  ExecuteScriptIAndGetInt(
+      GetExtensionId(),
+      base::StringPrintf(kAllowPopupScript, IsOldApi() ? "" : "'adblock', "));
+  ExecuteScript(kOpenPopupScript);
+  EXPECT_EQ(1, ExecuteScriptIAndGetInt(GetExtensionId(),
+                                       read_allowed_stats_script(1)));
+  EXPECT_EQ(1, ExecuteScriptIAndGetInt(GetExtensionId(),
+                                       read_blocked_stats_script(1)));
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiBackgroundPageTest, PopupStats) {
+  constexpr char verify_stats_script_tmpl[] = R"(
+    var intervalId = setInterval(function() {
+      apiObject[%s](function(sessionStats) {
+        let count = 0;
+        for (const entry of sessionStats) {
+          if (entry.url === 'adblock:custom') {
+            count = entry.count;
+          }
+        }
+        if (%d == 0 || count == %d) {
+          if (intervalId) {
+            clearInterval(intervalId);
+            intervalId = null;
+          }
+          chrome.test.sendScriptResult(count);
+        }
+      }
+    )}, 100);
+  )";
+
+  auto read_allowed_stats_script = [verify_stats_script_tmpl](int expected) {
+    std::string script = base::StringPrintf(
+        verify_stats_script_tmpl, "sessionAllowedCount", expected, expected);
+    return script;
+  };
+
+  auto read_blocked_stats_script = [verify_stats_script_tmpl](int expected) {
+    std::string script = base::StringPrintf(
+        verify_stats_script_tmpl, "sessionBlockedCount", expected, expected);
+    return script;
+  };
+
+  constexpr char kBlockPopupScript[] = R"(
+    apiObject.addCustomFilter(%s'some-popup.html^$popup');
+    chrome.test.sendScriptResult(0);
+  )";
+
+  constexpr char kAllowPopupScript[] = R"(
+    apiObject.addCustomFilter(%s'@@some-popup.html^$popup');
+    chrome.test.sendScriptResult(0);
+  )";
+
+  const GURL test_url = https_test_server_->GetURL(
+      "example.com", "/extensions/api_test/adblock_private/test.html");
+  constexpr char kOpenPopupScript[] =
+      "document.getElementById('popup_id').click()";
+  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), test_url));
+  SetupApiObjectAndMethods(GetExtensionId());
+
+  int initial_allowed_value =
+      ExecuteScriptIAndGetInt(GetExtensionId(), read_allowed_stats_script(0));
+  int initial_blocked_value =
+      ExecuteScriptIAndGetInt(GetExtensionId(), read_blocked_stats_script(0));
+
+  ExecuteScriptIAndGetInt(
+      GetExtensionId(),
+      base::StringPrintf(kBlockPopupScript, IsOldApi() ? "" : "'adblock', "));
+  ExecuteScript(kOpenPopupScript);
+  ASSERT_EQ(initial_blocked_value + 1,
+            ExecuteScriptIAndGetInt(
+                GetExtensionId(),
+                read_blocked_stats_script(initial_blocked_value + 1)));
+
+  ExecuteScriptIAndGetInt(
+      GetExtensionId(),
+      base::StringPrintf(kAllowPopupScript, IsOldApi() ? "" : "'adblock', "));
+  ExecuteScript(kOpenPopupScript);
+  ASSERT_EQ(initial_allowed_value + 1,
+            ExecuteScriptIAndGetInt(
+                GetExtensionId(),
+                read_allowed_stats_script(initial_allowed_value + 1)));
+  ASSERT_EQ(initial_blocked_value + 1,
+            ExecuteScriptIAndGetInt(
+                GetExtensionId(),
+                read_blocked_stats_script(initial_blocked_value + 1)));
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    All,
+    AdblockPrivateApiBackgroundPageTest,
+    testing::Combine(
+        testing::Values(
+            AdblockPrivateApiBackgroundPageTest::EyeoExtensionApi::Old,
+            AdblockPrivateApiBackgroundPageTest::EyeoExtensionApi::New),
+        testing::Values(AdblockPrivateApiBackgroundPageTest::Mode::Normal,
+                        AdblockPrivateApiBackgroundPageTest::Mode::Incognito)));
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.cc b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.cc
new file mode 100644
--- /dev/null
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.cc
@@ -0,0 +1,103 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h"
+
+#include "chrome/browser/adblock/adblock_chrome_content_browser_client.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/common/extensions/api/adblock_private.h"
+#include "chrome/common/extensions/api/tabs.h"
+#include "components/adblock/content/browser/factories/adblock_request_throttle_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/test/adblock_browsertest_base.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/net/adblock_request_throttle.h"
+#include "extensions/common/switches.h"
+
+namespace extensions {
+
+void AdblockPrivateApiTestBase::SetUpCommandLine(
+    base::CommandLine* command_line) {
+  ExtensionApiTest::SetUpCommandLine(command_line);
+  AllowTestExtension(command_line);
+  if (IsIncognito()) {
+    EnableIncognitoMode(command_line);
+  }
+}
+
+void AdblockPrivateApiTestBase::SetUpOnMainThread() {
+  ExtensionApiTest::SetUpOnMainThread();
+
+  // When any of that fails we need to update comment in adblock_private.idl
+  ASSERT_EQ(api::tabs::TAB_ID_NONE, -1);
+  ASSERT_EQ(SessionID::InvalidValue().id(), -1);
+
+  adblock::SubscriptionServiceFactory::GetForBrowserContext(
+      browser()->profile()->GetOriginalProfile())
+      ->GetFilteringConfiguration(adblock::kAdblockFilteringConfigurationName)
+      ->RemoveCustomFilter(adblock::kAllowlistEverythingFilter);
+  // Allow requests for filter lists to be "downloaded" immediately, otherwise
+  // the tests will hang for 30 seconds.
+  adblock::AdblockRequestThrottleFactory::GetForBrowserContext(
+      browser()->profile()->GetOriginalProfile())
+      ->AllowRequestsAfter(base::Seconds(0));
+
+  AdblockChromeContentBrowserClient::ForceAdblockProxyForTesting();
+}
+
+bool AdblockPrivateApiTestBase::IsIncognito() {
+  return false;
+}
+
+std::string AdblockPrivateApiTestBase::GetApiEndpoint() {
+  return "adblockPrivate";
+}
+
+bool AdblockPrivateApiTestBase::RunTest(const std::string& subtest) {
+  std::string page_url = "main.html?subtest=" + subtest;
+  page_url += "&api=" + GetApiEndpoint();
+  return RunExtensionTest("adblock_private",
+                          {.extension_url = page_url.c_str()},
+                          {.allow_in_incognito = IsIncognito(),
+                           .load_as_component = !IsIncognito()});
+}
+
+bool AdblockPrivateApiTestBase::RunTestWithParams(
+    const std::string& subtest,
+    const std::map<std::string, std::string>& params) {
+  if (params.empty()) {
+    return RunTest(subtest);
+  }
+  std::string subtest_with_params = subtest;
+  for (const auto& [key, value] : params) {
+    subtest_with_params += "&" + key + "=" + value;
+  }
+  return RunTest(subtest_with_params);
+}
+
+void AdblockPrivateApiTestBase::AllowTestExtension(
+    base::CommandLine* command_line) {
+  command_line->AppendSwitchASCII(switches::kAllowlistedExtensionID,
+                                  "hfkjbmnbjpodjjpikbpnphphoimfacom");
+}
+
+void AdblockPrivateApiTestBase::EnableIncognitoMode(
+    base::CommandLine* command_line) {
+  command_line->AppendSwitch(::switches::kIncognito);
+}
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h
new file mode 100644
--- /dev/null
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h
@@ -0,0 +1,62 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_ADBLOCK_PRIVATE_ADBLOCK_PRIVATE_APITEST_BASE_H_
+#define CHROME_BROWSER_EXTENSIONS_API_ADBLOCK_PRIVATE_ADBLOCK_PRIVATE_APITEST_BASE_H_
+
+#include <map>
+#include <string>
+
+#include "base/command_line.h"
+#include "chrome/browser/extensions/extension_apitest.h"
+#include "content/public/test/browser_test.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace extensions {
+
+class AdblockPrivateApiTestBase : public ExtensionApiTest {
+ public:
+  enum class Mode { Normal, Incognito };
+  enum class EyeoExtensionApi { Old, New };
+
+  AdblockPrivateApiTestBase() {}
+  ~AdblockPrivateApiTestBase() override = default;
+  AdblockPrivateApiTestBase(const AdblockPrivateApiTestBase&) = delete;
+  AdblockPrivateApiTestBase& operator=(const AdblockPrivateApiTestBase&) =
+      delete;
+
+  void SetUpCommandLine(base::CommandLine* command_line) override;
+  void SetUpOnMainThread() override;
+
+  virtual bool IsIncognito();
+
+  virtual std::string GetApiEndpoint();
+
+  virtual bool RunTest(const std::string& subtest);
+
+  virtual bool RunTestWithParams(
+      const std::string& subtest,
+      const std::map<std::string, std::string>& params);
+
+ private:
+  void AllowTestExtension(base::CommandLine* command_line);
+
+  void EnableIncognitoMode(base::CommandLine* command_line);
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_ADBLOCK_PRIVATE_ADBLOCK_PRIVATE_APITEST_BASE_H_
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_filter_lists_with_http_server_apitest.cc b/chrome/browser/extensions/api/adblock_private/adblock_private_filter_lists_with_http_server_apitest.cc
new file mode 100644
--- /dev/null
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_filter_lists_with_http_server_apitest.cc
@@ -0,0 +1,188 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <memory>
+
+#include "chrome/browser/extensions/api/adblock_private/adblock_private_apitest_base.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/test/adblock_browsertest_base.h"
+#include "components/adblock/core/subscription/subscription_config.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "net/dns/mock_host_resolver.h"
+#include "net/test/embedded_test_server/embedded_test_server.h"
+#include "net/test/embedded_test_server/http_request.h"
+#include "net/test/embedded_test_server/http_response.h"
+
+namespace extensions {
+
+/**
+ * Extension tests which require intercepting and returning content
+ * for filter lists download requests.
+ */
+class AdblockPrivateApiFilterListWithHttpServer
+    : public AdblockPrivateApiTestBase,
+      public testing::WithParamInterface<
+          std::tuple<AdblockPrivateApiTestBase::EyeoExtensionApi,
+                     AdblockPrivateApiTestBase::Mode>> {
+ public:
+  AdblockPrivateApiFilterListWithHttpServer()
+      : https_server_(net::EmbeddedTestServer::TYPE_HTTPS) {
+    const auto testing_interval = base::Seconds(1);
+    adblock::SubscriptionServiceFactory::SetUpdateCheckIntervalForTesting(
+        testing_interval);
+    https_server_.RegisterRequestHandler(base::BindRepeating(
+        &AdblockPrivateApiFilterListWithHttpServer::RequestHandler,
+        base::Unretained(this)));
+    net::EmbeddedTestServer::ServerCertificateConfig cert_config;
+    cert_config.dns_names = {kEyeoFilterListHost};
+    https_server_.SetSSLConfig(cert_config);
+    EXPECT_TRUE(https_server_.Start());
+    adblock::SetFilterListServerPortForTesting(https_server_.port());
+    geolocated_list_1_ =
+        base::StringPrintf("https://%s:%d/easylistpolish.txt",
+                           kEyeoFilterListHost, https_server_.port());
+    geolocated_list_2_ =
+        base::StringPrintf("https://%s:%d/easylistgermany.txt",
+                           kEyeoFilterListHost, https_server_.port());
+  }
+
+  ~AdblockPrivateApiFilterListWithHttpServer() override = default;
+  AdblockPrivateApiFilterListWithHttpServer(
+      const AdblockPrivateApiFilterListWithHttpServer&) = delete;
+  AdblockPrivateApiFilterListWithHttpServer& operator=(
+      const AdblockPrivateApiFilterListWithHttpServer&) = delete;
+
+  bool IsIncognito() override {
+    return std::get<1>(GetParam()) ==
+           AdblockPrivateApiTestBase::Mode::Incognito;
+  }
+
+  std::string GetApiEndpoint() override {
+    return std::get<0>(GetParam()) ==
+                   AdblockPrivateApiTestBase::EyeoExtensionApi::Old
+               ? "adblockPrivate"
+               : "eyeoFilteringPrivate";
+  }
+
+  std::unique_ptr<net::test_server::HttpResponse> RequestHandler(
+      const net::test_server::HttpRequest& request) {
+    if (base::StartsWith(request.relative_url, "/recommendations.json")) {
+      std::unique_ptr<net::test_server::BasicHttpResponse> http_response(
+          new net::test_server::BasicHttpResponse);
+      http_response->set_code(net::HTTP_OK);
+      auto payload = base::StringPrintf(
+          R"(
+          [{"url": "%s"}, {"url": "%s"}]
+        )",
+          geolocated_list_1_.c_str(), geolocated_list_2_.c_str());
+      http_response->set_content(payload);
+      http_response->set_content_type("text/plain");
+      return std::move(http_response);
+    } else if (base::StartsWith(request.relative_url, "/easylistpolish.txt") ||
+               base::StartsWith(request.relative_url, "/easylistgermany.txt") ||
+               base::StartsWith(request.relative_url, "/easylist.txt") ||
+               base::StartsWith(request.relative_url, "/exceptionrules.txt") ||
+               base::StartsWith(request.relative_url,
+                                "/abp-filters-anti-cv.txt")) {
+      std::unique_ptr<net::test_server::BasicHttpResponse> http_response(
+          new net::test_server::BasicHttpResponse);
+      http_response->set_code(net::HTTP_OK);
+      auto filename = request.GetURL().path();
+      auto filter_list_header =
+          base::StringPrintf("[Adblock Plus 2.0]\n! Version: %zu\n! Title: %s",
+                             filename.length(), filename.c_str());
+      http_response->set_content(filter_list_header);
+      http_response->set_content_type("text/plain");
+      return std::move(http_response);
+    }
+
+    // Unhandled requests result in the Embedded test server sending a 404.
+    // This is fine for the purpose of this test.
+    return nullptr;
+  }
+
+  void SetUpOnMainThread() override {
+    AdblockPrivateApiTestBase::SetUpOnMainThread();
+    host_resolver()->AddRule(kEyeoFilterListHost, "127.0.0.1");
+  }
+
+  void WaitForGeolocatedLists() {
+    std::vector<GURL> subscriptions = {GURL(geolocated_list_1_),
+                                       GURL(geolocated_list_2_)};
+    WaitForLists(subscriptions);
+  }
+
+  void WaitForDefaultLists() {
+    std::vector<GURL> subscriptions = {
+        GURL(base::StringPrintf("https://%s:%d/easylist.txt",
+                                kEyeoFilterListHost, https_server_.port())),
+        GURL(base::StringPrintf("https://%s:%d/exceptionrules.txt",
+                                kEyeoFilterListHost, https_server_.port())),
+        GURL(base::StringPrintf("https://%s:%d/abp-filters-anti-cv.txt",
+                                kEyeoFilterListHost, https_server_.port()))};
+    WaitForLists(subscriptions);
+  }
+
+ protected:
+  net::EmbeddedTestServer https_server_;
+  std::string geolocated_list_1_;
+  std::string geolocated_list_2_;
+
+ private:
+  void WaitForLists(const std::vector<GURL>& subscriptions) {
+    auto* subscription_service =
+        adblock::SubscriptionServiceFactory::GetForBrowserContext(
+            browser()->profile()->GetOriginalProfile());
+    auto waiter = adblock::SubscriptionInstalledWaiter(subscription_service);
+    waiter.WaitUntilSubscriptionsInstalled(std::move(subscriptions));
+  }
+  static constexpr char kEyeoFilterListHost[] =
+      "easylist-downloads.adblockplus.org";
+};
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiFilterListWithHttpServer,
+                       InstalledSubscriptionsDataSchema) {
+  WaitForDefaultLists();
+  EXPECT_TRUE(RunTest("installedSubscriptionsDataSchema")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiFilterListWithHttpServer,
+                       InstalledSubscriptionsDataSchemaConfigDisabled) {
+  EXPECT_TRUE(RunTestWithParams("installedSubscriptionsDataSchema",
+                                {{"disabled", "true"}}))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(AdblockPrivateApiFilterListWithHttpServer,
+                       GeolocationDiabledHidesFilterLists) {
+  WaitForGeolocatedLists();
+  EXPECT_TRUE(RunTestWithParams("disableGeolocation",
+                                {{"geolocated_list_1", geolocated_list_1_},
+                                 {"geolocated_list_2", geolocated_list_2_}}))
+      << message_;
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    ,
+    AdblockPrivateApiFilterListWithHttpServer,
+    testing::Combine(
+        testing::Values(AdblockPrivateApiTestBase::EyeoExtensionApi::Old,
+                        AdblockPrivateApiTestBase::EyeoExtensionApi::New),
+        testing::Values(AdblockPrivateApiTestBase::Mode::Normal,
+                        AdblockPrivateApiTestBase::Mode::Incognito)));
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/api_browser_context_keyed_service_factories.cc b/chrome/browser/extensions/api/api_browser_context_keyed_service_factories.cc
--- a/chrome/browser/extensions/api/api_browser_context_keyed_service_factories.cc
+++ b/chrome/browser/extensions/api/api_browser_context_keyed_service_factories.cc
@@ -1,6 +1,10 @@
 // Copyright 2022 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/browser/extensions/api/bookmarks/bookmarks_api.h"
 #include "chrome/browser/extensions/api/bookmarks/bookmarks_api_watcher.h"
@@ -35,10 +39,12 @@
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
 #include "chrome/browser/extensions/api/activity_log_private/activity_log_private_api.h"
+#include "chrome/browser/extensions/api/adblock_private/adblock_private_api.h"
 #include "chrome/browser/extensions/api/autofill_private/autofill_private_event_router_factory.h"
 #include "chrome/browser/extensions/api/bookmark_manager_private/bookmark_manager_private_api.h"
 #include "chrome/browser/extensions/api/braille_display_private/braille_display_private_api.h"
 #include "chrome/browser/extensions/api/enterprise_reporting_private/enterprise_reporting_private_event_router.h"
+#include "chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.h"
 #include "chrome/browser/extensions/api/image_writer_private/operation_manager.h"
 #include "chrome/browser/extensions/api/language_settings_private/language_settings_private_delegate_factory.h"
 #include "chrome/browser/extensions/api/networking_private/networking_private_ui_delegate_factory_impl.h"
@@ -109,6 +115,8 @@ void EnsureApiBrowserContextKeyedServiceFactoriesBuilt() {
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   extensions::ActivityLogAPI::GetFactoryInstance();
+  extensions::AdblockPrivateAPI::GetFactoryInstance();
+  extensions::EyeoFilteringPrivateAPI::GetFactoryInstance();
   extensions::AutofillPrivateEventRouterFactory::GetInstance();
   extensions::BluetoothLowEnergyAPI::GetFactoryInstance();
   extensions::BookmarkManagerPrivateAPI::GetFactoryInstance();
diff --git a/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.cc b/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.cc
new file mode 100644
--- /dev/null
+++ b/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.cc
@@ -0,0 +1,819 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.h"
+
+#include "base/containers/flat_map.h"
+#include "base/i18n/time_formatting.h"
+#include "base/logging.h"
+#include "base/no_destructor.h"
+#include "base/values.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/common/extensions/api/tabs.h"
+#include "components/adblock/content/browser/factories/resource_classification_runner_factory.h"
+#include "components/adblock/content/browser/factories/session_stats_factory.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/content/browser/resource_classification_runner.h"
+#include "components/adblock/core/common/adblock_prefs.h"
+#include "components/adblock/core/common/adblock_utils.h"
+#include "components/adblock/core/common/content_type.h"
+#include "components/adblock/core/configuration/filtering_configuration.h"
+#include "components/adblock/core/configuration/persistent_filtering_configuration.h"
+#include "components/adblock/core/session_stats.h"
+#include "components/adblock/core/subscription/subscription_config.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "components/prefs/pref_service.h"
+#include "components/sessions/core/session_id.h"
+#include "content/public/browser/web_contents.h"
+#include "url/gurl.h"
+namespace extensions {
+
+namespace {
+
+constexpr char kConfigurationMissing[] =
+    "Configuration with name '%s' does not exist!";
+
+adblock::FilteringConfiguration* FindFilteringConfiguration(
+    content::BrowserContext* context,
+    const std::string& config_name) {
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(context);
+  const auto installed_configurations =
+      subscription_service->GetInstalledFilteringConfigurations();
+  auto configuration_it =
+      std::ranges::find(installed_configurations, config_name,
+                        &adblock::FilteringConfiguration::GetName);
+  return configuration_it != installed_configurations.end() ? *configuration_it
+                                                            : nullptr;
+}
+
+enum class SubscriptionAction { kInstall, kUninstall };
+
+std::string RunSubscriptionAction(
+    adblock::FilteringConfiguration* configuration,
+    SubscriptionAction action,
+    const GURL& url) {
+  if (!url.is_valid()) {
+    return "Invalid URL";
+  }
+  switch (action) {
+    case SubscriptionAction::kInstall:
+      configuration->AddFilterList(url);
+      break;
+    case SubscriptionAction::kUninstall:
+      configuration->RemoveFilterList(url);
+      break;
+    default:
+      NOTREACHED();
+  }
+
+  return {};
+}
+
+std::vector<api::eyeo_filtering_private::SessionStatsEntry> CopySessionsStats(
+    const std::map<GURL, long>& source) {
+  std::vector<api::eyeo_filtering_private::SessionStatsEntry> result;
+  for (auto& entry : source) {
+    api::eyeo_filtering_private::SessionStatsEntry js_entry;
+    js_entry.url = entry.first.spec();
+    js_entry.count = entry.second;
+    result.emplace_back(std::move(js_entry));
+  }
+  return result;
+}
+
+std::string SubscriptionInstallationStateToString(
+    adblock::Subscription::InstallationState state) {
+  using State = adblock::Subscription::InstallationState;
+  switch (state) {
+    case State::Installed:
+      return "Installed";
+    case State::AutoInstalled:
+      return "AutoInstalled";
+    case State::Preloaded:
+      return "Preloaded";
+    case State::Installing:
+      return "Installing";
+    case State::Unknown:
+      return "Unknown";
+  }
+  return "";
+}
+
+std::vector<api::eyeo_filtering_private::Subscription> CopySubscriptions(
+    const std::vector<scoped_refptr<adblock::Subscription>>
+        current_subscriptions) {
+  std::vector<api::eyeo_filtering_private::Subscription> result;
+  for (auto& sub : current_subscriptions) {
+    api::eyeo_filtering_private::Subscription js_sub;
+    js_sub.url = sub->GetSourceUrl().spec();
+    js_sub.title = sub->GetTitle();
+    js_sub.current_version = sub->GetCurrentVersion();
+    js_sub.installation_state =
+        SubscriptionInstallationStateToString(sub->GetInstallationState());
+    const auto installation_time = sub->GetInstallationTime();
+    js_sub.last_installation_time =
+        installation_time.is_null()
+            ? ""
+            : base::TimeFormatAsIso8601(sub->GetInstallationTime());
+    result.emplace_back(std::move(js_sub));
+  }
+  return result;
+}
+
+content::BrowserContext* GetOriginalBrowserContext(
+    content::BrowserContext* browser_context) {
+  return Profile::FromBrowserContext(browser_context)->GetOriginalProfile();
+}
+
+}  // namespace
+
+class EyeoFilteringPrivateAPI::EyeoFilteringAPIEventRouter
+    : public adblock::ResourceClassificationRunner::Observer,
+      public adblock::SubscriptionService::SubscriptionObserver,
+      public adblock::FilteringConfiguration::Observer {
+ public:
+  explicit EyeoFilteringAPIEventRouter(content::BrowserContext* context)
+      : context_(GetOriginalBrowserContext(context)) {
+    adblock::ResourceClassificationRunnerFactory::GetForBrowserContext(context_)
+        ->AddObserver(this);
+    auto* subscription_service =
+        adblock::SubscriptionServiceFactory::GetForBrowserContext(context_);
+    subscription_service->AddObserver(this);
+    for (auto* it :
+         subscription_service->GetInstalledFilteringConfigurations()) {
+      it->AddObserver(this);
+    }
+  }
+
+  ~EyeoFilteringAPIEventRouter() override {
+    adblock::ResourceClassificationRunnerFactory::GetForBrowserContext(context_)
+        ->RemoveObserver(this);
+    auto* subscription_service =
+        adblock::SubscriptionServiceFactory::GetForBrowserContext(context_);
+    subscription_service->RemoveObserver(this);
+    for (auto* it :
+         subscription_service->GetInstalledFilteringConfigurations()) {
+      it->RemoveObserver(this);
+    }
+  }
+
+  // adblock::ResourceClassificationRunner::Observer:
+  void OnRequestMatched(const GURL& url,
+                        adblock::FilterMatchResult match_result,
+                        const std::vector<GURL>& parent_frame_urls,
+                        adblock::ContentType content_type,
+                        content::RenderFrameHost* render_frame_host,
+                        const GURL& subscription,
+                        const std::string& configuration_name) override {
+    std::unique_ptr<Event> event;
+    api::eyeo_filtering_private::RequestInfo info = CreateRequestInfoObject(
+        url, subscription, configuration_name, render_frame_host);
+    info.parent_frame_urls = adblock::utils::ConvertURLs(parent_frame_urls);
+    info.content_type = adblock::ContentTypeToString(content_type);
+
+    if (match_result == adblock::FilterMatchResult::kBlockRule) {
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT,
+          api::eyeo_filtering_private::OnRequestBlocked::kEventName,
+          api::eyeo_filtering_private::OnRequestBlocked::Create(info));
+    } else {
+      DCHECK(match_result == adblock::FilterMatchResult::kAllowRule);
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT,
+          api::eyeo_filtering_private::OnRequestAllowed::kEventName,
+          api::eyeo_filtering_private::OnRequestAllowed::Create(info));
+    }
+
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnPageAllowed(const GURL& url,
+                     content::RenderFrameHost* render_frame_host,
+                     const GURL& subscription,
+                     const std::string& configuration_name) override {
+    api::eyeo_filtering_private::RequestInfo info = CreateRequestInfoObject(
+        url, subscription, configuration_name, render_frame_host);
+    info.parent_frame_urls = std::vector<std::string>{};
+    info.content_type = "";
+
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::eyeo_filtering_private::OnPageAllowed::kEventName,
+        api::eyeo_filtering_private::OnPageAllowed::Create(info));
+
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnPopupMatched(const GURL& url,
+                      adblock::FilterMatchResult match_result,
+                      const GURL& opener_url,
+                      content::RenderFrameHost* render_frame_host,
+                      const GURL& subscription,
+                      const std::string& configuration_name) override {
+    std::unique_ptr<Event> event;
+    api::eyeo_filtering_private::RequestInfo info = CreateRequestInfoObject(
+        url, subscription, configuration_name, render_frame_host);
+    info.parent_frame_urls = std::vector<std::string>{opener_url.spec()};
+    info.content_type = "";
+
+    if (match_result == adblock::FilterMatchResult::kBlockRule) {
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT,
+          api::eyeo_filtering_private::OnPopupBlocked::kEventName,
+          api::eyeo_filtering_private::OnPopupBlocked::Create(info));
+    } else {
+      DCHECK(match_result == adblock::FilterMatchResult::kAllowRule);
+      event = std::make_unique<Event>(
+          events::EYEO_EVENT,
+          api::eyeo_filtering_private::OnPopupAllowed::kEventName,
+          api::eyeo_filtering_private::OnPopupAllowed::Create(info));
+    }
+
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  // adblock::SubscriptionService::SubscriptionObserver:
+  void OnSubscriptionInstalled(const GURL& url) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::eyeo_filtering_private::OnSubscriptionUpdated::kEventName,
+        api::eyeo_filtering_private::OnSubscriptionUpdated::Create(url.spec()));
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnFilteringConfigurationInstalled(
+      adblock::FilteringConfiguration* config) override {
+    config->AddObserver(this);
+  }
+
+  // adblock::FilteringConfiguration::Observer:
+  void OnEnabledStateChanged(adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::eyeo_filtering_private::OnEnabledStateChanged::kEventName,
+        api::eyeo_filtering_private::OnEnabledStateChanged::Create(
+            config->GetName()));
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnFilterListsChanged(adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::eyeo_filtering_private::OnFilterListsChanged::kEventName,
+        api::eyeo_filtering_private::OnFilterListsChanged::Create(
+            config->GetName()));
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnAllowedDomainsChanged(
+      adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::eyeo_filtering_private::OnAllowedDomainsChanged::kEventName,
+        api::eyeo_filtering_private::OnAllowedDomainsChanged::Create(
+            config->GetName()));
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+  void OnCustomFiltersChanged(
+      adblock::FilteringConfiguration* config) override {
+    std::unique_ptr<Event> event = std::make_unique<Event>(
+        events::EYEO_EVENT,
+        api::eyeo_filtering_private::OnCustomFiltersChanged::kEventName,
+        api::eyeo_filtering_private::OnCustomFiltersChanged::Create(
+            config->GetName()));
+    extensions::EventRouter::Get(context_)->BroadcastEvent(std::move(event));
+  }
+
+ private:
+  api::eyeo_filtering_private::RequestInfo CreateRequestInfoObject(
+      const GURL& url,
+      const GURL& subscription,
+      const std::string& configuration_name,
+      content::RenderFrameHost* render_frame_host) {
+    DCHECK(render_frame_host);
+    api::eyeo_filtering_private::RequestInfo info;
+    info.url = url.spec();
+    info.subscription = subscription.spec();
+    info.configuration_name = configuration_name;
+    info.tab_id = api::tabs::TAB_ID_NONE;
+    info.window_id = SessionID::InvalidValue().id();
+    const content::WebContents* wc =
+        content::WebContents::FromRenderFrameHost(render_frame_host);
+    if (wc) {
+      info.tab_id = ExtensionTabUtil::GetTabId(wc);
+      info.window_id = ExtensionTabUtil::GetWindowIdOfTab(wc);
+    }
+    return info;
+  }
+
+  const raw_ptr<content::BrowserContext> context_;
+};
+
+template <>
+void BrowserContextKeyedAPIFactory<
+    EyeoFilteringPrivateAPI>::DeclareFactoryDependencies() {
+  DependsOn(adblock::SubscriptionServiceFactory::GetInstance());
+}
+
+// static
+BrowserContextKeyedAPIFactory<EyeoFilteringPrivateAPI>*
+EyeoFilteringPrivateAPI::GetFactoryInstance() {
+  static base::NoDestructor<
+      BrowserContextKeyedAPIFactory<EyeoFilteringPrivateAPI>>
+      instance;
+  return instance.get();
+}
+
+// static
+EyeoFilteringPrivateAPI* EyeoFilteringPrivateAPI::Get(
+    content::BrowserContext* context) {
+  return GetFactoryInstance()->Get(context);
+}
+
+EyeoFilteringPrivateAPI::EyeoFilteringPrivateAPI(
+    content::BrowserContext* context)
+    : context_(context) {
+  // EventRouter can be null in tests
+  auto* ev = EventRouter::Get(context_);
+  if (ev) {
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnRequestAllowed::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnRequestBlocked::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnPageAllowed::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnPopupAllowed::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnPopupBlocked::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnSubscriptionUpdated::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnEnabledStateChanged::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnFilterListsChanged::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnAllowedDomainsChanged::kEventName);
+    ev->RegisterObserver(
+        this, api::eyeo_filtering_private::OnCustomFiltersChanged::kEventName);
+  }
+  // Make sure SessionStats is created so it will start collectings stats
+  adblock::SessionStatsFactory::GetForBrowserContext(context);
+}
+
+EyeoFilteringPrivateAPI::~EyeoFilteringPrivateAPI() = default;
+
+void EyeoFilteringPrivateAPI::Shutdown() {
+  // EventRouter can be null in tests
+  if (EventRouter::Get(context_)) {
+    EventRouter::Get(context_)->UnregisterObserver(this);
+  }
+  event_router_.reset();
+}
+
+void EyeoFilteringPrivateAPI::OnListenerAdded(
+    const extensions::EventListenerInfo& details) {
+  event_router_ =
+      std::make_unique<EyeoFilteringPrivateAPI::EyeoFilteringAPIEventRouter>(
+          context_);
+  EventRouter::Get(context_)->UnregisterObserver(this);
+}
+
+namespace api {
+
+EyeoFilteringPrivateCreateConfigurationFunction::
+    EyeoFilteringPrivateCreateConfigurationFunction() = default;
+
+EyeoFilteringPrivateCreateConfigurationFunction::
+    ~EyeoFilteringPrivateCreateConfigurationFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateCreateConfigurationFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::CreateConfiguration::Params>
+      params(api::eyeo_filtering_private::CreateConfiguration::Params::Create(
+          args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+  const auto installed_configurations =
+      subscription_service->GetInstalledFilteringConfigurations();
+  auto configuration_it =
+      std::ranges::find(installed_configurations, params->config_name,
+                         &adblock::FilteringConfiguration::GetName);
+  if (configuration_it == installed_configurations.end()) {
+    auto new_filtering_configuration =
+        std::make_unique<adblock::PersistentFilteringConfiguration>(
+            Profile::FromBrowserContext(
+                GetOriginalBrowserContext(browser_context()))
+                ->GetPrefs(),
+            params->config_name);
+    subscription_service->InstallFilteringConfiguration(
+        std::move(new_filtering_configuration));
+  }
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateRemoveConfigurationFunction::
+    EyeoFilteringPrivateRemoveConfigurationFunction() = default;
+
+EyeoFilteringPrivateRemoveConfigurationFunction::
+    ~EyeoFilteringPrivateRemoveConfigurationFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateRemoveConfigurationFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::RemoveConfiguration::Params>
+      params(api::eyeo_filtering_private::RemoveConfiguration::Params::Create(
+          args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+  const auto installed_configurations =
+      subscription_service->GetInstalledFilteringConfigurations();
+  auto configuration_it =
+      std::ranges::find(installed_configurations, params->config_name,
+                         &adblock::FilteringConfiguration::GetName);
+  if (configuration_it != installed_configurations.end()) {
+    subscription_service->UninstallFilteringConfiguration(
+        std::string((*configuration_it)->GetName()));
+  }
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateGetConfigurationsFunction::
+    EyeoFilteringPrivateGetConfigurationsFunction() = default;
+
+EyeoFilteringPrivateGetConfigurationsFunction::
+    ~EyeoFilteringPrivateGetConfigurationsFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateGetConfigurationsFunction::Run() {
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+  const auto installed_configurations =
+      subscription_service->GetInstalledFilteringConfigurations();
+  std::vector<std::string> configurations;
+  std::ranges::transform(installed_configurations,
+                          std::back_inserter(configurations),
+                          [](adblock::FilteringConfiguration* config) {
+                            return config->GetName();
+                          });
+  return RespondNow(ArgumentList(
+      api::eyeo_filtering_private::GetConfigurations::Results::Create(
+          std::move(configurations))));
+}
+
+EyeoFilteringPrivateSetAutoInstallEnabledFunction::
+    EyeoFilteringPrivateSetAutoInstallEnabledFunction() {}
+
+EyeoFilteringPrivateSetAutoInstallEnabledFunction::
+    ~EyeoFilteringPrivateSetAutoInstallEnabledFunction() {}
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateSetAutoInstallEnabledFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::SetAutoInstallEnabled::Params>
+      params =
+          api::eyeo_filtering_private::SetAutoInstallEnabled::Params::Create(
+              args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+  subscription_service->SetAutoInstallEnabled(params->enabled);
+
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateIsAutoInstallEnabledFunction::
+    EyeoFilteringPrivateIsAutoInstallEnabledFunction() {}
+
+EyeoFilteringPrivateIsAutoInstallEnabledFunction::
+    ~EyeoFilteringPrivateIsAutoInstallEnabledFunction() {}
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateIsAutoInstallEnabledFunction::Run() {
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+
+  return RespondNow(ArgumentList(
+      api::eyeo_filtering_private::IsAutoInstallEnabled::Results::Create(
+          subscription_service->IsAutoInstallEnabled())));
+}
+
+EyeoFilteringPrivateSetEnabledFunction::
+    EyeoFilteringPrivateSetEnabledFunction() = default;
+
+EyeoFilteringPrivateSetEnabledFunction::
+    ~EyeoFilteringPrivateSetEnabledFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateSetEnabledFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::SetEnabled::Params> params(
+      api::eyeo_filtering_private::SetEnabled::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  configuration->SetEnabled(params->enabled);
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateIsEnabledFunction::EyeoFilteringPrivateIsEnabledFunction() {
+}
+
+EyeoFilteringPrivateIsEnabledFunction::
+    ~EyeoFilteringPrivateIsEnabledFunction() = default;
+
+ExtensionFunction::ResponseAction EyeoFilteringPrivateIsEnabledFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::IsEnabled::Params> params(
+      api::eyeo_filtering_private::IsEnabled::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  return RespondNow(
+      ArgumentList(api::eyeo_filtering_private::IsEnabled::Results::Create(
+          configuration->IsEnabled())));
+}
+
+EyeoFilteringPrivateGetAcceptableAdsUrlFunction::
+    EyeoFilteringPrivateGetAcceptableAdsUrlFunction() = default;
+
+EyeoFilteringPrivateGetAcceptableAdsUrlFunction::
+    ~EyeoFilteringPrivateGetAcceptableAdsUrlFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateGetAcceptableAdsUrlFunction::Run() {
+  return RespondNow(ArgumentList(
+      api::eyeo_filtering_private::GetAcceptableAdsUrl::Results::Create(
+          adblock::AcceptableAdsUrl().spec())));
+}
+
+EyeoFilteringPrivateAddFilterListFunction::
+    EyeoFilteringPrivateAddFilterListFunction() = default;
+
+EyeoFilteringPrivateAddFilterListFunction::
+    ~EyeoFilteringPrivateAddFilterListFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateAddFilterListFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::AddFilterList::Params> params(
+      api::eyeo_filtering_private::AddFilterList::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  auto url = GURL{params->url};
+  auto status =
+      RunSubscriptionAction(configuration, SubscriptionAction::kInstall, url);
+  if (!status.empty()) {
+    return RespondNow(Error(status));
+  }
+
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateRemoveFilterListFunction::
+    EyeoFilteringPrivateRemoveFilterListFunction() = default;
+
+EyeoFilteringPrivateRemoveFilterListFunction::
+    ~EyeoFilteringPrivateRemoveFilterListFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateRemoveFilterListFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::RemoveFilterList::Params> params(
+      api::eyeo_filtering_private::RemoveFilterList::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  auto url = GURL{params->url};
+  auto status =
+      RunSubscriptionAction(configuration, SubscriptionAction::kUninstall, url);
+  if (!status.empty()) {
+    return RespondNow(Error(status));
+  }
+
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateGetFilterListsFunction::
+    EyeoFilteringPrivateGetFilterListsFunction() = default;
+
+EyeoFilteringPrivateGetFilterListsFunction::
+    ~EyeoFilteringPrivateGetFilterListsFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateGetFilterListsFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::GetFilterLists::Params> params(
+      api::eyeo_filtering_private::GetFilterLists::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          GetOriginalBrowserContext(browser_context()));
+  return RespondNow(
+      ArgumentList(api::eyeo_filtering_private::GetFilterLists::Results::Create(
+          CopySubscriptions(
+              subscription_service->GetCurrentSubscriptions(configuration)))));
+}
+
+EyeoFilteringPrivateAddAllowedDomainFunction::
+    EyeoFilteringPrivateAddAllowedDomainFunction() = default;
+
+EyeoFilteringPrivateAddAllowedDomainFunction::
+    ~EyeoFilteringPrivateAddAllowedDomainFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateAddAllowedDomainFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::AddAllowedDomain::Params> params(
+      api::eyeo_filtering_private::AddAllowedDomain::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  configuration->AddAllowedDomain(params->domain);
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateRemoveAllowedDomainFunction::
+    EyeoFilteringPrivateRemoveAllowedDomainFunction() = default;
+
+EyeoFilteringPrivateRemoveAllowedDomainFunction::
+    ~EyeoFilteringPrivateRemoveAllowedDomainFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateRemoveAllowedDomainFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::RemoveAllowedDomain::Params>
+      params(api::eyeo_filtering_private::RemoveAllowedDomain::Params::Create(
+          args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  configuration->RemoveAllowedDomain(params->domain);
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateGetAllowedDomainsFunction::
+    EyeoFilteringPrivateGetAllowedDomainsFunction() = default;
+
+EyeoFilteringPrivateGetAllowedDomainsFunction::
+    ~EyeoFilteringPrivateGetAllowedDomainsFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateGetAllowedDomainsFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::GetAllowedDomains::Params> params(
+      api::eyeo_filtering_private::GetAllowedDomains::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  return RespondNow(ArgumentList(
+      api::eyeo_filtering_private::GetCustomFilters::Results::Create(
+          configuration->GetAllowedDomains())));
+}
+
+EyeoFilteringPrivateAddCustomFilterFunction::
+    EyeoFilteringPrivateAddCustomFilterFunction() = default;
+
+EyeoFilteringPrivateAddCustomFilterFunction::
+    ~EyeoFilteringPrivateAddCustomFilterFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateAddCustomFilterFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::AddCustomFilter::Params> params(
+      api::eyeo_filtering_private::AddCustomFilter::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  configuration->AddCustomFilter(params->filter);
+  return RespondNow(NoArguments());
+}
+
+EyeoFilteringPrivateRemoveCustomFilterFunction::
+    EyeoFilteringPrivateRemoveCustomFilterFunction() = default;
+
+EyeoFilteringPrivateRemoveCustomFilterFunction::
+    ~EyeoFilteringPrivateRemoveCustomFilterFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateRemoveCustomFilterFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::RemoveCustomFilter::Params>
+      params(api::eyeo_filtering_private::RemoveCustomFilter::Params::Create(
+          args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  configuration->RemoveCustomFilter(params->filter);
+  return RespondNow(NoArguments());
+}
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateGetCustomFiltersFunction::Run() {
+  absl::optional<api::eyeo_filtering_private::GetCustomFilters::Params> params(
+      api::eyeo_filtering_private::GetCustomFilters::Params::Create(args()));
+  EXTENSION_FUNCTION_VALIDATE(params);
+  auto* configuration = FindFilteringConfiguration(
+      GetOriginalBrowserContext(browser_context()), params->configuration);
+  if (!configuration) {
+    return RespondNow(Error(base::StringPrintf(kConfigurationMissing,
+                                               params->configuration.c_str())));
+  }
+  return RespondNow(ArgumentList(
+      api::eyeo_filtering_private::GetCustomFilters::Results::Create(
+          configuration->GetCustomFilters())));
+}
+
+EyeoFilteringPrivateGetCustomFiltersFunction::
+    EyeoFilteringPrivateGetCustomFiltersFunction() = default;
+
+EyeoFilteringPrivateGetCustomFiltersFunction::
+    ~EyeoFilteringPrivateGetCustomFiltersFunction() = default;
+
+EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction::
+    EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction() = default;
+
+EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction::
+    ~EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction::Run() {
+  auto* session_stats = adblock::SessionStatsFactory::GetForBrowserContext(
+      GetOriginalBrowserContext(browser_context()));
+  return RespondNow(
+      ArgumentList(api::eyeo_filtering_private::GetSessionAllowedRequestsCount::
+                       Results::Create(CopySessionsStats(
+                           session_stats->GetSessionAllowedResourcesCount()))));
+}
+
+EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction::
+    EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction() = default;
+
+EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction::
+    ~EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction() = default;
+
+ExtensionFunction::ResponseAction
+EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction::Run() {
+  auto* session_stats = adblock::SessionStatsFactory::GetForBrowserContext(
+      GetOriginalBrowserContext(browser_context()));
+  return RespondNow(
+      ArgumentList(api::eyeo_filtering_private::GetSessionBlockedRequestsCount::
+                       Results::Create(CopySessionsStats(
+                           session_stats->GetSessionBlockedResourcesCount()))));
+}
+}  // namespace api
+}  // namespace extensions
diff --git a/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.h b/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.h
new file mode 100644
--- /dev/null
+++ b/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.h
@@ -0,0 +1,392 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_API_EYEO_FILTERING_PRIVATE_EYEO_FILTERING_PRIVATE_API_H_
+#define CHROME_BROWSER_EXTENSIONS_API_EYEO_FILTERING_PRIVATE_EYEO_FILTERING_PRIVATE_API_H_
+
+#include "base/memory/raw_ptr.h"
+#include "chrome/common/extensions/api/eyeo_filtering_private.h"
+#include "extensions/browser/browser_context_keyed_api_factory.h"
+#include "extensions/browser/event_router.h"
+#include "extensions/browser/extension_function.h"
+
+namespace extensions {
+
+class EyeoFilteringPrivateAPI : public BrowserContextKeyedAPI,
+                                public EventRouter::Observer {
+ public:
+  static BrowserContextKeyedAPIFactory<EyeoFilteringPrivateAPI>*
+  GetFactoryInstance();
+
+  static EyeoFilteringPrivateAPI* Get(content::BrowserContext* context);
+
+  explicit EyeoFilteringPrivateAPI(content::BrowserContext* context);
+  ~EyeoFilteringPrivateAPI() override;
+  friend class BrowserContextKeyedAPIFactory<EyeoFilteringPrivateAPI>;
+
+  // BrowserContextKeyedAPI implementation.
+  static const char* service_name() { return "EyeoFilteringPrivateAPI"; }
+  static const bool kServiceRedirectedInIncognito = true;
+  static const bool kServiceIsCreatedWithBrowserContext = true;
+  void Shutdown() override;
+
+  // EventRouter::Observer:
+  void OnListenerAdded(const extensions::EventListenerInfo& details) override;
+
+ private:
+  const raw_ptr<content::BrowserContext> context_;
+  class EyeoFilteringAPIEventRouter;
+  std::unique_ptr<EyeoFilteringAPIEventRouter> event_router_;
+};
+
+template <>
+void BrowserContextKeyedAPIFactory<
+    EyeoFilteringPrivateAPI>::DeclareFactoryDependencies();
+
+namespace api {
+
+class EyeoFilteringPrivateCreateConfigurationFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.createConfiguration",
+                             UNKNOWN)
+  EyeoFilteringPrivateCreateConfigurationFunction();
+
+ private:
+  ~EyeoFilteringPrivateCreateConfigurationFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateCreateConfigurationFunction(
+      const EyeoFilteringPrivateCreateConfigurationFunction&) = delete;
+  EyeoFilteringPrivateCreateConfigurationFunction& operator=(
+      const EyeoFilteringPrivateCreateConfigurationFunction&) = delete;
+};
+
+class EyeoFilteringPrivateRemoveConfigurationFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.removeConfiguration",
+                             UNKNOWN)
+  EyeoFilteringPrivateRemoveConfigurationFunction();
+
+ private:
+  ~EyeoFilteringPrivateRemoveConfigurationFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateRemoveConfigurationFunction(
+      const EyeoFilteringPrivateRemoveConfigurationFunction&) = delete;
+  EyeoFilteringPrivateRemoveConfigurationFunction& operator=(
+      const EyeoFilteringPrivateRemoveConfigurationFunction&) = delete;
+};
+
+class EyeoFilteringPrivateGetConfigurationsFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.getConfigurations", UNKNOWN)
+  EyeoFilteringPrivateGetConfigurationsFunction();
+
+ private:
+  ~EyeoFilteringPrivateGetConfigurationsFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateGetConfigurationsFunction(
+      const EyeoFilteringPrivateGetConfigurationsFunction&) = delete;
+  EyeoFilteringPrivateGetConfigurationsFunction& operator=(
+      const EyeoFilteringPrivateGetConfigurationsFunction&) = delete;
+};
+
+class EyeoFilteringPrivateSetAutoInstallEnabledFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.setAutoInstallEnabled",
+                             UNKNOWN)
+  EyeoFilteringPrivateSetAutoInstallEnabledFunction();
+
+ private:
+  ~EyeoFilteringPrivateSetAutoInstallEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateSetAutoInstallEnabledFunction(
+      const EyeoFilteringPrivateSetAutoInstallEnabledFunction&) = delete;
+  EyeoFilteringPrivateSetAutoInstallEnabledFunction& operator=(
+      const EyeoFilteringPrivateSetAutoInstallEnabledFunction&) = delete;
+};
+
+class EyeoFilteringPrivateIsAutoInstallEnabledFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.isAutoInstallEnabled",
+                             UNKNOWN)
+  EyeoFilteringPrivateIsAutoInstallEnabledFunction();
+
+ private:
+  ~EyeoFilteringPrivateIsAutoInstallEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateIsAutoInstallEnabledFunction(
+      const EyeoFilteringPrivateIsAutoInstallEnabledFunction&) = delete;
+  EyeoFilteringPrivateIsAutoInstallEnabledFunction& operator=(
+      const EyeoFilteringPrivateIsAutoInstallEnabledFunction&) = delete;
+};
+
+class EyeoFilteringPrivateSetEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.setEnabled", UNKNOWN)
+  EyeoFilteringPrivateSetEnabledFunction();
+
+ private:
+  ~EyeoFilteringPrivateSetEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateSetEnabledFunction(
+      const EyeoFilteringPrivateSetEnabledFunction&) = delete;
+  EyeoFilteringPrivateSetEnabledFunction& operator=(
+      const EyeoFilteringPrivateSetEnabledFunction&) = delete;
+};
+
+class EyeoFilteringPrivateIsEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.isEnabled", UNKNOWN)
+  EyeoFilteringPrivateIsEnabledFunction();
+
+ private:
+  ~EyeoFilteringPrivateIsEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateIsEnabledFunction(
+      const EyeoFilteringPrivateIsEnabledFunction&) = delete;
+  EyeoFilteringPrivateIsEnabledFunction& operator=(
+      const EyeoFilteringPrivateIsEnabledFunction&) = delete;
+};
+
+class EyeoFilteringPrivateGetAcceptableAdsUrlFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.getAcceptableAdsUrl",
+                             UNKNOWN)
+  EyeoFilteringPrivateGetAcceptableAdsUrlFunction();
+
+ private:
+  ~EyeoFilteringPrivateGetAcceptableAdsUrlFunction() override;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateGetAcceptableAdsUrlFunction(
+      const EyeoFilteringPrivateGetAcceptableAdsUrlFunction&) = delete;
+  EyeoFilteringPrivateGetAcceptableAdsUrlFunction& operator=(
+      const EyeoFilteringPrivateGetAcceptableAdsUrlFunction&) = delete;
+};
+
+class EyeoFilteringPrivateAddFilterListFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.addFilterList", UNKNOWN)
+  EyeoFilteringPrivateAddFilterListFunction();
+
+ private:
+  ~EyeoFilteringPrivateAddFilterListFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateAddFilterListFunction(
+      const EyeoFilteringPrivateAddFilterListFunction&) = delete;
+  EyeoFilteringPrivateAddFilterListFunction& operator=(
+      const EyeoFilteringPrivateAddFilterListFunction&) = delete;
+};
+
+class EyeoFilteringPrivateRemoveFilterListFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.removeFilterList", UNKNOWN)
+  EyeoFilteringPrivateRemoveFilterListFunction();
+
+ private:
+  ~EyeoFilteringPrivateRemoveFilterListFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateRemoveFilterListFunction(
+      const EyeoFilteringPrivateRemoveFilterListFunction&) = delete;
+  EyeoFilteringPrivateRemoveFilterListFunction& operator=(
+      const EyeoFilteringPrivateRemoveFilterListFunction&) = delete;
+};
+
+class EyeoFilteringPrivateGetFilterListsFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.getFilterLists", UNKNOWN)
+  EyeoFilteringPrivateGetFilterListsFunction();
+
+ private:
+  ~EyeoFilteringPrivateGetFilterListsFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateGetFilterListsFunction(
+      const EyeoFilteringPrivateGetFilterListsFunction&) = delete;
+  EyeoFilteringPrivateGetFilterListsFunction& operator=(
+      const EyeoFilteringPrivateGetFilterListsFunction&) = delete;
+};
+
+class EyeoFilteringPrivateAddAllowedDomainFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.addAllowedDomain", UNKNOWN)
+  EyeoFilteringPrivateAddAllowedDomainFunction();
+
+ private:
+  ~EyeoFilteringPrivateAddAllowedDomainFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateAddAllowedDomainFunction(
+      const EyeoFilteringPrivateAddAllowedDomainFunction&) = delete;
+  EyeoFilteringPrivateAddAllowedDomainFunction& operator=(
+      const EyeoFilteringPrivateAddAllowedDomainFunction&) = delete;
+};
+
+class EyeoFilteringPrivateRemoveAllowedDomainFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.removeAllowedDomain",
+                             UNKNOWN)
+  EyeoFilteringPrivateRemoveAllowedDomainFunction();
+
+ private:
+  ~EyeoFilteringPrivateRemoveAllowedDomainFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateRemoveAllowedDomainFunction(
+      const EyeoFilteringPrivateRemoveAllowedDomainFunction&) = delete;
+  EyeoFilteringPrivateRemoveAllowedDomainFunction& operator=(
+      const EyeoFilteringPrivateRemoveAllowedDomainFunction&) = delete;
+};
+
+class EyeoFilteringPrivateGetAllowedDomainsFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.getAllowedDomains", UNKNOWN)
+  EyeoFilteringPrivateGetAllowedDomainsFunction();
+
+ private:
+  ~EyeoFilteringPrivateGetAllowedDomainsFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateGetAllowedDomainsFunction(
+      const EyeoFilteringPrivateGetAllowedDomainsFunction&) = delete;
+  EyeoFilteringPrivateGetAllowedDomainsFunction& operator=(
+      const EyeoFilteringPrivateGetAllowedDomainsFunction&) = delete;
+};
+
+class EyeoFilteringPrivateAddCustomFilterFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.addCustomFilter", UNKNOWN)
+  EyeoFilteringPrivateAddCustomFilterFunction();
+
+ private:
+  ~EyeoFilteringPrivateAddCustomFilterFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateAddCustomFilterFunction(
+      const EyeoFilteringPrivateAddCustomFilterFunction&) = delete;
+  EyeoFilteringPrivateAddCustomFilterFunction& operator=(
+      const EyeoFilteringPrivateAddCustomFilterFunction&) = delete;
+};
+
+class EyeoFilteringPrivateRemoveCustomFilterFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.removeCustomFilter", UNKNOWN)
+  EyeoFilteringPrivateRemoveCustomFilterFunction();
+
+ private:
+  ~EyeoFilteringPrivateRemoveCustomFilterFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateRemoveCustomFilterFunction(
+      const EyeoFilteringPrivateRemoveCustomFilterFunction&) = delete;
+  EyeoFilteringPrivateRemoveCustomFilterFunction& operator=(
+      const EyeoFilteringPrivateRemoveCustomFilterFunction&) = delete;
+};
+
+class EyeoFilteringPrivateGetCustomFiltersFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("eyeoFilteringPrivate.getCustomFilters", UNKNOWN)
+  EyeoFilteringPrivateGetCustomFiltersFunction();
+
+ private:
+  ~EyeoFilteringPrivateGetCustomFiltersFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateGetCustomFiltersFunction(
+      const EyeoFilteringPrivateGetCustomFiltersFunction&) = delete;
+  EyeoFilteringPrivateGetCustomFiltersFunction& operator=(
+      const EyeoFilteringPrivateGetCustomFiltersFunction&) = delete;
+};
+
+class EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "eyeoFilteringPrivate.getSessionAllowedRequestsCount",
+      UNKNOWN)
+  EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction();
+
+ private:
+  ~EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction(
+      const EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction&) =
+      delete;
+  EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction& operator=(
+      const EyeoFilteringPrivateGetSessionAllowedRequestsCountFunction&) =
+      delete;
+};
+
+class EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction
+    : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION(
+      "eyeoFilteringPrivate.getSessionBlockedRequestsCount",
+      UNKNOWN)
+  EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction();
+
+ private:
+  ~EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction() override;
+
+  ResponseAction Run() override;
+
+  EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction(
+      const EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction&) =
+      delete;
+  EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction& operator=(
+      const EyeoFilteringPrivateGetSessionBlockedRequestsCountFunction&) =
+      delete;
+};
+
+}  // namespace api
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_API_EYEO_FILTERING_PRIVATE_EYEO_FILTERING_PRIVATE_API_H_
diff --git a/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_apitest.cc b/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_apitest.cc
new file mode 100644
--- /dev/null
+++ b/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_apitest.cc
@@ -0,0 +1,173 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+#include "chrome/browser/adblock/adblock_chrome_content_browser_client.h"
+#include "chrome/browser/extensions/extension_apitest.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/common/extensions/api/adblock_private.h"
+#include "components/adblock/content/browser/factories/subscription_service_factory.h"
+#include "components/adblock/core/common/adblock_constants.h"
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "content/public/test/browser_test.h"
+#include "extensions/common/switches.h"
+#include "testing/gmock/include/gmock/gmock.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace extensions {
+
+namespace {
+enum class Mode { Normal, Incognito };
+
+void AllowTestExtension(base::CommandLine* command_line) {
+  command_line->AppendSwitchASCII(extensions::switches::kAllowlistedExtensionID,
+                                  "hjlolhdkflcejcekagdgahplimkppjml");
+}
+
+void EnableIncognitoMode(base::CommandLine* command_line) {
+  command_line->AppendSwitch(::switches::kIncognito);
+}
+}  // namespace
+
+class EyeoFilteringPrivateApiTest : public ExtensionApiTest,
+                                    public testing::WithParamInterface<Mode> {
+ public:
+  EyeoFilteringPrivateApiTest() {}
+  ~EyeoFilteringPrivateApiTest() override = default;
+  EyeoFilteringPrivateApiTest(const EyeoFilteringPrivateApiTest&) = delete;
+  EyeoFilteringPrivateApiTest& operator=(const EyeoFilteringPrivateApiTest&) =
+      delete;
+
+  void SetUpCommandLine(base::CommandLine* command_line) override {
+    extensions::ExtensionApiTest::SetUpCommandLine(command_line);
+    AllowTestExtension(command_line);
+    if (IsIncognito()) {
+      EnableIncognitoMode(command_line);
+    }
+  }
+
+ protected:
+  void SetUpOnMainThread() override {
+    ExtensionApiTest::SetUpOnMainThread();
+
+    auto* adblock_configuration =
+        adblock::SubscriptionServiceFactory::GetForBrowserContext(
+            browser()->profile()->GetOriginalProfile())
+            ->GetFilteringConfiguration(
+                adblock::kAdblockFilteringConfigurationName);
+    if (adblock_configuration) {
+      adblock_configuration->RemoveCustomFilter(
+          adblock::kAllowlistEverythingFilter);
+    }
+
+    AdblockChromeContentBrowserClient::ForceAdblockProxyForTesting();
+  }
+
+  bool IsIncognito() { return GetParam() == Mode::Incognito; }
+
+  bool RunTest(const std::string& subtest) {
+    const std::string page_url = "main.html?subtest=" + subtest;
+    return RunExtensionTest("eyeo_filtering_private",
+                            {.extension_url = page_url.c_str()},
+                            {.allow_in_incognito = IsIncognito(),
+                             .load_as_component = !IsIncognito()});
+  }
+};
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       CreateRemoveAndGetConfigurations) {
+  EXPECT_TRUE(RunTest("createRemoveAndGetConfigurations")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       CreateRemoveAndGetConfigurationsWithPromises) {
+  EXPECT_TRUE(RunTest("createRemoveAndGetConfigurationsWithPromises"))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       EnableAndDisableConfiguration) {
+  EXPECT_TRUE(RunTest("enableAndDisableConfiguration")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       EnableAndDisableConfigurationWithPromises) {
+  EXPECT_TRUE(RunTest("enableAndDisableConfigurationWithPromises")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       AddAllowedDomainToCustomConfiguration) {
+  EXPECT_TRUE(RunTest("addAllowedDomainToCustomConfiguration")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       AddAllowedDomainToCustomConfigurationWithPromises) {
+  EXPECT_TRUE(RunTest("addAllowedDomainToCustomConfigurationWithPromises"))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       AddCustomFilterToCustomConfiguration) {
+  EXPECT_TRUE(RunTest("addCustomFilterToCustomConfiguration")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       AddCustomFilterToCustomConfigurationWithPromises) {
+  EXPECT_TRUE(RunTest("addCustomFilterToCustomConfigurationWithPromises"))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       AddFilterListInCustomConfiguration) {
+  EXPECT_TRUE(RunTest("addFilterListInCustomConfiguration")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       AddFilterListInCustomConfigurationWithPromises) {
+  EXPECT_TRUE(RunTest("addFilterListInCustomConfigurationWithPromises"))
+      << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest, MissingConfiguration) {
+  EXPECT_TRUE(RunTest("missingConfiguration")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest,
+                       MissingConfigurationWithPromises) {
+  EXPECT_TRUE(RunTest("missingConfigurationWithPromises")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest, AllowedDomainsEvent) {
+  EXPECT_TRUE(RunTest("allowedDomainsEvent")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest, EnabledStateEvent) {
+  EXPECT_TRUE(RunTest("enabledStateEvent")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest, FilterListsEvent) {
+  EXPECT_TRUE(RunTest("filterListsEvent")) << message_;
+}
+
+IN_PROC_BROWSER_TEST_P(EyeoFilteringPrivateApiTest, CustomFiltersEvent) {
+  EXPECT_TRUE(RunTest("customFiltersEvent")) << message_;
+}
+
+INSTANTIATE_TEST_SUITE_P(,
+                         EyeoFilteringPrivateApiTest,
+                         testing::Values(Mode::Normal, Mode::Incognito));
+
+}  // namespace extensions
diff --git a/chrome/browser/extensions/extension_function_registration_test.cc b/chrome/browser/extensions/extension_function_registration_test.cc
--- a/chrome/browser/extensions/extension_function_registration_test.cc
+++ b/chrome/browser/extensions/extension_function_registration_test.cc
@@ -1,6 +1,10 @@
 // Copyright 2018 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "base/containers/contains.h"
 #include "base/one_shot_event.h"
@@ -59,6 +63,12 @@ IN_PROC_BROWSER_TEST_F(ExtensionFunctionRegistrationTest,
                            base::CompareCase::SENSITIVE)) {
         continue;
       }
+      // Eyeo extension API uses UNKNOWN; it's not used in histograms.
+      if (base::StartsWith(entry.function_name_, "adblockPrivate.") ||
+          base::StartsWith(entry.function_name_, "eyeoFilteringPrivate.")) {
+        continue;
+      }
+
       // Some undocumented, unlaunched APIs may also use UNKNOWN if it's unclear
       // (or unlikely) if they will ever launch.
       if (base::Contains(kAllowedUnknownHistogramEntries,
diff --git a/chrome/common/extensions/api/_api_features.json b/chrome/common/extensions/api/_api_features.json
--- a/chrome/common/extensions/api/_api_features.json
+++ b/chrome/common/extensions/api/_api_features.json
@@ -1,6 +1,10 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
+
 
 // This features file defines extension APIs implemented under src/chrome.
 // See chrome/common/extensions/api/_features.md to understand this file, as
@@ -68,6 +72,16 @@
     "contexts": ["privileged_extension"],
     "dependencies": ["permission:experimentalAiData"]
   },
+  "adblockPrivate": [{
+    "dependencies": ["permission:adblockPrivate"],
+    "contexts": ["privileged_extension"]
+  }, {
+    "contexts": ["webui"],
+    "dependencies": [],
+    "matches": [
+      "chrome://settings/*"
+    ]
+  }],
   "app": {
     "blocklist": [
       "2FC374607C2DF285634B67C64A2E356C607091C3",  // Quickoffice
@@ -541,6 +555,14 @@
     "channel": "stable",
     "contexts": []
   },
+  "eyeoFilteringPrivate": [{
+    "dependencies": ["permission:eyeoFilteringPrivate"],
+    "contexts": ["privileged_extension"]
+  }, {
+    "contexts": ["webui"],
+    "dependencies": [],
+    "matches": ["chrome://settings/*"]
+  }],
   "fileBrowserHandler": {
     "dependencies": ["permission:fileBrowserHandler"],
     "contexts": ["privileged_extension"],
diff --git a/chrome/common/extensions/api/_permission_features.json b/chrome/common/extensions/api/_permission_features.json
--- a/chrome/common/extensions/api/_permission_features.json
+++ b/chrome/common/extensions/api/_permission_features.json
@@ -1,6 +1,10 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
+
 
 // This features file defines permissions for extension APIs implemented
 // under src/chrome.
@@ -60,6 +64,13 @@
       "5107DE9024C329EEA9C9A72D94C16723790C6422"   // Apps Developer Tool Dev.
     ]
   },
+  "adblockPrivate": {
+    "channel": "stable",
+    "extension_types": ["extension", "platform_app"],
+    "allowlist" : [
+      "664F11343A17783FC7F6DC994BBC8AAF6823739C"  // eyeo test extension
+    ]
+  },
   "autofillPrivate": {
     "channel": "trunk",
     "extension_types": ["extension", "platform_app"],
@@ -411,6 +422,13 @@
     // "desktop_android" is not supported.
     "platforms": ["chromeos", "linux", "mac", "win"]
   },
+  "eyeoFilteringPrivate": {
+    "channel": "stable",
+    "extension_types": ["extension", "platform_app"],
+    "allowlist" : [
+      "664F11343A17783FC7F6DC994BBC8AAF6823739C"  // eyeo test extension
+    ]
+  },
   "favicon": {
     "channel": "stable",
     "extension_types": ["extension"]
diff --git a/chrome/common/extensions/api/adblock_private.idl b/chrome/common/extensions/api/adblock_private.idl
new file mode 100644
--- /dev/null
+++ b/chrome/common/extensions/api/adblock_private.idl
@@ -0,0 +1,180 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+// DEPRECATED: Prefer eyeoFilteringPrivate API.
+//
+// This is a private API exposing ability to control ad-filtering settings via adblockPrivate API.
+//
+// Devs: when modifying this file, ensure you update
+// tools/typescript/definitions/adblock_private.d.ts as well.
+// See DPD-1870 for more information.
+namespace adblockPrivate {
+
+dictionary BuiltInSubscription {
+  // Subscription url
+  DOMString url;
+  // Subscription title (may be empty)
+  DOMString title;
+  // list of languages this subscription is relevant for.
+  DOMString[] languages;
+};
+
+dictionary Subscription {
+  // Subscription url
+  DOMString url;
+  // Current state of the subscription. Allowed values are:
+  // "Installed"
+  // "Preloaded"
+  // "Installing"
+  // See components/adblock/core/subscription/subscription.h for description.
+  DOMString installation_state;
+  // Subscription title (may be empty)
+  DOMString title;
+  // Subscription version (may be empty)
+  DOMString current_version;
+  // Time of last successful installation or update, in ISO 8601 format.
+  // May be passed directly to the Date constructor.
+  // Empty for subscriptions that are not installed yet.
+  DOMString last_installation_time;
+};
+
+dictionary SessionStatsEntry {
+  // Subscription url or "adblock:custom" when custom filter was matched
+  DOMString url;
+  // Subscription hits
+  long count;
+};
+
+dictionary AdInfo {
+  // URL of the ad element which has been matched.
+  DOMString url;
+  // URLs of the parent frames.
+  DOMString[] parent_frame_urls;
+  // URL of subscription having the filter which matched for the ad.
+  DOMString subscription;
+  // Configuration name containing subscription with matched filer.
+  DOMString configuration_name;
+  // A string representation of matched ad's resource type.
+  // Possible values are:
+  // - "SCRIPT"
+  // - "IMAGE"
+  // - "STYLESHEET"
+  // - "OBJECT"
+  // - "SUBDOCUMENT"
+  // - "WEBSOCKET"
+  // - "WEBRTC"
+  // - "PING"
+  // - "XMLHTTPREQUEST"
+  // - "MEDIA"
+  // - "FONT"
+  // - "OTHER" (when none of the above matches)
+  // See: components/adblock/core/common/content_type.h
+  DOMString content_type;
+  // Tab id for which the event is fired. Defaults to -1, a numerical value of
+  // api::tabs::TAB_ID_NONE which means tab id cannot be obtained.
+  long tab_id;
+  // Window id for which the event is fired. Defaults to -1 which is a value
+  // of SessionID::InvalidValue() which means window id cannot be obtained.
+  long window_id;
+};
+
+callback BuiltInSubscriptionsCallback = void(BuiltInSubscription[] result);
+callback SubscriptionsCallback = void(Subscription[] result);
+callback StateCallback = void(boolean result);
+callback CompletionCallback = void();
+callback ListCallback = void(DOMString[] result);
+callback SessionStatsCallback = void(SessionStatsEntry[] result);
+
+[deprecated="Use eyeoFilteringPrivate methods instead."]
+interface Functions {
+  // Allows to turn Adblock on or off.
+  static void setEnabled(boolean enabled);
+  // Returns whether Adblock is on.
+  static void isEnabled(StateCallback callback);
+  // Allows to turn Acceptable Ads on or off.
+  static void setAcceptableAdsEnabled(boolean enabled);
+  // Returns whether Acceptable Ads is on.
+  static void isAcceptableAdsEnabled(StateCallback callback);
+  // Allows to turn autoinstalling geolocation recommendation on or off.
+  static void setAutoInstallEnabled(boolean enabled);
+  // Returns whether autoinstalling geolocation recommendation is on.
+  static void isAutoInstallEnabled(StateCallback callback);
+  // Gets the list of built-in subscriptions.
+  static void getBuiltInSubscriptions(BuiltInSubscriptionsCallback callback);
+  // Adds a domain ads should not be blocked on.
+  static void addAllowedDomain(DOMString domain);
+  // Removes a domain ads should not be blocked on.
+  static void removeAllowedDomain(DOMString domain);
+  // Returns a list of domains ads are not blocked on.
+  static void getAllowedDomains(ListCallback callback);
+  // Adds a custom filter.
+  static void addCustomFilter(DOMString filter);
+  // Removes a custom filter.
+  static void removeCustomFilter(DOMString filter);
+  // Returns a list of custom filters a user set.
+  static void getCustomFilters(ListCallback callback);
+  // Returns number of allowlisted requests in a current session (runtime).
+  static void getSessionAllowedAdsCount(SessionStatsCallback callback);
+  // Returns number of blocked requests in a current session (runtime).
+  static void getSessionBlockedAdsCount(SessionStatsCallback callback);
+  // Compiles a list of currently installed subscriptions. Filter lists that are
+  // still being installed and don't yet participate in ad filtering also appear
+  // on this list and can be discerned by their installation_state.
+  static void getInstalledSubscriptions(SubscriptionsCallback callback);
+  // Subscribes to a filter list. If subscription was already done and not
+  // removed later by "uninstallSubscription()" call then this is a no-op call,
+  // otherwise it initiates a download. |url| must point to a https URL.
+  static void installSubscription(DOMString url,
+                                  optional CompletionCallback feedback);
+  // Removes a subscription to a filter list downloaded from |url| and deletes
+  // corresponding files from disk. Does nothing if the filter list was never
+  // subscribed to.
+  static void uninstallSubscription(DOMString url,
+                                    optional CompletionCallback feedback);
+};
+
+interface Events {
+  // Fired when an ad is explicitly allowed by an exception rule.
+  static void onAdAllowed(AdInfo info);
+
+  // Fired when an ad is blocked.
+  static void onAdBlocked(AdInfo info);
+
+  // Fired when a whole page is allowlisted.
+  static void onPageAllowed(AdInfo info);
+
+  // Fired when a popup is blocked.
+  static void onPopupBlocked(AdInfo info);
+
+  // Fired when a popup is allowlisted.
+  static void onPopupAllowed(AdInfo info);
+
+  // Fired when a subscription has been updated.
+  static void onSubscriptionUpdated(DOMString subscription_url);
+
+  // Fired when ad-filtering enable state changed
+  static void onEnabledStateChanged();
+
+  // Fired when subscription added or removed.
+  static void onFilterListsChanged();
+
+  // Fired when allowed domain list has been updated.
+  static void onAllowedDomainsChanged();
+
+  // Fired when custom filter added or removed.
+  static void onCustomFiltersChanged();
+};
+
+};
diff --git a/chrome/common/extensions/api/api_sources.gni b/chrome/common/extensions/api/api_sources.gni
--- a/chrome/common/extensions/api/api_sources.gni
+++ b/chrome/common/extensions/api/api_sources.gni
@@ -1,6 +1,9 @@
 # Copyright 2018 The Chromium Authors
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
+#
+# This source code is a part of eyeo Chromium SDK.
+# Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 
 import("//chrome/common/features.gni")
 import("//pdf/features.gni")
@@ -40,6 +43,8 @@ schema_sources_ = [
   "tabs.json",
   "web_authentication_proxy.webidl",
   "web_navigation.json",
+  "adblock_private.idl",
+  "eyeo_filtering_private.idl",
 
   # Despite the name, these APIs do not rely on any WebRTC-specific bits and
   # as such do not belong in a conditional.
diff --git a/chrome/common/extensions/api/eyeo_filtering_private.idl b/chrome/common/extensions/api/eyeo_filtering_private.idl
new file mode 100644
--- /dev/null
+++ b/chrome/common/extensions/api/eyeo_filtering_private.idl
@@ -0,0 +1,207 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+// This is a private API exposing control over resource filtering via eyeoFilteringPrivate API.
+//
+// Devs: when modifying this file, ensure you update
+// tools/typescript/definitions/eyeo_filtering_private.d.ts as well.
+// See DPD-1870 for more information.
+namespace eyeoFilteringPrivate {
+
+  dictionary Subscription {
+    // Subscription url
+    DOMString url;
+    // Current state of the subscription. Allowed values are:
+    // "Installed"
+    // "Preloaded"
+    // "Installing"
+    // See components/adblock/core/subscription/subscription.h for description.
+    DOMString installation_state;
+    // Subscription title (may be empty)
+    DOMString title;
+    // Subscription version (may be empty)
+    DOMString current_version;
+    // Time of last successful installation or update, in ISO 8601 format.
+    // May be passed directly to the Date constructor.
+    DOMString last_installation_time;
+  };
+
+  dictionary SessionStatsEntry {
+    // Subscription url or "adblock:custom" when custom filter was matched
+    DOMString url;
+    // Subscription hits
+    long count;
+  };
+
+  dictionary RequestInfo {
+    // URL of the request element which has been matched.
+    DOMString url;
+    // URLs of the parent frames.
+    DOMString[] parent_frame_urls;
+    // URL of subscription having the filter which matched for the request.
+    DOMString subscription;
+    // Configuration name containing subscription with matched filer.
+    DOMString configuration_name;
+    // A string representation of matched request's resource type.
+    // Possible values are:
+    // - "SCRIPT"
+    // - "IMAGE"
+    // - "STYLESHEET"
+    // - "OBJECT"
+    // - "SUBDOCUMENT"
+    // - "WEBSOCKET"
+    // - "WEBRTC"
+    // - "PING"
+    // - "XMLHTTPREQUEST"
+    // - "MEDIA"
+    // - "FONT"
+    // - "OTHER" (when none of the above matches)
+    // See: components/adblock/core/common/content_type.h
+    DOMString content_type;
+    // Tab id for which the event is fired. Defaults to -1, a numerical value of
+    // api::tabs::TAB_ID_NONE which means tab id cannot be obtained.
+    long tab_id;
+    // Window id for which the event is fired. Defaults to -1 which is a value
+    // of SessionID::InvalidValue() which means window id cannot be obtained.
+    long window_id;
+  };
+
+  callback CompletionCallback = void();
+  callback ListCallback = void(DOMString[] result);
+  callback SessionStatsCallback = void(SessionStatsEntry[] result);
+  callback StateCallback = void(boolean result);
+  callback SubscriptionsCallback = void(Subscription[] result);
+  callback UrlCallback = void(DOMString result);
+
+  // In order to use any configuration it needs to be created first
+  // in the backend, for example by using $(ref:createConfiguration) call.
+  // Names of all existing configurations can be fetched via
+  // (ref:getConfigurations) call.
+  interface Functions {
+    // Creates new filtering configuration. It is a no-op call if configuration
+    // already exists.
+    static void createConfiguration(DOMString config_name);
+    // Removes existing configuration, no-op when configuration does not exist.
+    // Use it only when |configuration| is no longer needed, otherwise prefer
+    // to disable |configuration| using (ref:setEnabled).
+    static void removeConfiguration(DOMString config_name);
+    // Returns a list of existing configurations.
+    [supportsPromises] static void getConfigurations(ListCallback callback);
+    // Returns whether autoinstalling geolocation recommendation is on.
+    [supportsPromises] static void isAutoInstallEnabled(
+        StateCallback callback);
+    // Allows to turn autoinstalling geolocation recommendation on or off.
+    [supportsPromises] static void setAutoInstallEnabled(
+        boolean enabled,
+        optional CompletionCallback status);
+    // Allows to turn filtering configuration on or off.
+    [supportsPromises] static void setEnabled(
+        DOMString configuration,
+        boolean enabled,
+        optional CompletionCallback status);
+    // Returns whether filtering configuration is on.
+    [supportsPromises] static void isEnabled(
+        DOMString configuration,
+        StateCallback callback);
+    // Adds a domain requests should not be blocked on.
+    [supportsPromises] static void addAllowedDomain(
+        DOMString configuration,
+        DOMString domain,
+        optional CompletionCallback status);
+    // Removes a domain requests should not be blocked on.
+    [supportsPromises] static void removeAllowedDomain(
+        DOMString configuration,
+        DOMString domain,
+        optional CompletionCallback status);
+    // Returns a list of domains requests are not blocked on.
+    [supportsPromises] static void getAllowedDomains(
+        DOMString configuration,
+        ListCallback callback);
+    // Adds a custom filter.
+    [supportsPromises] static void addCustomFilter(
+        DOMString configuration,
+        DOMString filter,
+        optional CompletionCallback status);
+    // Removes a custom filter.
+    [supportsPromises] static void removeCustomFilter(
+        DOMString configuration,
+        DOMString filter,
+        optional CompletionCallback status);
+    // Returns a list of custom filters a user set.
+    [supportsPromises] static void getCustomFilters(
+        DOMString configuration,
+        ListCallback callback);
+    // Subscribes to a filter list. If subscription was already done and not
+    // removed later by "removeFilterList()" call then this is a no-op
+    // call, otherwise it initiates a download. |url| must point to a https URL.
+    [supportsPromises] static void addFilterList(
+        DOMString configuration,
+        DOMString url,
+        optional CompletionCallback status);
+    // Removes a subscription to a filter list downloaded from |url| and deletes
+    // corresponding files from disk. Does nothing if the filter list was never
+    // subscribed to.
+    [supportsPromises] static void removeFilterList(
+        DOMString configuration,
+        DOMString url,
+        optional CompletionCallback status);
+    // Compiles a list of currently installed subscriptions. Filter lists that
+    // are still being installed and don't yet participate in filtering also
+    // appear on this list and can be discerned by their installation_state.
+    [supportsPromises] static void getFilterLists(
+        DOMString configuration,
+        SubscriptionsCallback callback);
+    [supportsPromises] static void getSessionAllowedRequestsCount(
+        SessionStatsCallback callback);
+    // Returns number of blocked requests in a current session (runtime).
+    [supportsPromises] static void getSessionBlockedRequestsCount(
+        SessionStatsCallback callback);
+    // Returns Acceptable Ads url which can be passed to
+    // (ref:addFilterList) or (ref:removeFilterList).
+    [supportsPromises] static void getAcceptableAdsUrl(UrlCallback callback);
+  };
+
+  interface Events {
+    // Fired when an request is explicitly allowed by an exception rule.
+    static void onRequestAllowed(RequestInfo info);
+
+    // Fired when an request is blocked.
+    static void onRequestBlocked(RequestInfo info);
+
+    // Fired when a whole page is allowlisted in every filtering configuration.
+    static void onPageAllowed(RequestInfo info);
+
+    // Fired when a popup is blocked.
+    static void onPopupBlocked(RequestInfo info);
+
+    // Fired when a popup is allowlisted.
+    static void onPopupAllowed(RequestInfo info);
+
+    // Fired when a subscription has been updated.
+    static void onSubscriptionUpdated(DOMString subscription_url);
+
+    // Fired when configuration enable state changed
+    static void onEnabledStateChanged(DOMString config_name);
+
+    // Fired when subscription added or removed.
+    static void onFilterListsChanged(DOMString config_name);
+
+    // Fired when allowed domain list has been updated.
+    static void onAllowedDomainsChanged(DOMString config_name);
+
+    // Fired when custom filter added or removed.
+    static void onCustomFiltersChanged(DOMString config_name);
+  };
+};
diff --git a/chrome/common/extensions/permissions/chrome_api_permissions.cc b/chrome/common/extensions/permissions/chrome_api_permissions.cc
--- a/chrome/common/extensions/permissions/chrome_api_permissions.cc
+++ b/chrome/common/extensions/permissions/chrome_api_permissions.cc
@@ -1,6 +1,10 @@
 // Copyright 2013 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "chrome/common/extensions/permissions/chrome_api_permissions.h"
 
@@ -32,6 +36,8 @@ std::unique_ptr<APIPermission> CreateAPIPermission(
 // ChromePermissionMessageProvider::GetPermissionMessages as well.
 constexpr APIPermissionInfo::InitInfo permissions_to_register[] = {
     // Register permissions for all extension types.
+    {APIPermissionID::kAdblockPrivate, "adblockPrivate",
+     APIPermissionInfo::kFlagCannotBeOptional},
     {APIPermissionID::kBackground, "background",
      APIPermissionInfo::kFlagDoesNotRequireManagedSessionFullLoginWarning},
     {APIPermissionID::kDeclarativeContent, "declarativeContent"},
@@ -87,6 +93,8 @@ constexpr APIPermissionInfo::InitInfo permissions_to_register[] = {
     {APIPermissionID::kEnterpriseNetworkingAttributes,
      "enterprise.networkingAttributes",
      APIPermissionInfo::kFlagDoesNotRequireManagedSessionFullLoginWarning},
+    {APIPermissionID::kEyeoFilteringPrivate, "eyeoFilteringPrivate",
+     APIPermissionInfo::kFlagCannotBeOptional},
     {APIPermissionID::kEnterprisePlatformKeys, "enterprise.platformKeys",
      APIPermissionInfo::kFlagDoesNotRequireManagedSessionFullLoginWarning},
     {APIPermissionID::kFavicon, "favicon"},
diff --git a/chrome/common/extensions/permissions/permission_set_unittest.cc b/chrome/common/extensions/permissions/permission_set_unittest.cc
--- a/chrome/common/extensions/permissions/permission_set_unittest.cc
+++ b/chrome/common/extensions/permissions/permission_set_unittest.cc
@@ -1,6 +1,10 @@
 // Copyright 2012 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #include "extensions/common/permissions/permission_set.h"
 
@@ -896,6 +900,10 @@ TEST(PermissionsTest, PermissionMessages) {
   skip.insert(APIPermissionID::kSystemLog);
   skip.insert(APIPermissionID::kOdfsConfigPrivate);
 
+  // Adblock API is also private (in separate block to minimize conflicts).
+  skip.insert(APIPermissionID::kAdblockPrivate);
+  skip.insert(APIPermissionID::kEyeoFilteringPrivate);
+
   // Warned as part of host permissions.
   skip.insert(APIPermissionID::kDevtools);
 
diff --git a/chrome/test/BUILD.gn b/chrome/test/BUILD.gn
--- a/chrome/test/BUILD.gn
+++ b/chrome/test/BUILD.gn
@@ -4335,6 +4335,20 @@ if (!is_android) {
       ]
     }
 
+    ### Extensions API module start
+    sources += [
+      "../browser/extensions/api/adblock_private/adblock_private_apitest.cc",
+      "../browser/extensions/api/adblock_private/adblock_private_apitest_backgroundpage.cc",
+      "../browser/extensions/api/adblock_private/adblock_private_apitest_base.cc",
+      "../browser/extensions/api/adblock_private/adblock_private_apitest_base.h",
+      "../browser/extensions/api/adblock_private/adblock_private_filter_lists_with_http_server_apitest.cc",
+      "../browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_apitest.cc",
+    ]
+
+    deps += [ "//components/adblock/content/browser:browser_tests_support" ]
+
+    ### Extensions API module end
+
     if (is_chromeos) {
       deps += [
         "//chrome/browser/chromeos/cros_apps:all_browser_tests",
diff --git a/chrome/test/data/extensions/api_test/adblock_private/empty.js b/chrome/test/data/extensions/api_test/adblock_private/empty.js
new file mode 100644
--- /dev/null
+++ b/chrome/test/data/extensions/api_test/adblock_private/empty.js
@@ -0,0 +1,14 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
diff --git a/chrome/test/data/extensions/api_test/adblock_private/main.html b/chrome/test/data/extensions/api_test/adblock_private/main.html
new file mode 100644
--- /dev/null
+++ b/chrome/test/data/extensions/api_test/adblock_private/main.html
@@ -0,0 +1,29 @@
+<!--
+* This file is part of eyeo Chromium SDK,
+* Copyright (C) 2006-present eyeo GmbH
+*
+* eyeo Chromium SDK is free software: you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 3 as
+* published by the Free Software Foundation.
+*
+* eyeo Chromium SDK is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+-->
+<script src="test.js"></script>
+
+<html>
+
+<head>
+  <title>Adblock private API test</title>
+</head>
+
+<body>
+  <h2>chrome.adblockPrivate.* tests</h2>
+</body>
+
+</html>
diff --git a/chrome/test/data/extensions/api_test/adblock_private/manifest.json b/chrome/test/data/extensions/api_test/adblock_private/manifest.json
new file mode 100644
--- /dev/null
+++ b/chrome/test/data/extensions/api_test/adblock_private/manifest.json
@@ -0,0 +1,32 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+{
+  "name": "adblockPrivate API test",
+  "key": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyURY+BO7WO3B/dixoRSitosEKb1OOCsS1EF8dRoywUP+iQlHDJw2JL2A7d/E6JpoBQ/CUxX8lcHcsAs7zC31zb2iosBbfd5mCDd24bjLaIF/WNBRno6QYwbM/J7gCxn/aGFvAXdLnPhs2XFiP7iSQEY67NtTlah9EFGalB45UFUssrxFOXTFWT/gJmRIHqfCSUzHdPmFRJ1Sk6UpyZBPxp2MJAISbfTUhWIXa7WG+JxW95OEtNggfhYzX9wbCVSEU18RiMiMLdqNwHf7hYI30KiwrQhWcaB5kCnvJYEa43JggcE9xAaHV+1t2hSMyo5Xbz2YslI5UfDe8112hGVIUQIDAQAB",
+  "version": "0.1",
+  "incognito": "split",
+  "manifest_version": 2,
+  "background": {
+    "scripts": [
+      "empty.js"
+    ]
+  },
+  "description": "Test of chrome.adblockPrivate interface",
+  "permissions": [
+    "adblockPrivate",
+    "eyeoFilteringPrivate",
+    "<all_urls>"
+  ]
+}
diff --git a/chrome/test/data/extensions/api_test/adblock_private/some-popup.html b/chrome/test/data/extensions/api_test/adblock_private/some-popup.html
new file mode 100644
--- /dev/null
+++ b/chrome/test/data/extensions/api_test/adblock_private/some-popup.html
@@ -0,0 +1,24 @@
+<!--
+* This file is part of eyeo Chromium SDK,
+* Copyright (C) 2006-present eyeo GmbH
+*
+* eyeo Chromium SDK is free software: you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 3 as
+* published by the Free Software Foundation.
+*
+* eyeo Chromium SDK is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+-->
+<html>
+<head>
+  <title>Popup content</title>
+</head>
+<body>
+  <p>I am a popup</p>
+</body>
+</html>
diff --git a/chrome/test/data/extensions/api_test/adblock_private/test.html b/chrome/test/data/extensions/api_test/adblock_private/test.html
new file mode 100644
--- /dev/null
+++ b/chrome/test/data/extensions/api_test/adblock_private/test.html
@@ -0,0 +1,25 @@
+<!--
+* This file is part of eyeo Chromium SDK,
+* Copyright (C) 2006-present eyeo GmbH
+*
+* eyeo Chromium SDK is free software: you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 3 as
+* published by the Free Software Foundation.
+*
+* eyeo Chromium SDK is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+-->
+<html>
+<head>
+  <title>Test file</title>
+</head>
+<body>
+  <img src="some_ad.png">
+  <a href="some-popup.html" id="popup_id" target="_blank">popup link</a>
+</body>
+</html>
diff --git a/chrome/test/data/extensions/api_test/adblock_private/test.js b/chrome/test/data/extensions/api_test/adblock_private/test.js
new file mode 100644
--- /dev/null
+++ b/chrome/test/data/extensions/api_test/adblock_private/test.js
@@ -0,0 +1,609 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+'use strict';
+
+const urlParams = new URLSearchParams(window.location.search);
+
+// This class binds 1st argument for chrome.eyeoFilteringPrivate to 'adblock'
+// configuration and redirects methods renamed in chrome.eyeoFilteringPrivate
+// (eg. `onAdAllowed` => `onRequestAllowed`) which allows test code to
+// seamlessly call the same methods on chrome.adblockPrivate and on
+// chrome.eyeoFilteringPrivate.
+class FilteringPrivateBoundWithAdblock {
+  constructor() {
+    this.delegate = chrome.eyeoFilteringPrivate;
+    this.configuration = 'adblock';
+    this.getSessionAllowedAdsCount =
+        this.delegate.getSessionAllowedRequestsCount;
+    this.getSessionBlockedAdsCount =
+        this.delegate.getSessionBlockedRequestsCount;
+    this.onAdAllowed = this.delegate.onRequestAllowed;
+    this.onAdBlocked = this.delegate.onRequestBlocked;
+    this.onAllowedDomainsChanged = this.delegate.onAllowedDomainsChanged;
+    this.onCustomFiltersChanged = this.delegate.onCustomFiltersChanged;
+    this.onEnabledStateChanged = this.delegate.onEnabledStateChanged;
+    this.onFilterListsChanged = this.delegate.onFilterListsChanged;
+    this.onSubscriptionUpdated = this.delegate.onSubscriptionUpdated;
+    const methodsToBind = [
+      'isEnabled', 'setEnabled', 'getAllowedDomains', 'addAllowedDomain',
+      'removeAllowedDomain', 'getCustomFilters', 'addCustomFilter',
+      'removeCustomFilter'
+    ];
+    for (const method of methodsToBind) {
+      this[method] = function() {
+        const args = Array.from(arguments);
+        args.unshift(this.configuration);
+        this.delegate[method].apply(this.delegate, args);
+      }
+    }
+    const methodsToBindWithoutConfigurationParam = [
+      'isAutoInstallEnabled', 'setAutoInstallEnabled'
+    ];
+    for (const method of methodsToBindWithoutConfigurationParam) {
+      this[method] = function() {
+        const args = Array.from(arguments);
+        this.delegate[method].apply(this.delegate, args);
+      }
+    }
+    const methodsToBindRenamed = new Map([
+      ['installSubscription', 'addFilterList'],
+      ['uninstallSubscription', 'removeFilterList'],
+      ['getInstalledSubscriptions', 'getFilterLists'],
+    ]);
+    methodsToBindRenamed.forEach((value, key) => {
+      this[key] =
+          function() {
+            const args = Array.from(arguments);
+            args.unshift(this.configuration);
+            this.delegate[value].apply(this.delegate, args);
+          }
+    });
+  }
+};
+
+// Set API object for tests, defaults to chrome.adblockPrivate
+let apiObject = chrome.adblockPrivate;
+if (urlParams.get('api') === 'eyeoFilteringPrivate') {
+  apiObject = new FilteringPrivateBoundWithAdblock;
+}
+
+function findEnglishEasyList(item) {
+  console.log(item.title + ' ' + item.url + ' ' + item.languages);
+  return item.title.toLowerCase().includes('easylist') &&
+      item.url.toLowerCase().includes('easylist') &&
+      item.languages.includes('en');
+}
+
+function containsSubscription(subscriptions, url) {
+  for (const subscription of subscriptions) {
+    if (subscription.url === url) {
+      return true;
+    }
+  }
+  return false;
+}
+
+// Checks that session stats data contains expected filter list url entry with a
+// single hit
+function verifySessionStats(sessionStats) {
+  let index = -1;
+  for (let i = 0; i < sessionStats.length; i++) {
+    if (sessionStats[i].url === 'adblock:custom') {
+      index = i;
+      break;
+    }
+  }
+  if (index == -1) {
+    chrome.test.fail('Failed: Missing entry in sessionStats');
+    return;
+  }
+  if (sessionStats[index].count != 1) {
+    chrome.test.fail(
+        'Failed: Expected a single subscription hit number, got: ' +
+        sessionStats[index].count);
+  }
+}
+
+// Checks that even contains no error and expected filter list url
+function verifyEventData(event) {
+  if (event.tab_id < 1) {
+    chrome.test.fail('Failed: Wrong tab_id value');
+  }
+  if (event.window_id < 1) {
+    chrome.test.fail('Failed: Wrong window_id value');
+  }
+  if (event.content_type !== 'XMLHTTPREQUEST') {
+    chrome.test.fail('Failed: Wrong content_type value: ' + event.content_type);
+  }
+  if (event.subscription !== 'adblock:custom') {
+    chrome.test.fail('Failed: Wrong subscription value: ' + event.subscription);
+  }
+}
+
+function arrayEquals(a, b) {
+  if (a === b)
+    return true;
+  if (a === null || b === null)
+    return false;
+  if (a.length !== b.length)
+    return false;
+  for (var i = 0; i < a.length; i++) {
+    if (a[i] !== b[i])
+      return false;
+  }
+  return true;
+};
+
+const availableTests = [
+  function setEnabled_isEnabled() {
+    apiObject.setEnabled(false);
+    apiObject.isEnabled(function(enabled) {
+      if (enabled)
+        chrome.test.fail('Failed: ad blocking should NOT be enabled');
+    });
+    apiObject.setEnabled(true);
+    apiObject.isEnabled(function(enabled) {
+      if (enabled)
+        chrome.test.succeed();
+      else
+        chrome.test.fail('Failed: ad blocking should be enabled');
+    });
+  },
+  function setAAEnabled_isAAEnabled() {
+    chrome.adblockPrivate.setAcceptableAdsEnabled(false);
+    chrome.adblockPrivate.isAcceptableAdsEnabled(function(enabled) {
+      if (enabled)
+        chrome.test.fail('Failed: AA should NOT be enabled');
+    });
+    chrome.adblockPrivate.setAcceptableAdsEnabled(true);
+    chrome.adblockPrivate.getInstalledSubscriptions(function(selected) {
+      if (!containsSubscription(
+              selected,
+              'https://easylist-downloads.adblockplus.org/exceptionrules.txt')) {
+        chrome.test.fail('Failed: AA subscription should be on the list');
+      }
+    });
+    chrome.adblockPrivate.isAcceptableAdsEnabled(function(enabled) {
+      if (enabled)
+        chrome.test.succeed();
+      else
+        chrome.test.fail('Failed: AA should be enabled');
+    });
+  },
+  function setAAEnabled_isAAEnabled_newAPI() {
+    const default_config = 'adblock';
+    chrome.eyeoFilteringPrivate.getAcceptableAdsUrl(function(aa_url) {
+      chrome.eyeoFilteringPrivate.removeFilterList(
+          default_config, aa_url);
+      chrome.adblockPrivate.isAcceptableAdsEnabled(function(enabled) {
+        if (enabled)
+          chrome.test.fail('Failed: AA should NOT be enabled');
+      });
+      chrome.eyeoFilteringPrivate.getAcceptableAdsUrl(function(aa_url) {
+        chrome.eyeoFilteringPrivate.addFilterList(
+            default_config, aa_url);
+        chrome.adblockPrivate.isAcceptableAdsEnabled(function(enabled) {
+          if (enabled)
+            chrome.test.succeed();
+          else
+            chrome.test.fail('Failed: AA should be enabled');
+        });
+      });
+    });
+  },
+  function getBuiltInSubscriptions() {
+    chrome.adblockPrivate.getBuiltInSubscriptions(function(recommended) {
+      const found = recommended.find(findEnglishEasyList);
+      if (found) {
+        chrome.test.succeed();
+      } else {
+        chrome.test.fail('Failed: invalid built-in subscriptions');
+      }
+    });
+  },
+  // This test works because at the beginning getInstalledSubscriptions returns
+  // just default entries from recommended subscriptions.
+  function installedSubscriptionsDataSchema() {
+    const disabled = !!urlParams.get('disabled');
+    if (disabled) {
+      apiObject.setEnabled(false);
+    }
+    apiObject.getInstalledSubscriptions(function(installed) {
+      for (const subscription of installed) {
+        if (!subscription.url)
+          chrome.test.fail('Failed: Must contain "url" property');
+        if (!(subscription.installation_state == 'Unknown' && disabled ||
+              subscription.installation_state != 'Unknown' && !disabled))
+          chrome.test.fail(
+              'Failed: Must contain valid "installation_state" property');
+        if (disabled)
+          continue;
+        const pathname = new URL(subscription.url).pathname;
+        if (subscription.title != pathname)
+          chrome.test.fail('Failed: Must contain expected "title" property');
+        if (subscription.current_version != pathname.length)
+          chrome.test.fail('Failed: Must contain expected "current_version" property');
+        if (!subscription.last_installation_time)
+          chrome.test.fail(
+              'Failed: Installed subscription must contain "last_installation_time" property');
+      }
+      chrome.test.succeed();
+    });
+  },
+  function installSubscriptionInvalidURL() {
+    apiObject.installSubscription('http://', function() {
+      if (!chrome.runtime.lastError)
+        chrome.test.fail('Failed: invalid input accepted');
+      else
+        chrome.test.succeed();
+    });
+  },
+  function uninstallSubscriptionInvalidURL() {
+    apiObject.uninstallSubscription('http://', function() {
+      if (!chrome.runtime.lastError)
+        chrome.test.fail('Failed: invalid input accepted');
+      else
+        chrome.test.succeed();
+    });
+  },
+  function subscriptionsManagement() {
+    const kEasylist = urlParams.get('easylist');
+    const kExceptionrules = urlParams.get('exceptions');
+    const kABPFilters = urlParams.get('snippets');
+    const kCustom = 'https://example.com/subscription.txt';
+
+    function containsDefaultSubscriptions(subscriptions) {
+      return containsSubscription(subscriptions, kEasylist) &&
+          containsSubscription(subscriptions, kExceptionrules) &&
+          containsSubscription(subscriptions, kABPFilters);
+    }
+
+    if (urlParams.get('disabled')) {
+      apiObject.setEnabled(false);
+    }
+
+    apiObject.getInstalledSubscriptions(function(installed) {
+      if (installed.length) {
+        if (!containsDefaultSubscriptions(installed)) {
+          chrome.test.fail('Failed: Should contain all default subscriptions');
+        }
+        for (const subscription of installed) {
+          apiObject.uninstallSubscription(subscription.url);
+        }
+      } else {
+        chrome.test.fail('Failed: Should contain default subscriptions');
+      }
+      apiObject.getInstalledSubscriptions(function(installed) {
+        if (installed.length) {
+          chrome.test.fail(
+              'Failed: There shouldn\'t be any installed subscriptions');
+        }
+        apiObject.installSubscription(kEasylist);
+        apiObject.installSubscription(kExceptionrules);
+        apiObject.installSubscription(kABPFilters);
+        apiObject.getInstalledSubscriptions(function(installed) {
+          if (installed.length) {
+            if (!containsDefaultSubscriptions(installed)) {
+              chrome.test.fail(
+                  'Failed: Should contain all default subscriptions');
+            }
+          } else {
+            chrome.test.fail('Failed: Should contain default subscriptions');
+          }
+          apiObject.installSubscription(kCustom);
+          apiObject.getInstalledSubscriptions(function(installed) {
+            if (!containsSubscription(installed, kCustom)) {
+              chrome.test.fail('Failed: Should contain custom subscription');
+            }
+            apiObject.uninstallSubscription(kCustom);
+            apiObject.getInstalledSubscriptions(function(installed) {
+              if (containsSubscription(installed, kCustom)) {
+                chrome.test.fail(
+                    'Failed: Should not contain custom subscription');
+              } else {
+                chrome.test.succeed();
+              }
+            });
+          });
+        });
+      });
+    });
+  },
+  function allowedDomainsManagement() {
+    apiObject.getAllowedDomains(function(domains) {
+      if (domains.length) {
+        for (const domain of domains)
+          apiObject.removeAllowedDomain(domain);
+      }
+
+      apiObject.getAllowedDomains(function(domains) {
+        if (domains.length) {
+          chrome.test.fail('Failed: There shouldn\'t be any allowed domains');
+          return;
+        }
+
+        apiObject.addAllowedDomain('foo.bar');
+        apiObject.addAllowedDomain('bar.baz');
+        apiObject.getAllowedDomains(function(domains) {
+          if (domains.length != 2) {
+            chrome.test.fail('Failed: There should be 2 allowed domains');
+            return;
+          }
+
+          if (domains.indexOf('foo.bar') == -1 ||
+              domains.indexOf('bar.baz') == -1) {
+            chrome.test.fail('Failed: Didn\'t find expected allowed domains');
+            return;
+          }
+
+          apiObject.removeAllowedDomain('foo.bar');
+          apiObject.removeAllowedDomain('bar.baz');
+
+          apiObject.getAllowedDomains(function(domains) {
+            if (domains.length)
+              chrome.test.fail('Failed: Still have allowed domains');
+            else
+              chrome.test.succeed();
+          });
+        });
+      });
+    });
+  },
+  function customFiltersManagement() {
+    apiObject.getCustomFilters(function(filters) {
+      if (filters.length) {
+        for (const filter of filters)
+          apiObject.removeCustomFilter(filter);
+      }
+
+      apiObject.getCustomFilters(function(filters) {
+        if (filters.length) {
+          chrome.test.fail('Failed: There shouldn\'t be any custom filters');
+          return;
+        }
+
+        apiObject.addCustomFilter('foo.bar');
+        apiObject.addCustomFilter('bar.baz');
+        apiObject.getCustomFilters(function(filters) {
+          if (filters.length != 2) {
+            chrome.test.fail('Failed: There should be 2 custom filters');
+            return;
+          }
+
+          if (filters.indexOf('foo.bar') == -1 ||
+              filters.indexOf('bar.baz') == -1) {
+            chrome.test.fail('Failed: Didn\'t find expected custom filters');
+            return;
+          }
+
+          apiObject.removeCustomFilter('foo.bar');
+          apiObject.removeCustomFilter('bar.baz');
+
+          apiObject.getCustomFilters(function(filters) {
+            if (filters.length)
+              chrome.test.fail('Failed: Still have custom filters');
+            else
+              chrome.test.succeed();
+          });
+        });
+      });
+    });
+  },
+  function adBlockedEvents() {
+    let expected_filters_count = 1;
+    apiObject.onCustomFiltersChanged.addListener(function(filter) {
+      if (--expected_filters_count)
+        return;
+
+      apiObject.onAdBlocked.addListener(function(e) {
+        verifyEventData(e);
+        if (e.url.includes('test1.png')) {
+          chrome.test.succeed();
+        }
+      });
+      // External request to delay triggering test request
+      const delaying_wrapper_request = new XMLHttpRequest();
+      const delaying_wrapper_request_handler = function() {
+        // Internal request expected by test logic
+        const blocked_url_request = new XMLHttpRequest();
+        const blocked_url_request_handler = function() {};
+        blocked_url_request.onload = blocked_url_request_handler;
+        blocked_url_request.onerror = blocked_url_request_handler;
+        blocked_url_request.open('GET', 'https://example.com/test1.png', true);
+        blocked_url_request.send();
+      };
+      delaying_wrapper_request.onload = delaying_wrapper_request_handler;
+      delaying_wrapper_request.onerror = delaying_wrapper_request_handler;
+      delaying_wrapper_request.open('GET', 'https://example.com/', true);
+      delaying_wrapper_request.send();
+    });
+    apiObject.addCustomFilter('test1.png');
+  },
+  function adAllowedEvents() {
+    let expected_filters_count = 2;
+    apiObject.onCustomFiltersChanged.addListener(function(filter) {
+      if (--expected_filters_count)
+        return;
+
+      apiObject.onAdAllowed.addListener(function(e) {
+        verifyEventData(e);
+        if (e.url.includes('test2.png')) {
+          chrome.test.succeed();
+        }
+      });
+      // External request to delay triggering test request
+      const delaying_wrapper_request = new XMLHttpRequest();
+      const delaying_wrapper_request_handler = function() {
+        // Internal request expected by test logic
+        const allowed_url_request = new XMLHttpRequest();
+        const allowed_url_request_handler = function() {};
+        allowed_url_request.onload = allowed_url_request_handler;
+        allowed_url_request.onerror = allowed_url_request_handler;
+        allowed_url_request.open('GET', 'https://example.com/test2.png', true);
+        allowed_url_request.send();
+      };
+      delaying_wrapper_request.onload = delaying_wrapper_request_handler;
+      delaying_wrapper_request.onerror = delaying_wrapper_request_handler;
+      delaying_wrapper_request.open('GET', 'https://example.com/', true);
+      delaying_wrapper_request.send();
+    });
+    apiObject.addCustomFilter('test2.png');
+    apiObject.addCustomFilter('@@test2.png');
+  },
+  function sessionStats() {
+    let expected_filters_count = 3;
+    apiObject.onCustomFiltersChanged.addListener(function(filter) {
+      if (--expected_filters_count)
+        return;
+
+      const blocked_request_handler = function() {
+        apiObject.getSessionBlockedAdsCount(function(sessionStats) {
+          verifySessionStats(sessionStats);
+          const allowed_request_handler = function() {
+            apiObject.getSessionAllowedAdsCount(function(sessionStats) {
+              verifySessionStats(sessionStats);
+              chrome.test.succeed();
+            });
+          };
+          const request = new XMLHttpRequest();
+          request.onload = allowed_request_handler;
+          request.onerror = allowed_request_handler;
+          request.open('GET', 'https://example.com/test4.png', true);
+          request.send();
+        });
+      };
+      const request = new XMLHttpRequest();
+      request.onload = blocked_request_handler;
+      request.onerror = blocked_request_handler;
+      request.open('GET', 'https://example.com/test3.png', true);
+      request.send();
+    });
+    apiObject.addCustomFilter('test3.png');
+    apiObject.addCustomFilter('test4.png');
+    apiObject.addCustomFilter('@@test4.png');
+  },
+  function allowedDomainsEvent() {
+    const domain = 'domain.com';
+    let data = [domain];
+    let attempts = 2;
+    apiObject.onAllowedDomainsChanged.addListener(function() {
+      apiObject.getAllowedDomains(function(domains) {
+        if (!arrayEquals(data, domains)) {
+          chrome.test.fail('Unexpected domain list');
+        }
+        if (--attempts == 0) {
+          chrome.test.succeed();
+        }
+      });
+    });
+    apiObject.addAllowedDomain(domain);
+    data = [];
+    apiObject.removeAllowedDomain(domain);
+  },
+  function enabledStateEvent() {
+    let state = false;
+    let attempts = 2;
+    apiObject.onEnabledStateChanged.addListener(function() {
+      apiObject.isEnabled(function(enabled) {
+        if (enabled !== state) {
+          chrome.test.fail('Unexpected enabled state');
+        }
+        if (--attempts == 0) {
+          chrome.test.succeed();
+        }
+      });
+    });
+    apiObject.setEnabled(false);
+    state = true;
+    apiObject.setEnabled(true);
+  },
+  function filterListsEvent() {
+    const kCustom = 'https://example.com/subscription.txt';
+    let data = [kCustom];
+    let attempts = 2;
+    apiObject.onFilterListsChanged.addListener(function() {
+      apiObject.getInstalledSubscriptions(function(custom) {
+        if (!(data.length + 3, custom.length)) {
+          chrome.test.fail('Unexpected subscription list');
+        }
+        if (--attempts == 0) {
+          chrome.test.succeed();
+        }
+        data = [];
+        apiObject.uninstallSubscription(kCustom);
+      });
+    });
+    apiObject.installSubscription(kCustom);
+  },
+  function customFiltersEvent() {
+    const filter = 'foo.bar';
+    let data = [filter];
+    let attempts = 2;
+    apiObject.onCustomFiltersChanged.addListener(function() {
+      apiObject.getCustomFilters(function(filters) {
+        if (!arrayEquals(data, filters)) {
+          chrome.test.fail('Unexpected custom filter list');
+        }
+        if (--attempts == 0) {
+          chrome.test.succeed();
+        }
+      });
+    });
+    apiObject.addCustomFilter(filter);
+    data = [];
+    apiObject.removeCustomFilter(filter);
+  },
+  function disableGeolocation() {
+    const geoLocatedList1 = urlParams.get('geolocated_list_1');
+    const geoLocatedList2 = urlParams.get('geolocated_list_2');
+    if (!geoLocatedList1 || !geoLocatedList2) {
+      chrome.test.fail('Failed: missing expected filter list param(s)');
+    }
+    apiObject.isAutoInstallEnabled(function(enabled) {
+      if (!enabled) {
+        chrome.test.fail('Failed: auto installed FL feature should be enabled by default');
+      }
+      apiObject.getInstalledSubscriptions(function(installed) {
+        if (!containsSubscription(installed, geoLocatedList1)
+            || !containsSubscription(installed, geoLocatedList2)) {
+          chrome.test.fail('Failed: Should contain expected auto installed filter lists');
+        }
+        // Make geoLocatedList1 not auto-installed
+        apiObject.uninstallSubscription(geoLocatedList1);
+        apiObject.installSubscription(geoLocatedList1);
+        apiObject.setAutoInstallEnabled(false);
+        apiObject.isAutoInstallEnabled(function(enabled) {
+          if (enabled) {
+            chrome.test.fail('Failed: auto installed FL feature should be disabled');
+          }
+          apiObject.getInstalledSubscriptions(function(installed) {
+            if (!containsSubscription(installed, geoLocatedList1)) {
+              chrome.test.fail('Failed: Should contain manually installed filter list');
+            }
+            if (containsSubscription(installed, geoLocatedList2)) {
+              chrome.test.fail('Failed: Should NOT contain auto installed filter list');
+            }
+            chrome.test.succeed();
+          });
+        });
+      });
+    });
+  },
+];
+
+chrome.test.runTests(availableTests.filter(function(op) {
+  return op.name == urlParams.get('subtest');
+}));
diff --git a/chrome/test/data/extensions/api_test/eyeo_filtering_private/empty.js b/chrome/test/data/extensions/api_test/eyeo_filtering_private/empty.js
new file mode 100644
--- /dev/null
+++ b/chrome/test/data/extensions/api_test/eyeo_filtering_private/empty.js
@@ -0,0 +1,14 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
diff --git a/chrome/test/data/extensions/api_test/eyeo_filtering_private/main.html b/chrome/test/data/extensions/api_test/eyeo_filtering_private/main.html
new file mode 100644
--- /dev/null
+++ b/chrome/test/data/extensions/api_test/eyeo_filtering_private/main.html
@@ -0,0 +1,29 @@
+<!--
+* This file is part of eyeo Chromium SDK,
+* Copyright (C) 2006-present eyeo GmbH
+*
+* eyeo Chromium SDK is free software: you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 3 as
+* published by the Free Software Foundation.
+*
+* eyeo Chromium SDK is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+-->
+<script src="test.js"></script>
+
+<html>
+
+<head>
+  <title>Eyeo filtering private API test</title>
+</head>
+
+<body>
+  <h2>chrome.eyeoFilteringPrivate.* tests</h2>
+</body>
+
+</html>
diff --git a/chrome/test/data/extensions/api_test/eyeo_filtering_private/manifest.json b/chrome/test/data/extensions/api_test/eyeo_filtering_private/manifest.json
new file mode 100644
--- /dev/null
+++ b/chrome/test/data/extensions/api_test/eyeo_filtering_private/manifest.json
@@ -0,0 +1,31 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+{
+  "name": "eyeoFilteringPrivate API test",
+  "key": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAkRxyv6tzqVnC+2gR3QxaN32fynw6GBZd9CXH8huHopx5xZ0fE1gScXnnjna7YW2sc6dhZZv326lRwmsJRwJN+RZpxBQbTD4CuCiqfUo+Xdyigh91QqyScLLRmg3SPsBBF9X/M50LO/6MD2eETiWbQQRy1TXNz52lt6NtjXKmS2lVZzR/jnGyAA96vMOmxeNIJmSYHFOHlSIphAJr/Erd0v1ZcBjJnZxqSrKZwUTHHc/FxcN1YqJkU/6O6gjMLNo3Uv33bqRAYmGUq+TTftwLg2hzEE1OllThcF9VVmQ3HZ5eTqqw/XP/tiQ/vUBflKer2mSVk708VBNpktao44kAtQIDAQAB",
+  "version": "0.1",
+  "incognito": "split",
+  "manifest_version": 3,
+  "background": {
+    "service_worker": "empty.js"
+  },
+  "description": "Test of chrome.eyeoFilteringPrivate interface",
+  "host_permissions": [
+    "<all_urls>"
+  ],
+  "permissions": [
+    "eyeoFilteringPrivate"
+  ]
+}
diff --git a/chrome/test/data/extensions/api_test/eyeo_filtering_private/test.js b/chrome/test/data/extensions/api_test/eyeo_filtering_private/test.js
new file mode 100644
--- /dev/null
+++ b/chrome/test/data/extensions/api_test/eyeo_filtering_private/test.js
@@ -0,0 +1,429 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+'use strict';
+
+const custom_config = 'custom';
+
+async function pollUntil(predicate, pollEveryMs) {
+  return new Promise(r => {
+    const id = setInterval(() => {
+      let ret;
+      if (ret = predicate()) {
+        clearInterval(id);
+        r(ret);
+      }
+    }, pollEveryMs);
+  });
+}
+
+function containsSubscription(subscriptions, url) {
+  for (const subscription of subscriptions) {
+    if (subscription.url === url) {
+      return true;
+    }
+  }
+  return false;
+}
+
+function arrayEquals(a, b) {
+  if (a === b)
+    return true;
+  if (a === null || b === null)
+    return false;
+  if (a.length !== b.length)
+    return false;
+  for (var i = 0; i < a.length; i++) {
+    if (a[i] !== b[i])
+      return false;
+  }
+  return true;
+};
+
+const availableTests = [
+  function createRemoveAndGetConfigurations() {
+    chrome.eyeoFilteringPrivate.getConfigurations(function(configs) {
+      if (configs.includes(custom_config)) {
+        chrome.test.fail('Failed: There should NOT be a custom configuration');
+      }
+      chrome.eyeoFilteringPrivate.createConfiguration(custom_config);
+      chrome.eyeoFilteringPrivate.getConfigurations(function(configs) {
+        if (!configs.includes(custom_config)) {
+          chrome.test.fail('Failed: There should be a custom configuration');
+        }
+        chrome.eyeoFilteringPrivate.removeConfiguration(custom_config);
+        chrome.eyeoFilteringPrivate.getConfigurations(function(configs) {
+          if (configs.includes(custom_config)) {
+            chrome.test.fail('Failed: There should NOT be a custom configuration');
+          }
+          chrome.test.succeed();
+        });
+      });
+    });
+  },
+  async function createRemoveAndGetConfigurationsWithPromises() {
+    let configs = await chrome.eyeoFilteringPrivate.getConfigurations();
+    if (configs.includes(custom_config)) {
+      chrome.test.fail('Failed: There should NOT be a custom configuration');
+    }
+    chrome.eyeoFilteringPrivate.createConfiguration(custom_config);
+    configs = await chrome.eyeoFilteringPrivate.getConfigurations();
+    if (!configs.includes(custom_config)) {
+      chrome.test.fail('Failed: There should be a custom configuration');
+    }
+    chrome.eyeoFilteringPrivate.removeConfiguration(custom_config);
+    configs = await chrome.eyeoFilteringPrivate.getConfigurations();
+    if (configs.includes(custom_config)) {
+      chrome.test.fail('Failed: There should NOT be a custom configuration');
+    } else {
+      chrome.test.succeed();
+    }
+  },
+  function enableAndDisableConfiguration() {
+    chrome.eyeoFilteringPrivate.createConfiguration(custom_config);
+    chrome.eyeoFilteringPrivate.isEnabled(custom_config, function(enabled) {
+      if (!enabled) {
+        chrome.test.fail('Failed: Configuration should be enabled');
+      }
+      chrome.eyeoFilteringPrivate.setEnabled(custom_config, false);
+      chrome.eyeoFilteringPrivate.isEnabled(custom_config, function(enabled) {
+        if (enabled) {
+          chrome.test.fail('Failed: Configuration should NOT be enabled');
+        }
+        chrome.eyeoFilteringPrivate.setEnabled(custom_config, true);
+        chrome.eyeoFilteringPrivate.isEnabled(custom_config, function(enabled) {
+          if (!enabled) {
+            chrome.test.fail('Failed: Configuration should be enabled');
+          }
+          chrome.test.succeed();
+        });
+      });
+    });
+  },
+  function enableAndDisableConfigurationWithPromises() {
+    chrome.eyeoFilteringPrivate.createConfiguration(custom_config);
+    chrome.eyeoFilteringPrivate.isEnabled(custom_config)
+      .then(enabled => {
+        if (!enabled) {
+          throw 'Failed: Configuration should be enabled';
+        }
+        chrome.eyeoFilteringPrivate.setEnabled(custom_config, false);
+      })
+      .then(() => chrome.eyeoFilteringPrivate.isEnabled(custom_config))
+      .then(enabled => {
+        if (enabled) {
+          throw 'Failed: Configuration should NOT be enabled';
+        }
+        chrome.eyeoFilteringPrivate.setEnabled(custom_config, true);
+      })
+      .then(() => chrome.eyeoFilteringPrivate.isEnabled(custom_config))
+      .then(enabled => {
+        if (!enabled) {
+          throw 'Failed: Configuration should be enabled';
+        }
+        chrome.test.succeed();
+      })
+      .catch(message => chrome.test.fail(message))
+  },
+  function addAllowedDomainToCustomConfiguration() {
+    const domain = 'domain.com';
+    chrome.eyeoFilteringPrivate.createConfiguration(custom_config);
+    chrome.eyeoFilteringPrivate.addAllowedDomain(custom_config, domain);
+    chrome.eyeoFilteringPrivate.getAllowedDomains(
+        custom_config, function(domains) {
+      if (domains.length != 1 || domains.indexOf(domain) == -1) {
+        chrome.test.fail('Failed: There should be a custom domain');
+      }
+      chrome.eyeoFilteringPrivate.removeAllowedDomain(custom_config, domain);
+      chrome.eyeoFilteringPrivate.getAllowedDomains(
+          custom_config, function(domains) {
+        if (domains.length) {
+          chrome.test.fail('Failed: Still have custom domain(s)');
+        }
+        chrome.test.succeed();
+      });
+    });
+  },
+  function addAllowedDomainToCustomConfigurationWithPromises() {
+    const domain = 'domain.com';
+    chrome.eyeoFilteringPrivate.createConfiguration(custom_config);
+    chrome.eyeoFilteringPrivate.addAllowedDomain(custom_config, domain)
+      .then(() => chrome.eyeoFilteringPrivate.getAllowedDomains(custom_config))
+      .then(domains => {
+        if (domains.length != 1 || domains.indexOf(domain) == -1) {
+          throw 'Failed: There should be a custom domain';
+        }
+        chrome.eyeoFilteringPrivate.removeAllowedDomain(custom_config, domain);
+      })
+      .then(() => chrome.eyeoFilteringPrivate.getAllowedDomains(custom_config))
+      .then(domains => {
+        if (domains.length) {
+          throw 'Failed: Still have custom domain(s)';
+        }
+        chrome.test.succeed();
+      })
+      .catch(message => chrome.test.fail(message))
+  },
+  function addCustomFilterToCustomConfiguration() {
+    const filter = '||foo.bar';
+    chrome.eyeoFilteringPrivate.createConfiguration(custom_config);
+    chrome.eyeoFilteringPrivate.addCustomFilter(custom_config, filter);
+    chrome.eyeoFilteringPrivate.getCustomFilters(
+        custom_config, function(filters) {
+      if (filters.length != 1 || filters.indexOf(filter) == -1) {
+        chrome.test.fail('Failed: There should be a custom filter');
+      }
+      chrome.eyeoFilteringPrivate.removeCustomFilter(custom_config, filter);
+      chrome.eyeoFilteringPrivate.getCustomFilters(
+          custom_config, function(filters) {
+        if (filters.length) {
+          chrome.test.fail('Failed: Still have custom filter(s)');
+        }
+        chrome.test.succeed();
+      });
+    });
+  },
+  function addCustomFilterToCustomConfigurationWithPromises() {
+    const filter = '||foo.bar';
+    chrome.eyeoFilteringPrivate.createConfiguration(custom_config);
+    chrome.eyeoFilteringPrivate.addCustomFilter(custom_config, filter)
+      .then(() => chrome.eyeoFilteringPrivate.getCustomFilters(custom_config))
+      .then(filters => {
+        if (filters.length != 1 || filters.indexOf(filter) == -1) {
+          throw 'Failed: There should be a custom filter';
+        }
+        chrome.eyeoFilteringPrivate.removeCustomFilter(custom_config, filter);
+      })
+      .then(() => chrome.eyeoFilteringPrivate.getCustomFilters(custom_config))
+      .then(filters => {
+        if (filters.length) {
+          throw 'Failed: Still have custom filter(s)';
+        }
+        chrome.test.succeed();
+      })
+      .catch(message => chrome.test.fail(message));
+  },
+  function addFilterListInCustomConfiguration() {
+    const subscription = 'https://example.com/subscription.txt';
+    chrome.eyeoFilteringPrivate.createConfiguration(custom_config);
+    chrome.eyeoFilteringPrivate.addFilterList(custom_config, subscription);
+    chrome.eyeoFilteringPrivate.getFilterLists(
+        custom_config, function(subscriptions) {
+      if (subscriptions.length != 1 || !containsSubscription(subscriptions, subscription)) {
+        chrome.test.fail('Failed: There should be a single custom subscription');
+      }
+      chrome.eyeoFilteringPrivate.removeFilterList(custom_config, subscription);
+      chrome.eyeoFilteringPrivate.getFilterLists(
+          custom_config, function(subscriptions) {
+        if (subscriptions.length) {
+          chrome.test.fail('Failed: Still have custom subscription(s)');
+        }
+        chrome.test.succeed();
+      });
+    });
+  },
+  function addFilterListInCustomConfigurationWithPromises() {
+    const subscription = 'https://example.com/subscription.txt';
+    chrome.eyeoFilteringPrivate.createConfiguration(custom_config);
+    chrome.eyeoFilteringPrivate.addFilterList(custom_config, subscription)
+      .then(() => chrome.eyeoFilteringPrivate.getFilterLists(custom_config))
+      .then(subscriptions => {
+        if (subscriptions.length != 1 || !containsSubscription(subscriptions, subscription)) {
+          throw 'Failed: There should be a single custom subscription';
+        }
+        chrome.eyeoFilteringPrivate.removeFilterList(custom_config, subscription);
+      })
+      .then(() => chrome.eyeoFilteringPrivate.getFilterLists(custom_config))
+      .then(subscriptions => {
+        if (subscriptions.length) {
+          throw 'Failed: Still have custom subscription(s)';
+        }
+        chrome.test.succeed();
+      })
+      .catch(message => chrome.test.fail(message));
+  },
+  async function missingConfiguration() {
+    const input = 'https://dummy.com';
+    const expectedError = 'Configuration with name \'custom\' does not exist!';
+    const setters = [
+      'addFilterList', 'removeFilterList', 'addAllowedDomain',
+      'removeAllowedDomain', 'addCustomFilter', 'removeCustomFilter'
+    ];
+    const getters = [
+      'isEnabled', 'getFilterLists', 'getAllowedDomains', 'getCustomFilters'
+    ];
+    const allMethodsCount = 1 + setters.length + getters.length;
+    let counter = 0;
+    chrome.eyeoFilteringPrivate.setEnabled(custom_config, false, function() {
+      if (!chrome.runtime.lastError) {
+        chrome.test.fail('Failed: missing configuration accepted');
+      }
+      chrome.test.assertEq(expectedError, chrome.runtime.lastError.message);
+      ++counter;
+    });
+    for (const method of setters) {
+      chrome.eyeoFilteringPrivate[method](custom_config, input, function() {
+        if (!chrome.runtime.lastError) {
+          chrome.test.fail('Failed: missing configuration accepted');
+        }
+        chrome.test.assertEq(expectedError, chrome.runtime.lastError.message);
+        ++counter;
+      });
+    }
+    for (const method of getters) {
+      chrome.eyeoFilteringPrivate[method](custom_config, function(result) {
+        if (!chrome.runtime.lastError) {
+          chrome.test.fail('Failed: missing configuration accepted');
+        }
+        chrome.test.assertEq(expectedError, chrome.runtime.lastError.message);
+        ++counter;
+      });
+    }
+    await pollUntil(() => counter === allMethodsCount, 100);
+    chrome.test.succeed();
+  },
+  async function missingConfigurationWithPromises() {
+    const input = 'https://dummy.com';
+    const expectedError =
+        'Error: Configuration with name \'custom\' does not exist!'
+    const setters = [
+      'addFilterList', 'removeFilterList', 'addAllowedDomain',
+      'removeAllowedDomain', 'addCustomFilter', 'removeCustomFilter'
+    ];
+    const getters = [
+      'isEnabled', 'getFilterLists', 'getAllowedDomains', 'getCustomFilters'
+    ];
+    const allMethodsCount = 1 + setters.length + getters.length;
+    let counter = 0;
+    const errorHandler = function(error) {
+      chrome.test.assertEq(expectedError, error.toString());
+      ++counter;
+    };
+    await chrome.eyeoFilteringPrivate.setEnabled(custom_config, false)
+        .catch(error => errorHandler(error));
+    for (const method of setters) {
+      await chrome.eyeoFilteringPrivate[method](custom_config, input)
+          .catch(error => errorHandler(error));
+    }
+    for (const method of getters) {
+      await chrome.eyeoFilteringPrivate[method](custom_config)
+          .catch(error => errorHandler(error));
+    }
+    if (counter == allMethodsCount) {
+      chrome.test.succeed();
+    } else {
+      chrome.test.fail('Failed: expected missing configuration for every call');
+    }
+  },
+  function allowedDomainsEvent() {
+    const domain = 'domain.com';
+    let data = [domain];
+    let attempts = 2;
+    chrome.eyeoFilteringPrivate.onAllowedDomainsChanged.addListener(function(
+        config_name) {
+      if (config_name != custom_config) {
+        chrome.test.fail('Failed: Wrong config name');
+      }
+      chrome.eyeoFilteringPrivate.getAllowedDomains(
+          custom_config, function(domains) {
+            if (!arrayEquals(data, domains)) {
+              chrome.test.fail('Unexpected domain list');
+            }
+            if (--attempts == 0) {
+              chrome.test.succeed();
+            }
+          });
+    });
+    chrome.eyeoFilteringPrivate.createConfiguration(custom_config);
+    chrome.eyeoFilteringPrivate.addAllowedDomain(custom_config, domain);
+    data = [];
+    chrome.eyeoFilteringPrivate.removeAllowedDomain(custom_config, domain);
+  },
+  function enabledStateEvent() {
+    let state = false;
+    let attempts = 2;
+    chrome.eyeoFilteringPrivate.onEnabledStateChanged.addListener(function(
+        config_name) {
+      if (config_name != custom_config) {
+        chrome.test.fail('Failed: Wrong config name');
+      }
+      chrome.eyeoFilteringPrivate.isEnabled(custom_config, function(enabled) {
+        if (enabled !== state) {
+          chrome.test.fail('Unexpected enabled state');
+        }
+        if (--attempts == 0) {
+          chrome.test.succeed();
+        }
+      });
+    });
+    chrome.eyeoFilteringPrivate.createConfiguration(custom_config);
+    chrome.eyeoFilteringPrivate.setEnabled(custom_config, false);
+    state = true;
+    chrome.eyeoFilteringPrivate.setEnabled(custom_config, true);
+  },
+  function filterListsEvent() {
+    const list = 'http://example.com/list.txt';
+    let data = [list];
+    let attempts = 2;
+    chrome.eyeoFilteringPrivate.onFilterListsChanged.addListener(function(
+        config_name) {
+      if (config_name != custom_config) {
+        chrome.test.fail('Failed: Wrong config name');
+      }
+      chrome.eyeoFilteringPrivate.getFilterLists(
+          custom_config, function(custom) {
+            if (!arrayEquals(data, custom)) {
+              chrome.test.fail('Unexpected subscription list');
+            }
+            if (--attempts == 0) {
+              chrome.test.succeed();
+            }
+          });
+    });
+    chrome.eyeoFilteringPrivate.createConfiguration(custom_config);
+    chrome.eyeoFilteringPrivate.addFilterList(custom_config, list);
+    data = [];
+    chrome.eyeoFilteringPrivate.removeFilterList(custom_config, list);
+  },
+  function customFiltersEvent() {
+    const filter = 'foo.bar';
+    let data = [filter];
+    let attempts = 2;
+    chrome.eyeoFilteringPrivate.onCustomFiltersChanged.addListener(function(
+        config_name) {
+      if (config_name != custom_config) {
+        chrome.test.fail('Failed: Wrong config name');
+      }
+      chrome.eyeoFilteringPrivate.getCustomFilters(
+          custom_config, function(filters) {
+            if (!arrayEquals(data, filters)) {
+              chrome.test.fail('Unexpected custom filter list');
+            }
+            if (--attempts == 0) {
+              chrome.test.succeed();
+            }
+          });
+    });
+    chrome.eyeoFilteringPrivate.createConfiguration(custom_config);
+    chrome.eyeoFilteringPrivate.addCustomFilter(custom_config, filter);
+    data = [];
+    chrome.eyeoFilteringPrivate.removeCustomFilter(custom_config, filter);
+  },
+];
+
+const urlParams = new URLSearchParams(window.location.search);
+chrome.test.runTests(availableTests.filter(function(op) {
+  return op.name == urlParams.get('subtest');
+}));
diff --git a/extensions/browser/extension_event_histogram_value.h b/extensions/browser/extension_event_histogram_value.h
--- a/extensions/browser/extension_event_histogram_value.h
+++ b/extensions/browser/extension_event_histogram_value.h
@@ -1,6 +1,10 @@
 // Copyright 2015 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 #ifndef EXTENSIONS_BROWSER_EXTENSION_EVENT_HISTOGRAM_VALUE_H_
 #define EXTENSIONS_BROWSER_EXTENSION_EVENT_HISTOGRAM_VALUE_H_
@@ -42,7 +46,8 @@ enum HistogramValue {
   APP_WINDOW_ON_MAXIMIZED = 19,
   APP_WINDOW_ON_MINIMIZED = 20,
   APP_WINDOW_ON_RESTORED = 21,
-  DELETED_AUDIO_MODEM_ON_RECEIVED = 22,
+  EYEO_EVENT = 22,  // Reusing a DELETED_AUDIO_MODEM_ON_RECEIVED to avoid merge
+                    // conflicts.
   DELETED_AUDIO_MODEM_ON_TRANSMIT_FAIL = 23,
   DELETED_AUDIO_ON_DEVICE_CHANGED = 24,
   AUDIO_ON_DEVICES_CHANGED = 25,
diff --git a/extensions/common/mojom/api_permission_id.mojom b/extensions/common/mojom/api_permission_id.mojom
--- a/extensions/common/mojom/api_permission_id.mojom
+++ b/extensions/common/mojom/api_permission_id.mojom
@@ -1,6 +1,10 @@
 // Copyright 2021 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+//
+// This source code is a part of eyeo Chromium SDK.
+// Use of this source code is governed by the GPLv3 that can be found in the
+// components/adblock/LICENSE file.
 
 module extensions.mojom;
 
@@ -288,6 +292,8 @@ enum APIPermissionID {
   kOmniboxDirectInput = 261,
   kExperimentalActor = 262,
   kEnterpriseLogin = 263,
+  kAdblockPrivate = 999,
+  kEyeoFilteringPrivate = 1000,
 
   // Add new entries at the end of the enum and be sure to update the
   // "ExtensionPermission3" enum in
diff --git a/tools/metrics/histograms/enums.xml b/tools/metrics/histograms/enums.xml
--- a/tools/metrics/histograms/enums.xml
+++ b/tools/metrics/histograms/enums.xml
@@ -17,6 +17,9 @@ https://chromium.googlesource.com/chromium/src.git/+/HEAD/tools/metrics/histogra
 Please pretty-print and validate your edits by running the pretty_print.py
 and validate_format.py scripts in the same directory as this file before
 uploading your change for review.  These are checked by presubmit scripts.
+
+This source code is a part of eyeo Chromium SDK.
+Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
 -->
 
 <histogram-configuration>
diff --git a/tools/typescript/definitions/adblock_private.d.ts b/tools/typescript/definitions/adblock_private.d.ts
new file mode 100644
--- /dev/null
+++ b/tools/typescript/definitions/adblock_private.d.ts
@@ -0,0 +1,182 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+/** @fileoverview Type definitions for chrome.adblockPrivate API. */
+
+import {ChromeEvent} from './chrome_event.js';
+
+declare global {
+  export namespace chrome {
+    export namespace adblockPrivate {
+
+      export interface BuiltInSubscription {
+        url: string;
+        title: string;
+        languages: string[];
+      }
+
+      export interface Subscription {
+        url: string;
+        installation_state: string;
+        title: string;
+        current_version: string;
+        last_installation_time: string;
+      }
+
+      export interface SessionStatsEntry {
+        url: string;
+        count: number;
+      }
+
+      export interface AdInfo {
+        url: string;
+        parent_frame_urls: string[];
+        subscription: string;
+        configuration_name: string;
+        content_type: string;
+        tab_id: number;
+        window_id: number;
+      }
+
+      export const onAdAllowed: ChromeEvent<(
+        info: AdInfo,
+      ) => void>;
+
+      export const onAdBlocked: ChromeEvent<(
+        info: AdInfo,
+      ) => void>;
+
+      export const onPageAllowed: ChromeEvent<(
+        info: AdInfo,
+      ) => void>;
+
+      export const onPopupBlocked: ChromeEvent<(
+        info: AdInfo,
+      ) => void>;
+
+      export const onPopupAllowed: ChromeEvent<(
+        info: AdInfo,
+      ) => void>;
+
+      export const onSubscriptionUpdated: ChromeEvent<(
+        subscription_url: string,
+      ) => void>;
+
+      export const onEnabledStateChanged: ChromeEvent<(
+      ) => void>;
+
+      export const onFilterListsChanged: ChromeEvent<(
+      ) => void>;
+
+      export const onAllowedDomainsChanged: ChromeEvent<(
+      ) => void>;
+
+      export const onCustomFiltersChanged: ChromeEvent<(
+      ) => void>;
+
+      export function setEnabled(
+        enabled: boolean,
+      ): void;
+
+      export function isEnabled(
+        callback: (
+          result: boolean,
+        ) => void,
+      ): void;
+
+      export function setAcceptableAdsEnabled(
+        enabled: boolean,
+      ): void;
+
+      export function isAcceptableAdsEnabled(
+        callback: (
+          result: boolean,
+        ) => void,
+      ): void;
+
+      export function setAutoInstallEnabled(
+        enabled: boolean,
+      ): void;
+
+      export function isAutoInstallEnabled(
+        callback: (
+          result: boolean,
+        ) => void,
+      ): void;
+
+      export function getBuiltInSubscriptions(
+        callback: (
+          result: BuiltInSubscription[],
+        ) => void,
+      ): void;
+
+      export function addAllowedDomain(
+        domain: string,
+      ): void;
+
+      export function removeAllowedDomain(
+        domain: string,
+      ): void;
+
+      export function getAllowedDomains(
+        callback: (
+          result: string[],
+        ) => void,
+      ): void;
+
+      export function addCustomFilter(
+        filter: string,
+      ): void;
+
+      export function removeCustomFilter(
+        filter: string,
+      ): void;
+
+      export function getCustomFilters(
+        callback: (
+          result: string[],
+        ) => void,
+      ): void;
+
+      export function getSessionAllowedAdsCount(
+        callback: (
+          result: SessionStatsEntry[],
+        ) => void,
+      ): void;
+
+      export function getSessionBlockedAdsCount(
+        callback: (
+          result: SessionStatsEntry[],
+        ) => void,
+      ): void;
+
+      export function getInstalledSubscriptions(
+        callback: (
+          result: Subscription[],
+        ) => void,
+      ): void;
+
+      export function installSubscription(
+        url: string,
+        feedback?: () => void,
+      ): void;
+
+      export function uninstallSubscription(
+        url: string,
+        feedback?: () => void,
+      ): void;
+    }
+  }
+}
diff --git a/tools/typescript/definitions/eyeo_filtering_private.d.ts b/tools/typescript/definitions/eyeo_filtering_private.d.ts
new file mode 100644
--- /dev/null
+++ b/tools/typescript/definitions/eyeo_filtering_private.d.ts
@@ -0,0 +1,266 @@
+// This file is part of eyeo Chromium SDK,
+// Copyright (C) 2006-present eyeo GmbH
+//
+// eyeo Chromium SDK is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License version 3 as
+// published by the Free Software Foundation.
+//
+// eyeo Chromium SDK is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
+
+/** @fileoverview Type definitions for chrome.eyeoFilteringPrivate API. */
+
+import {ChromeEvent} from './chrome_event.js';
+
+declare global {
+  export namespace chrome {
+    export namespace eyeoFilteringPrivate {
+
+      export interface Subscription {
+        url: string;
+        installation_state: string;
+        title: string;
+        current_version: string;
+        last_installation_time: string;
+      }
+
+      export interface SessionStatsEntry {
+        url: string;
+        count: number;
+      }
+
+      export interface RequestInfo {
+        url: string;
+        parent_frame_urls: string[];
+        subscription: string;
+        configuration_name: string;
+        content_type: string;
+        tab_id: number;
+        window_id: number;
+      }
+
+      export const onRequestAllowed: ChromeEvent<(
+        info: RequestInfo,
+      ) => void>;
+
+      export const onRequestBlocked: ChromeEvent<(
+        info: RequestInfo,
+      ) => void>;
+
+      export const onPageAllowed: ChromeEvent<(
+        info: RequestInfo,
+      ) => void>;
+
+      export const onPopupBlocked: ChromeEvent<(
+        info: RequestInfo,
+      ) => void>;
+
+      export const onPopupAllowed: ChromeEvent<(
+        info: RequestInfo,
+      ) => void>;
+
+      export const onSubscriptionUpdated: ChromeEvent<(
+        subscription_url: string,
+      ) => void>;
+
+      export const onEnabledStateChanged: ChromeEvent<(
+        config_name: string,
+      ) => void>;
+
+      export const onFilterListsChanged: ChromeEvent<(
+        config_name: string,
+      ) => void>;
+
+      export const onAllowedDomainsChanged: ChromeEvent<(
+        config_name: string,
+      ) => void>;
+
+      export const onCustomFiltersChanged: ChromeEvent<(
+        config_name: string,
+      ) => void>;
+
+      export function createConfiguration(
+        config_name: string,
+      ): void;
+
+      export function removeConfiguration(
+        config_name: string,
+      ): void;
+
+      export function getConfigurations(): Promise<string[]>;
+
+      export function getConfigurations(
+        callback?: (
+          result: string[],
+        ) => void,
+      ): void;
+
+      export function setEnabled(
+        configuration: string,
+        enabled: boolean,
+      ): Promise<void>;
+
+      export function setEnabled(
+        configuration: string,
+        enabled: boolean,
+        status?: () => void,
+      ): void;
+
+      export function isEnabled(
+        configuration: string,
+      ): Promise<boolean>;
+
+      export function isEnabled(
+        configuration: string,
+        callback?: (
+          result: boolean,
+        ) => void,
+      ): void;
+
+      export function setAutoInstallEnabled(
+        enabled: boolean,
+      ): Promise<void>;
+
+      export function setAutoInstallEnabled(
+        enabled: boolean,
+        status?: () => void,
+      ): void;
+
+      export function isAutoInstallEnabled(): Promise<boolean>;
+
+      export function isAutoInstallEnabled(
+        callback?: (
+          result: boolean,
+        ) => void,
+      ): void;
+
+      export function addAllowedDomain(
+        configuration: string,
+        domain: string,
+      ): Promise<void>;
+
+      export function addAllowedDomain(
+        configuration: string,
+        domain: string,
+        status?: () => void,
+      ): void;
+
+      export function removeAllowedDomain(
+        configuration: string,
+        domain: string,
+      ): Promise<void>;
+
+      export function removeAllowedDomain(
+        configuration: string,
+        domain: string,
+        status?: () => void,
+      ): void;
+
+      export function getAllowedDomains(
+        configuration: string,
+      ): Promise<string[]>;
+
+      export function getAllowedDomains(
+        configuration: string,
+        callback?: (
+          result: string[],
+        ) => void,
+      ): void;
+
+      export function addCustomFilter(
+        configuration: string,
+        filter: string,
+      ): Promise<void>;
+
+      export function addCustomFilter(
+        configuration: string,
+        filter: string,
+        status?: () => void,
+      ): void;
+
+      export function removeCustomFilter(
+        configuration: string,
+        filter: string,
+      ): Promise<void>;
+
+      export function removeCustomFilter(
+        configuration: string,
+        filter: string,
+        status?: () => void,
+      ): void;
+
+      export function getCustomFilters(
+        configuration: string,
+      ): Promise<string[]>;
+
+      export function getCustomFilters(
+        configuration: string,
+        callback?: (
+          result: string[],
+        ) => void,
+      ): void;
+
+      export function getFilterLists(
+        configuration: string,
+      ): Promise<Subscription[]>;
+
+      export function getFilterLists(
+        configuration: string,
+        callback?: (
+          result: Subscription[],
+        ) => void,
+      ): void;
+
+      export function addFilterList(
+        configuration: string,
+        url: string,
+      ): Promise<void>;
+
+      export function addFilterList(
+        configuration: string,
+        url: string,
+        status?: () => void,
+      ): void;
+
+      export function removeFilterList(
+        configuration: string,
+        url: string,
+      ): Promise<void>;
+
+      export function removeFilterList(
+        configuration: string,
+        url: string,
+        status?: () => void,
+      ): void;
+
+      export function getSessionAllowedRequestsCount(): Promise<SessionStatsEntry[]>;
+
+      export function getSessionAllowedRequestsCount(
+        callback?: (
+          result: SessionStatsEntry[],
+        ) => void,
+      ): void;
+
+      export function getSessionBlockedRequestsCount(): Promise<SessionStatsEntry[]>;
+
+      export function getSessionBlockedRequestsCount(
+        callback?: (
+          result: SessionStatsEntry[],
+        ) => void,
+      ): void;
+
+      export function getAcceptableAdsUrl(): Promise<string>;
+
+      export function getAcceptableAdsUrl(
+        callback?: (
+          result: string,
+        ) => void,
+      ): void;
+    }
+  }
+}
--
