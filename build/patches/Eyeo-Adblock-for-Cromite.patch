From: uazo <uazo@users.noreply.github.com>
Date: Thu, 29 Sep 2022 11:27:35 +0000
Subject: Eyeo Adblock for Cromite

Change the normal behaviour of Eyeo Chromium SDK to
suit Cromite logic.
---
 .../android/java/res/xml/main_preferences.xml |   19 +-
 .../adblock_chrome_content_browser_client.cc  |    6 +
 .../adblock_chrome_content_browser_client.h   |    4 +
 chrome/browser/adblock/android/BUILD.gn       |    3 +-
 .../adblock/android/adblock_strings.grd       |   56 +-
 .../java/res/layout/adblock_custom_item.xml   |   14 +-
 .../layout/adblock_filter_lists_list_item.xml |   15 +
 ...ences.xml => eyeo_adblock_preferences.xml} |   42 +-
 .../AdblockAllowedDomainsFragment.java        |    7 +-
 .../AdblockCustomFilterListsFragment.java     |   37 +-
 .../AdblockCustomFiltersFragment.java         |    7 +-
 .../settings/AdblockCustomItemFragment.java   |   26 +-
 .../settings/AdblockFilterListsAdapter.java   |    6 +
 .../settings/AdblockFilterListsFragment.java  |    8 +-
 .../settings/AdblockSettingsFragment.java     |   96 +-
 .../browser/chrome_content_browser_client.cc  |    6 +-
 .../browser/chrome_content_browser_client.h   |    6 +-
 .../adblock_private/adblock_private_api.cc    |   76 +-
 .../api/adblock_private/adblock_private_api.h |   49 +
 .../eyeo_filtering_private_api.cc             |   25 +-
 .../api/settings_private/prefs_util.cc        |   14 +
 ...hrome_browser_main_extra_parts_profiles.cc |    2 -
 chrome/browser/resources/settings/BUILD.gn    |    2 +
 .../settings/adblock_page/adblock_page.html   |  218 +
 .../settings/adblock_page/adblock_page.ts     |  319 +
 .../resources/settings/page_visibility.ts     |    1 +
 chrome/browser/resources/settings/route.ts    |    4 +
 chrome/browser/resources/settings/router.ts   |    1 +
 chrome/browser/resources/settings/settings.ts |    1 +
 .../settings/settings_main/settings_main.html |    7 +
 .../settings/settings_main/settings_main.ts   |    1 +
 .../settings/settings_menu/settings_menu.html |    5 +
 chrome/browser/ui/tab_helpers.cc              |    3 +-
 .../extensions/api/_permission_features.json  |   14 -
 .../common/extensions/api/adblock_private.idl |    8 +
 .../adblock/android/adblock_controller_jni.cc |   85 +-
 .../components/adblock/AdblockController.java |   53 +-
 components/adblock/content/browser/BUILD.gn   |   24 +-
 .../content/browser/adblock_blocking_page.cc  |  183 +
 .../content/browser/adblock_blocking_page.h   |   75 +
 .../browser/adblock_content_browser_client.h  |  241 +-
 .../browser/adblock_internals_page_handler.cc |    9 +-
 .../browser/adblock_url_loader_factory.cc     |   72 +-
 .../adblock_web_ui_controller_factory.cc      |    1 +
 .../browser/adblock_webcontents_observer.cc   |   63 +-
 .../browser/adblock_webcontents_observer.h    |    5 +-
 .../content/browser/element_hider_impl.cc     |   17 +-
 .../content/browser/eyeo_document_info.cc     |   15 +
 .../content/browser/eyeo_document_info.h      |    9 +
 .../adblock_request_throttle_factory.cc       |    2 +-
 .../adblock_telemetry_service_factory.cc      |    7 -
 .../browser/factories/embedding_utils.cc      |    2 -
 .../browser/factories/embedding_utils.h       |    7 +-
 .../factories/subscription_service_factory.cc |   22 +-
 .../factories/subscription_service_factory.h  |    1 +
 .../browser/frame_hierarchy_builder.cc        |    1 +
 .../content/browser/page_view_stats.cc        |   83 +-
 .../browser/resource_classification_runner.h  |    7 +
 .../resource_classification_runner_impl.cc    |   71 +-
 .../resource_classification_runner_impl.h     |    8 +
 components/adblock/core/BUILD.gn              |   39 -
 components/adblock/core/common/BUILD.gn       |    8 -
 .../adblock/core/common/adblock_constants.cc  |   17 +-
 .../adblock/core/common/adblock_constants.h   |    1 -
 .../adblock/core/common/adblock_prefs.cc      |   66 +-
 .../adblock/core/common/adblock_prefs.h       |    9 +-
 components/adblock/core/common/app_info.cc    |   17 +-
 components/adblock/core/common/app_info.h     |    1 -
 .../configuration/filtering_configuration.h   |    5 +
 .../persistent_filtering_configuration.cc     |   37 +-
 .../persistent_filtering_configuration.h      |    6 +
 .../core/converter/flatbuffer_converter.cc    |    2 +-
 .../converter/parser/filter_classifier.cc     |    5 +-
 .../adblock/core/converter/parser/metadata.cc |   14 +-
 .../core/converter/parser/test/test_rules.txt |   21 +
 .../core/converter/parser/url_filter.cc       |   20 +-
 .../converter/parser/url_filter_options.cc    |   34 +-
 .../serializer/filter_keyword_extractor.cc    |   13 +-
 .../serializer/flatbuffer_serializer.cc       |  102 +-
 components/adblock/core/features.cc           |    6 +-
 .../core/net/adblock_resource_request_impl.cc |   26 +-
 components/adblock/core/resources/.gitignore  |    2 +-
 components/adblock/core/resources/BUILD.gn    |    5 +-
 .../core/resources/adblock_resources.grd      |    5 +-
 .../core/resources/elemhide_for_selector.jst  |    4 +-
 .../adblock/core/resources/elemhideemu.jst    |    2 +
 .../resources/snippets/dist/dependencies.jst  | 1690 ++++++
 .../dist/isolated-first-all.source.jst        | 5256 +++++++++++++++++
 .../adblock/core/sitekey_storage_impl.cc      |   17 +-
 .../core/subscription/conversion_executors.h  |    1 +
 .../filtering_configuration_maintainer.h      |    4 +
 ...filtering_configuration_maintainer_impl.cc |   36 +-
 .../filtering_configuration_maintainer_impl.h |    4 +-
 .../preloaded_subscription_provider_impl.cc   |    4 +-
 ...recommended_subscription_installer_impl.cc |    1 +
 .../adblock/core/subscription/subscription.cc |   20 +
 .../adblock/core/subscription/subscription.h  |    3 +
 .../subscription_collection_impl.cc           |    1 +
 .../core/subscription/subscription_config.cc  |   86 +-
 .../core/subscription/subscription_config.h   |    6 +-
 .../subscription_downloader_impl.cc           |   19 +-
 .../subscription_persistent_metadata.h        |    1 +
 .../subscription_persistent_metadata_impl.cc  |    7 +
 .../subscription_persistent_metadata_impl.h   |    1 +
 .../subscription_persistent_storage_impl.cc   |   11 +-
 .../core/subscription/subscription_service.h  |   11 +
 .../subscription/subscription_service_impl.cc |   87 +-
 .../subscription/subscription_service_impl.h  |   10 +
 .../subscription_validator_impl.cc            |    4 +-
 components/adblock/features.gni               |    2 +-
 components/blocked_content/popup_blocker.cc   |    9 +-
 components/blocked_content/popup_blocker.h    |    3 +
 .../browser/bromite_content_settings/ads.inc  |    3 +
 components/error_page_strings.grdp            |   16 +
 .../resources/interstitial_enterprisewarn.css |    7 +
 .../websockets/websocket_connector_impl.cc    |    6 +-
 .../public/browser/content_browser_client.cc  |    4 +-
 .../public/browser/content_browser_client.h   |    4 +-
 content/public/common/isolated_world_ids.h    |    2 +-
 .../about_flags_cc/Stricter-popup-blocker.inc |   14 +
 .../blink/renderer/core/css/style_engine.cc   |    8 +
 .../blink/renderer/core/css/style_engine.h    |    1 +
 .../renderer/core/dom/events/event_target.cc  |    5 +-
 .../renderer/core/exported/web_document.cc    |   13 +-
 .../blink/renderer/core/html/html_element.cc  |    8 +-
 .../definitions/adblock_private.d.ts          |   14 +
 126 files changed, 9347 insertions(+), 690 deletions(-)
 rename chrome/browser/adblock/android/java/res/xml/{adblock_preferences.xml => eyeo_adblock_preferences.xml} (59%)
 create mode 100644 chrome/browser/resources/settings/adblock_page/adblock_page.html
 create mode 100644 chrome/browser/resources/settings/adblock_page/adblock_page.ts
 create mode 100644 components/adblock/content/browser/adblock_blocking_page.cc
 create mode 100644 components/adblock/content/browser/adblock_blocking_page.h
 create mode 100644 components/adblock/core/converter/parser/test/test_rules.txt
 create mode 100644 components/adblock/core/resources/snippets/dist/dependencies.jst
 create mode 100644 components/adblock/core/resources/snippets/dist/isolated-first-all.source.jst
 create mode 100644 components/content_settings/core/browser/bromite_content_settings/ads.inc
 create mode 100644 cromite_flags/chrome/browser/about_flags_cc/Stricter-popup-blocker.inc

diff --git a/chrome/android/java/res/xml/main_preferences.xml b/chrome/android/java/res/xml/main_preferences.xml
--- a/chrome/android/java/res/xml/main_preferences.xml
+++ b/chrome/android/java/res/xml/main_preferences.xml
@@ -1,13 +1,4 @@
 <?xml version="1.0" encoding="utf-8"?>
-<!--
-Copyright 2015 The Chromium Authors
-Use of this source code is governed by a BSD-style license that can be
-found in the LICENSE file.
-
-This source code is a part of eyeo Chromium SDK.
-Use of this source code is governed by the GPLv3 that can be found in the components/adblock/LICENSE file.
--->
-
 <PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:app="http://schemas.android.com/apk/res-auto"
     android:orderingFromXml="false">
@@ -91,11 +82,6 @@ Use of this source code is governed by the GPLv3 that can be found in the compon
         android:key="autofill_options"
         android:order="16"
         android:title="@string/autofill_options_title" />
-    <Preference
-        android:fragment="org.chromium.chrome.browser.adblock.settings.AdblockSettingsFragment"
-        android:key="adblock"
-        android:order="17"
-        android:title="@string/adblock_settings_title" />
 
     <PreferenceCategory
         android:key="advanced_section"
@@ -122,6 +108,11 @@ Use of this source code is governed by the GPLv3 that can be found in the compon
         android:key="adblock"
         android:order="13"
         android:title="@string/prefs_adblock"/>
+    <Preference
+        android:fragment="org.chromium.chrome.browser.adblock.settings.AdblockSettingsFragment"
+        android:key="eyeo_adblock"
+        android:order="13"
+        android:title="@string/adblock_settings_title" />
     <Preference
         android:key="notifications"
         android:order="22"
diff --git a/chrome/browser/adblock/adblock_chrome_content_browser_client.cc b/chrome/browser/adblock/adblock_chrome_content_browser_client.cc
--- a/chrome/browser/adblock/adblock_chrome_content_browser_client.cc
+++ b/chrome/browser/adblock/adblock_chrome_content_browser_client.cc
@@ -25,3 +25,9 @@ AdblockChromeContentBrowserClient::GetBrowserContextForEyeoFactories(
   return Profile::FromBrowserContext(current_browser_context)
       ->GetOriginalProfile();
 }
+
+HostContentSettingsMap*
+AdblockChromeContentBrowserClient::GetHostContentSettingsMap(
+    content::BrowserContext* current_browser_context) {
+  return HostContentSettingsMapFactory::GetForProfile(current_browser_context);
+}
diff --git a/chrome/browser/adblock/adblock_chrome_content_browser_client.h b/chrome/browser/adblock/adblock_chrome_content_browser_client.h
--- a/chrome/browser/adblock/adblock_chrome_content_browser_client.h
+++ b/chrome/browser/adblock/adblock_chrome_content_browser_client.h
@@ -20,12 +20,16 @@
 
 #include "chrome/browser/chrome_content_browser_client.h"
 #include "components/adblock/content/browser/adblock_content_browser_client.h"
+#include "chrome/browser/content_settings/host_content_settings_map_factory.h"
+#include "components/content_settings/core/browser/host_content_settings_map.h"
 
 class AdblockChromeContentBrowserClient
     : public adblock::AdblockContentBrowserClient<ChromeContentBrowserClient> {
  private:
   content::BrowserContext* GetBrowserContextForEyeoFactories(
       content::BrowserContext* current_browser_context) override;
+  HostContentSettingsMap* GetHostContentSettingsMap(
+      content::BrowserContext* current_browser_context) override;
 };
 
 #endif  // CHROME_BROWSER_ADBLOCK_ADBLOCK_CHROME_CONTENT_BROWSER_CLIENT_H_
diff --git a/chrome/browser/adblock/android/BUILD.gn b/chrome/browser/adblock/android/BUILD.gn
--- a/chrome/browser/adblock/android/BUILD.gn
+++ b/chrome/browser/adblock/android/BUILD.gn
@@ -34,6 +34,7 @@ android_library("adblock_ui_java") {
     "//build/android:build_java",
     "//chrome/browser/preferences:java",
     "//chrome/browser/profiles/android:java",
+    "//chrome/browser/settings:java",
     "//components/adblock/android:adblock_controller_java",
     "//components/browser_ui/settings/android:java",
     "//components/prefs/android:java",
@@ -69,7 +70,7 @@ android_resources("java_ui_resources") {
     "java/res/layout/adblock_custom_item_settings.xml",
     "java/res/layout/adblock_filter_lists_list_item.xml",
     "java/res/xml/adblock_more_options.xml",
-    "java/res/xml/adblock_preferences.xml",
+    "java/res/xml/eyeo_adblock_preferences.xml",
   ]
 
   deps = [ ":adblock_strings_grd" ]
diff --git a/chrome/browser/adblock/android/adblock_strings.grd b/chrome/browser/adblock/android/adblock_strings.grd
--- a/chrome/browser/adblock/android/adblock_strings.grd
+++ b/chrome/browser/adblock/android/adblock_strings.grd
@@ -15,7 +15,7 @@
   You should have received a copy of the GNU General Public License
   along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
 -->
-<grit current_release="1" latest_public_release="0" output_all_resource_defines="false">
+<grit current_release="1" latest_public_release="0">
   <outputs>
     <output filename="values-af/adblock_strings.xml" lang="af" type="android" />
     <output filename="values-am/adblock_strings.xml" lang="am" type="android" />
@@ -186,10 +186,52 @@
   <release seq="1">
     <messages fallback_to_english="true">
       <message name="IDS_ADBLOCK_SETTINGS_TITLE" desc="Title of Adblock settings menu item [CHAR-LIMIT=12]">
-        Ad blocking
+        Adblock Plus settings
+      </message>
+      <message name="IDS_ADBLOCK_SETTINGS_ENABLE" desc="">
+        Enable Adblock Plus
+      </message>
+      <message name="IDS_FRAGMENT_ADBLOCK_SETTINGS_START_UPDATE" desc="">
+        Check for updates now
+      </message>
+      <message name="IDS_ADBLOCK_SETTINGS_PRIVILEGED_FILTERS_ENABLED" desc="">
+        Enable anti-circumvention and snippets
+      </message>
+      <message name="IDS_ADBLOCK_SETTINGS_PRIVILEGED_FILTERS_ENABLED_SUMMARY" desc="">
+        Snippets are pieces of JavaScript code, injected by the Adblock Plus, that execute within the context of a website and combat advanced ads that circumvent ordinary blocking.
+The functionality is ONLY allowed for the list
+https://www.cromite.org/filters/abp-filters-anti-cv.txt
+which is activated by this setting.
+      </message>
+      <message name="IDS_ADBLOCK_SETTINGS_OPEN_REPO_URL_TEXT" desc="">
+        Open ABP anti-circumvention filter list repo
+      </message>
+      <message name="IDS_ADBLOCK_SETTINGS_OPEN_REPO_URL_SUMMARY" desc="">
+        Open https://gitlab.com/eyeo/anti-cv/abp-filters-anti-cv in the browser
+      </message>
+      <message name="IDS_ADBLOCK_SETTINGS_OPEN_REPO_URL" desc="" translateable="false">
+        https://gitlab.com/eyeo/anti-cv/abp-filters-anti-cv
+      </message>
+      <message name="IDS_ADBLOCK_SETTINGS_OPEN_SNIPPETS_URL_TEXT" desc="">
+        Open ABP Snippets Overview
+      </message>
+      <message name="IDS_ADBLOCK_SETTINGS_OPEN_SNIPPETS_URL_SUMMARY" desc="">
+        Open https://developers.eyeo.com/snippets/snippets-overview in the browser
+      </message>
+      <message name="IDS_ADBLOCK_SETTINGS_OPEN_SNIPPETS_URL" desc="" translateable="false">
+        https://developers.eyeo.com/snippets/snippets-overview
+      </message>
+      <message name="IDS_FRAGMENT_ADBLOCK_SETTINGS_FILTER_LISTS_TITLE_COUNT" desc="Title of MultiSelectListPreference to choose filter lists">
+        Filter lists (<ph name="COUNT">%s</ph> selected)
+      </message>
+      <message name="IDS_FRAGMENT_ADBLOCK_MORE_OPTIONS_CUSTOM_FILTER_LISTS_TITLE_COUNT" desc="Title of the Preference and fragment for adding custom filter lists">
+        Custom ad filtering settings (<ph name="COUNT">%s</ph> selected)
+      </message>
+      <message name="IDS_FRAGMENT_ADBLOCK_MORE_OPTIONS_CUSTOM_FILTERS_TITLE_COUNT" desc="Title of the Preference and fragment for adding custom filters">
+        Custom Filters (<ph name="COUNT">%s</ph> selected)
       </message>
       <message name="IDS_FRAGMENT_ADBLOCK_SETTINGS_ENABLED_SUMMARY" desc="Summary of SwitchPreference to enable/disable Adblock">
-        Allow ad blocking on websites in this app
+        Block ads on websites
       </message>
       <message name="IDS_FRAGMENT_ADBLOCK_SETTINGS_FILTER_LISTS_TITLE" desc="Title of MultiSelectListPreference to choose filter lists">
         Filter lists
@@ -222,10 +264,10 @@
         More blocking options
       </message>
       <message name="IDS_FRAGMENT_ADBLOCK_MORE_OPTIONS_CUSTOM_FILTER_LISTS_TITLE" desc="Title of the Preference and fragment for adding custom filter lists">
-        Custom ad filtering settings
+        Custom ad filtering urls
       </message>
       <message name="IDS_FRAGMENT_ADBLOCK_MORE_OPTIONS_CUSTOM_FILTER_LISTS_SUMMARY" desc="Title of the Preference for adding custom filter lists">
-        Add custom filter lists
+        Add custom filter urls
       </message>
       <message name="IDS_FRAGMENT_ADBLOCK_MORE_OPTIONS_ADD_CUSTOM_FILTER_LIST" desc="Hint shown in a EditView for adding custom filter list URL">
         https://example.org/myFilterList.txt
@@ -234,10 +276,10 @@
         Custom Filters
       </message>
       <message name="IDS_FRAGMENT_ADBLOCK_MORE_OPTIONS_CUSTOM_FILTERS_SUMMARY" desc="Title of the Preference for adding custom filters">
-        Add custom filters
+        Add custom filters commands
       </message>
       <message name="IDS_FRAGMENT_ADBLOCK_MORE_OPTIONS_CUSTOM_FILTERS_HINT" desc="Hint shown in a EditView for adding custom filter">
-        Enter filter
+        Enter filter commands
       </message>
     </messages>
   </release>
diff --git a/chrome/browser/adblock/android/java/res/layout/adblock_custom_item.xml b/chrome/browser/adblock/android/java/res/layout/adblock_custom_item.xml
--- a/chrome/browser/adblock/android/java/res/layout/adblock_custom_item.xml
+++ b/chrome/browser/adblock/android/java/res/layout/adblock_custom_item.xml
@@ -25,14 +25,24 @@
     tools:ignore="UseCompoundDrawables">
 
     <!-- Domain/URL -->
-    <TextView
-        android:id="@+id/fragment_adblock_custom_item_title"
+   <LinearLayout
         android:layout_width="0dp"
         android:layout_weight="1"
         android:layout_height="wrap_content"
         android:paddingStart="0dp"
+        android:orientation="vertical">
+    <TextView
+        android:id="@+id/fragment_adblock_custom_item_title"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
         android:textAppearance="?android:attr/textAppearanceMedium"
         tools:text="http://www.google.com"/>
+    <TextView
+        android:id="@+id/fragment_adblock_custom_item_status"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:textAppearance="@style/TextAppearance.TextSmall.Secondary" />
+    </LinearLayout>
 
     <!-- Remove button
          UseCompoundDrawables added to parent element to suppress warning
diff --git a/chrome/browser/adblock/android/java/res/layout/adblock_filter_lists_list_item.xml b/chrome/browser/adblock/android/java/res/layout/adblock_filter_lists_list_item.xml
--- a/chrome/browser/adblock/android/java/res/layout/adblock_filter_lists_list_item.xml
+++ b/chrome/browser/adblock/android/java/res/layout/adblock_filter_lists_list_item.xml
@@ -28,9 +28,24 @@
         android:layout_height="wrap_content"
         android:layout_marginEnd="21dp"
         android:clickable="false" />
+      <LinearLayout
+          android:layout_width="match_parent"
+          android:layout_height="wrap_content"
+          android:orientation="vertical">
         <TextView
             android:id="@+id/name"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
             android:textAppearance="@style/TextAppearance.TextLarge.Primary" />
+        <TextView
+            android:id="@+id/url"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:textAppearance="@style/TextAppearance.TextSmall.Secondary" />
+        <TextView
+            android:id="@+id/status"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:textAppearance="@style/TextAppearance.TextSmall.Secondary" />
+      </LinearLayout>
 </LinearLayout>
diff --git a/chrome/browser/adblock/android/java/res/xml/adblock_preferences.xml b/chrome/browser/adblock/android/java/res/xml/eyeo_adblock_preferences.xml
similarity index 59%
rename from chrome/browser/adblock/android/java/res/xml/adblock_preferences.xml
rename to chrome/browser/adblock/android/java/res/xml/eyeo_adblock_preferences.xml
--- a/chrome/browser/adblock/android/java/res/xml/adblock_preferences.xml
+++ b/chrome/browser/adblock/android/java/res/xml/eyeo_adblock_preferences.xml
@@ -20,7 +20,7 @@
     <!-- Adblock: enabled/disabled -->
     <org.chromium.components.browser_ui.settings.ChromeSwitchPreference
         android:key="fragment_adblock_settings_enabled_key"
-        android:title="@string/adblock_settings_title"
+        android:title="@string/adblock_settings_enable"
         app:iconSpaceReserved="false"
         android:summary="@string/fragment_adblock_settings_enabled_summary" />
 
@@ -32,6 +32,43 @@
         app:iconSpaceReserved="false"
         android:summary="@string/fragment_adblock_settings_filter_lists_summary" />
 
+    <org.chromium.components.browser_ui.settings.ChromeSwitchPreference
+        android:key="fragment_adblock_privileged_filters_enabled_key"
+        android:title="@string/adblock_settings_privileged_filters_enabled"
+        app:iconSpaceReserved="false"
+        android:summary="@string/adblock_settings_privileged_filters_enabled_summary" />
+
+    <org.chromium.chrome.browser.about_settings.HyperlinkPreference
+        android:key="fragment_adblock_settings_open_repo_url"
+        android:title="@string/adblock_settings_open_repo_url_text"
+        app:url="@string/adblock_settings_open_repo_url"
+        android:summary="@string/adblock_settings_open_repo_url_summary" />
+
+    <org.chromium.chrome.browser.about_settings.HyperlinkPreference
+        android:key="fragment_adblock_settings_open_snippets_url"
+        android:title="@string/adblock_settings_open_snippets_url_text"
+        app:url="@string/adblock_settings_open_snippets_url"
+        android:summary="@string/adblock_settings_open_snippets_url_summary" />
+
+
+    <androidx.preference.Preference
+        android:fragment="org.chromium.chrome.browser.adblock.settings.AdblockCustomFilterListsFragment"
+        android:key="fragment_adblock_more_options_custom_filter_lists_key"
+        android:title="@string/fragment_adblock_more_options_custom_filter_lists_title"
+        app:iconSpaceReserved="false"
+        android:summary="@string/fragment_adblock_more_options_custom_filter_lists_summary" />
+
+    <androidx.preference.Preference
+        android:fragment="org.chromium.chrome.browser.adblock.settings.AdblockCustomFiltersFragment"
+        android:key="fragment_adblock_more_options_custom_filter_key"
+        android:title="@string/fragment_adblock_more_options_custom_filters_title"
+        app:iconSpaceReserved="false"
+        android:summary="@string/fragment_adblock_more_options_custom_filters_summary" />
+
+   <Preference
+        android:key="fragment_adblock_settings_start_update"
+        android:title="@string/fragment_adblock_settings_start_update"/>
+
     <!-- Acceptable Ads: enabled/disabled -->
     <org.chromium.components.browser_ui.settings.ChromeSwitchPreference
         android:key="fragment_adblock_settings_aa_enabled_key"
@@ -44,7 +81,8 @@
         android:key="fragment_adblock_settings_auto_install_enabled_key"
         android:title="@string/fragment_adblock_settings_auto_install_enabled_title"
         app:iconSpaceReserved="false"
-        android:summary="@string/fragment_adblock_settings_auto_install_enabled_summary" />
+        android:summary="@string/fragment_adblock_settings_auto_install_enabled_summary"
+        app:isPreferenceVisible="false" />
 
     <!-- Allowed domains -->
     <androidx.preference.Preference
diff --git a/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockAllowedDomainsFragment.java b/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockAllowedDomainsFragment.java
--- a/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockAllowedDomainsFragment.java
+++ b/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockAllowedDomainsFragment.java
@@ -25,7 +25,7 @@ import org.chromium.components.adblock.AdblockController;
 
 import java.util.List;
 
-public class AdblockAllowedDomainsFragment extends AdblockCustomItemFragment {
+public class AdblockAllowedDomainsFragment extends AdblockCustomItemFragment<String> {
     public AdblockAllowedDomainsFragment() {}
 
     @Override
@@ -34,6 +34,11 @@ public class AdblockAllowedDomainsFragment extends AdblockCustomItemFragment {
         getActivity().setTitle(R.string.fragment_adblock_settings_allowed_domains_title);
     }
 
+    @Override
+    protected String getItemText(String item) {
+        return item;
+    }
+
     @Override
     protected List<String> getItems() {
         return AdblockController.getInstance(ProfileManager.getLastUsedRegularProfile())
diff --git a/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockCustomFilterListsFragment.java b/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockCustomFilterListsFragment.java
--- a/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockCustomFilterListsFragment.java
+++ b/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockCustomFilterListsFragment.java
@@ -26,13 +26,14 @@ import android.widget.Toast;
 import org.chromium.chrome.browser.adblock.R;
 import org.chromium.chrome.browser.profiles.ProfileManager;
 import org.chromium.components.adblock.AdblockController;
+import org.chromium.components.adblock.AdblockController.Subscription;
 
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
 
-public class AdblockCustomFilterListsFragment extends AdblockCustomItemFragment {
+public class AdblockCustomFilterListsFragment extends AdblockCustomItemFragment<Subscription> {
     private static final String TAG = AdblockCustomFilterListsFragment.class.getSimpleName();
 
     public AdblockCustomFilterListsFragment() {}
@@ -44,29 +45,19 @@ public class AdblockCustomFilterListsFragment extends AdblockCustomItemFragment
     }
 
     @Override
-    protected List<String> getItems() {
-        final List<AdblockController.Subscription> installed =
-                AdblockController.getInstance(ProfileManager.getLastUsedRegularProfile())
-                        .getInstalledSubscriptions();
-        final List<AdblockController.Subscription> recommended =
-                AdblockController.getInstance(ProfileManager.getLastUsedRegularProfile())
-                        .getRecommendedSubscriptions();
-        final List<String> customStrings = new ArrayList<String>();
-        for (final AdblockController.Subscription subscription : installed) {
-            if (recommended.contains(subscription)) {
-                continue;
-            }
-            // FIXME(kzlomek): Remove this after DPD-1613
-            if (subscription
-                    .url()
-                    .toString()
-                    .equals("https://easylist-downloads.adblockplus.org/exceptionrules.txt")) {
-                continue;
-            }
-            customStrings.add(subscription.url().toString());
-        }
+    protected List<Subscription> getItems() {
+        return AdblockController.getInstance(ProfileManager.getLastUsedRegularProfile())
+            .getCustomSubscriptions();
+    }
+
+    @Override
+    protected String getItemText(Subscription item) {
+        return item.url().toString();
+    }
 
-        return customStrings;
+    @Override
+    protected String getItemStatus(Subscription item) {
+        return item.getDescription();
     }
 
     @Override
diff --git a/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockCustomFiltersFragment.java b/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockCustomFiltersFragment.java
--- a/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockCustomFiltersFragment.java
+++ b/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockCustomFiltersFragment.java
@@ -25,9 +25,14 @@ import org.chromium.components.adblock.AdblockController;
 
 import java.util.List;
 
-public class AdblockCustomFiltersFragment extends AdblockCustomItemFragment {
+public class AdblockCustomFiltersFragment extends AdblockCustomItemFragment<String>  {
     public AdblockCustomFiltersFragment() {}
 
+    @Override
+    protected String getItemText(String item) {
+        return item;
+    }
+
     @Override
     public void onActivityCreated(Bundle savedInstanceState) {
         super.onActivityCreated(savedInstanceState);
diff --git a/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockCustomItemFragment.java b/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockCustomItemFragment.java
--- a/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockCustomItemFragment.java
+++ b/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockCustomItemFragment.java
@@ -30,10 +30,11 @@ import android.widget.TextView;
 import androidx.preference.PreferenceFragmentCompat;
 
 import org.chromium.chrome.browser.adblock.R;
+import org.chromium.components.browser_ui.settings.SettingsFragment;
 
 import java.util.List;
 
-public abstract class AdblockCustomItemFragment extends PreferenceFragmentCompat {
+public abstract class AdblockCustomItemFragment<T> extends PreferenceFragmentCompat implements SettingsFragment {
     private EditText mItem;
     private ImageView mAddButton;
     private ListView mListView;
@@ -41,6 +42,11 @@ public abstract class AdblockCustomItemFragment extends PreferenceFragmentCompat
 
     public AdblockCustomItemFragment() {}
 
+    @Override
+    public @AnimationType int getAnimationType() {
+        return AnimationType.PROPERTY;
+    }
+
     @Override
     public View onCreateView(
             LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
@@ -75,7 +81,7 @@ public abstract class AdblockCustomItemFragment extends PreferenceFragmentCompat
 
     protected abstract void removeItemImpl(String item);
 
-    protected abstract List<String> getItems();
+    protected abstract List<T> getItems();
 
     protected abstract String getCustomItemTextViewText();
 
@@ -90,10 +96,12 @@ public abstract class AdblockCustomItemFragment extends PreferenceFragmentCompat
     // Holder for listview items
     private class Holder {
         TextView mItem;
+        TextView mStatus;
         ImageView mRemoveButton;
 
         Holder(View rootView) {
             mItem = rootView.findViewById(R.id.fragment_adblock_custom_item_title);
+            mStatus = rootView.findViewById(R.id.fragment_adblock_custom_item_status);
             mRemoveButton = rootView.findViewById(R.id.fragment_adblock_custom_item_remove);
             mRemoveButton.setContentDescription(
                     AdblockCustomItemFragment.this.getCustomItemRemoveButtonContentDescription());
@@ -107,6 +115,7 @@ public abstract class AdblockCustomItemFragment extends PreferenceFragmentCompat
                     String item = (String) v.getTag();
                     removeItemImpl(item);
                     mAdapter.notifyDataSetChanged();
+                    mItem.setText(item);
                 }
             };
 
@@ -134,16 +143,23 @@ public abstract class AdblockCustomItemFragment extends PreferenceFragmentCompat
                 convertView.setTag(new Holder(convertView));
             }
 
-            String item = (String) getItem(position);
+            T item = (T) getItem(position);
             Holder holder = (Holder) convertView.getTag();
-            holder.mItem.setText(item.toString());
+            holder.mItem.setText(getItemText(item));
+            holder.mStatus.setText(getItemStatus(item));
             holder.mRemoveButton.setOnClickListener(removeItemClickListener);
-            holder.mRemoveButton.setTag(item.toString());
+            holder.mRemoveButton.setTag(getItemText(item));
 
             return convertView;
         }
     }
 
+    protected abstract String getItemText(T item);
+
+    protected String getItemStatus(T item) {
+        return null;
+    }
+
     private void initControls() {
         mAddButton.setOnClickListener(
                 new View.OnClickListener() {
diff --git a/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockFilterListsAdapter.java b/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockFilterListsAdapter.java
--- a/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockFilterListsAdapter.java
+++ b/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockFilterListsAdapter.java
@@ -79,10 +79,13 @@ public class AdblockFilterListsAdapter extends BaseAdapter implements OnClickLis
                 mController.getInstalledSubscriptions();
         boolean subscribed = false;
         boolean autoinstalled = false;
+        TextView status = view.findViewById(R.id.status);
+        status.setText("");
         for (final AdblockController.Subscription subscription : subscriptions) {
             if (subscription.url().equals(item.url())) {
                 subscribed = true;
                 autoinstalled = subscription.autoinstalled();
+                status.setText(subscription.getDescription());
                 break;
             }
         }
@@ -93,6 +96,9 @@ public class AdblockFilterListsAdapter extends BaseAdapter implements OnClickLis
         TextView description = view.findViewById(R.id.name);
         description.setText(item.title());
         description.setContentDescription(item.title() + "filer list item title text");
+
+        TextView url = view.findViewById(R.id.url);
+        url.setText(item.url().toString());
         return view;
     }
 
diff --git a/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockFilterListsFragment.java b/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockFilterListsFragment.java
--- a/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockFilterListsFragment.java
+++ b/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockFilterListsFragment.java
@@ -26,8 +26,9 @@ import androidx.fragment.app.ListFragment;
 import org.chromium.chrome.browser.adblock.R;
 import org.chromium.chrome.browser.profiles.ProfileManager;
 import org.chromium.components.adblock.AdblockController;
+import org.chromium.components.browser_ui.settings.SettingsFragment;
 
-public class AdblockFilterListsFragment extends ListFragment {
+public class AdblockFilterListsFragment extends ListFragment implements SettingsFragment {
     private AdblockFilterListsAdapter mFilterListsAdapter;
 
     @Override
@@ -54,4 +55,9 @@ public class AdblockFilterListsFragment extends ListFragment {
         super.onStart();
         mFilterListsAdapter.start();
     }
+
+    @Override
+    public @AnimationType int getAnimationType() {
+        return AnimationType.PROPERTY;
+    }
 }
diff --git a/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockSettingsFragment.java b/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockSettingsFragment.java
--- a/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockSettingsFragment.java
+++ b/chrome/browser/adblock/android/java/src/org/chromium/chrome/browser/adblock/settings/AdblockSettingsFragment.java
@@ -13,27 +13,46 @@
 package org.chromium.chrome.browser.adblock.settings;
 
 import android.os.Bundle;
+import android.widget.Toast;
 
 import androidx.preference.Preference;
 import androidx.preference.PreferenceFragmentCompat;
 
+import org.chromium.base.supplier.ObservableSupplier;
+import org.chromium.base.supplier.ObservableSupplierImpl;
+
 import org.chromium.build.BuildConfig;
 import org.chromium.chrome.browser.adblock.R;
 import org.chromium.chrome.browser.preferences.Pref;
+import org.chromium.chrome.browser.profiles.Profile;
 import org.chromium.chrome.browser.profiles.ProfileManager;
+import org.chromium.chrome.browser.settings.ChromeBaseSettingsFragment;
 import org.chromium.components.adblock.AdblockController;
 import org.chromium.components.browser_ui.settings.ChromeSwitchPreference;
+import org.chromium.components.browser_ui.settings.SettingsFragment;
 import org.chromium.components.user_prefs.UserPrefs;
 
-public class AdblockSettingsFragment extends PreferenceFragmentCompat
-        implements Preference.OnPreferenceChangeListener {
+public class AdblockSettingsFragment
+        extends ChromeBaseSettingsFragment implements Preference.OnPreferenceChangeListener {
     private ChromeSwitchPreference mAdblockEnabled;
     private ChromeSwitchPreference mAcceptableAdsEnabled;
     private ChromeSwitchPreference mAutoInstalledEnabled;
     private Preference mFilterLists;
     private Preference mAllowedDomains;
     private Preference mMoreOptions;
-
+    private Preference mStartUpdate;
+    private ChromeSwitchPreference mPrivilegedFilters;
+
+    private static final String START_UPDATE_KEY =
+        "fragment_adblock_settings_start_update";
+    private static final String PRIVILEGED_FILTERS_KEY =
+        "fragment_adblock_privileged_filters_enabled_key";
+    private static final String FILTER_LISTS_KEY =
+        "fragment_adblock_settings_filter_lists_key";
+    private static final String CUSTOM_FILTER_LISTS_KEY =
+        "fragment_adblock_more_options_custom_filter_lists_key";
+    private static final String CUSTOM_FILTER_KEY =
+        "fragment_adblock_more_options_custom_filter_key";
     private static final String SETTINGS_ENABLED_KEY = "fragment_adblock_settings_enabled_key";
     private static final String SETTINGS_FILTER_LISTS_KEY =
             "fragment_adblock_settings_filter_lists_key";
@@ -51,10 +70,34 @@ public class AdblockSettingsFragment extends PreferenceFragmentCompat
     private static final int ON_OFF_TOGGLE_COUNT_TIME_WINDOW_MS = 3000;
     private long mOnOffTogleTimestamp;
 
+    private final ObservableSupplierImpl<String> mPageTitle = new ObservableSupplierImpl<>();
+
+    @Override
+    public @SettingsFragment.AnimationType int getAnimationType() {
+        return SettingsFragment.AnimationType.PROPERTY;
+    }
+
+    @Override
+    public ObservableSupplier<String> getPageTitle() {
+        return mPageTitle;
+    }
+
     private void bindPreferences() {
+        mStartUpdate = findPreference(START_UPDATE_KEY);
+        mStartUpdate.setOnPreferenceClickListener(preference -> {
+            AdblockController.getInstance(
+                ProfileManager.getLastUsedRegularProfile()).startUpdate();
+            Toast toast = Toast.makeText(getContext(),
+                "Checking for updates in progress", Toast.LENGTH_LONG);
+            toast.show();
+            // handle the click so the default action isn't triggered.
+            return true;
+        });
+        mPrivilegedFilters = (ChromeSwitchPreference) findPreference(PRIVILEGED_FILTERS_KEY);
         mAdblockEnabled = (ChromeSwitchPreference) findPreference(SETTINGS_ENABLED_KEY);
         mFilterLists = findPreference(SETTINGS_FILTER_LISTS_KEY);
         mAcceptableAdsEnabled = (ChromeSwitchPreference) findPreference(SETTINGS_AA_ENABLED_KEY);
+        mAcceptableAdsEnabled.setVisible(false);
         mAutoInstalledEnabled =
                 (ChromeSwitchPreference) findPreference(SETTINGS_AUTO_INSTALL_ENABLED_KEY);
         mAllowedDomains = findPreference(SETTINGS_ALLOWED_DOMAINS_KEY);
@@ -62,35 +105,43 @@ public class AdblockSettingsFragment extends PreferenceFragmentCompat
     }
 
     private boolean areMoreOptionsEnabled() {
-        return UserPrefs.get(ProfileManager.getLastUsedRegularProfile())
-                .getBoolean(Pref.ADBLOCK_MORE_OPTIONS_ENABLED);
+        return false;
     }
 
     private void applyAdblockEnabled(boolean enabledValue) {
-        mFilterLists.setEnabled(enabledValue);
-        mAcceptableAdsEnabled.setEnabled(enabledValue);
+        mStartUpdate.setEnabled(enabledValue);
         mAutoInstalledEnabled.setEnabled(enabledValue);
+        mPrivilegedFilters.setEnabled(enabledValue);
         mAllowedDomains.setEnabled(enabledValue);
         mMoreOptions.setEnabled(enabledValue);
         mMoreOptions.setVisible(areMoreOptionsEnabled());
     }
 
     private void synchronizePreferences() {
-        boolean enabled =
-                AdblockController.getInstance(ProfileManager.getLastUsedRegularProfile())
-                        .isEnabled();
+        AdblockController controller =
+            AdblockController.getInstance(ProfileManager.getLastUsedRegularProfile());
+
+        findPreference(FILTER_LISTS_KEY).setTitle(
+            getContext().getString(R.string.fragment_adblock_settings_filter_lists_title_count,
+                controller.getInstalledSubscriptions().size()));
+        findPreference(CUSTOM_FILTER_LISTS_KEY).setTitle(
+            getContext().getString(R.string.fragment_adblock_more_options_custom_filter_lists_title_count,
+                controller.getCustomSubscriptions().size()));
+        findPreference(CUSTOM_FILTER_KEY).setTitle(
+            getContext().getString(R.string.fragment_adblock_more_options_custom_filters_title_count,
+                controller.getCustomFilters().size()));
+        mPrivilegedFilters.setChecked(controller.isPrivilegedFiltersEnabled());
+        mPrivilegedFilters.setOnPreferenceChangeListener(this);
+        boolean enabled = controller.isEnabled();
         mAdblockEnabled.setChecked(enabled);
         mAdblockEnabled.setOnPreferenceChangeListener(this);
         applyAdblockEnabled(enabled);
 
-        mAcceptableAdsEnabled.setChecked(
-                AdblockController.getInstance(ProfileManager.getLastUsedRegularProfile())
-                        .isAcceptableAdsEnabled());
+        mAcceptableAdsEnabled.setChecked(controller.isAcceptableAdsEnabled());
         mAcceptableAdsEnabled.setOnPreferenceChangeListener(this);
 
         mAutoInstalledEnabled.setChecked(
-                AdblockController.getInstance(ProfileManager.getLastUsedRegularProfile())
-                        .isAutoInstallEnabled());
+                controller.isAutoInstallEnabled());
         mAutoInstalledEnabled.setOnPreferenceChangeListener(this);
     }
 
@@ -122,7 +173,7 @@ public class AdblockSettingsFragment extends PreferenceFragmentCompat
 
     @Override
     public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
-        addPreferencesFromResource(R.xml.adblock_preferences);
+        addPreferencesFromResource(R.xml.eyeo_adblock_preferences);
         bindPreferences();
         synchronizePreferences();
     }
@@ -137,19 +188,16 @@ public class AdblockSettingsFragment extends PreferenceFragmentCompat
     public boolean onPreferenceChange(Preference preference, Object newValue) {
         if (preference.getKey().equals(SETTINGS_ENABLED_KEY)) {
             AdblockController.getInstance(ProfileManager.getLastUsedRegularProfile())
-                    .setEnabled((Boolean) newValue);
+                .setEnabled(
+                    (Boolean) newValue);
 
             maybeEnableMoreOptions();
 
             applyAdblockEnabled((Boolean) newValue);
-        } else if (preference.getKey().equals(SETTINGS_AA_ENABLED_KEY)) {
-            AdblockController.getInstance(ProfileManager.getLastUsedRegularProfile())
-                    .setAcceptableAdsEnabled((Boolean) newValue);
-        } else {
-            assert preference.getKey().equals(SETTINGS_AUTO_INSTALL_ENABLED_KEY);
-
+        } else if (preference.getKey().equals(PRIVILEGED_FILTERS_KEY)) {
             AdblockController.getInstance(ProfileManager.getLastUsedRegularProfile())
-                    .setAutoInstallEnabled((Boolean) newValue);
+                .setPrivilegedFiltersEnabled(
+                    (Boolean) newValue);
         }
         return true;
     }
diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -6464,7 +6464,9 @@ ChromeContentBrowserClient::
 }
 
 bool ChromeContentBrowserClient::WillInterceptWebSocket(
-    content::RenderFrameHost* frame) {
+    content::RenderFrameHost* frame,
+    content::RenderProcessHost* process,
+    const url::Origin& origin) {
 #if BUILDFLAG(ENABLE_EXTENSIONS_CORE)
   if (!frame) {
     return false;
@@ -6487,9 +6489,11 @@ bool ChromeContentBrowserClient::WillInterceptWebSocket(
 }
 
 void ChromeContentBrowserClient::CreateWebSocket(
+    content::RenderProcessHost* process,
     content::RenderFrameHost* frame,
     WebSocketFactory factory,
     const GURL& url,
+    const url::Origin& initiator_origin,
     const net::SiteForCookies& site_for_cookies,
     const std::optional<std::string>& user_agent,
     mojo::PendingRemote<network::mojom::WebSocketHandshakeClient>
diff --git a/chrome/browser/chrome_content_browser_client.h b/chrome/browser/chrome_content_browser_client.h
--- a/chrome/browser/chrome_content_browser_client.h
+++ b/chrome/browser/chrome_content_browser_client.h
@@ -727,11 +727,15 @@ class ChromeContentBrowserClient : public content::ContentBrowserClient {
   CreateURLLoaderHandlerForServiceWorkerNavigationPreload(
       content::FrameTreeNodeId frame_tree_node_id,
       const network::ResourceRequest& resource_request) override;
-  bool WillInterceptWebSocket(content::RenderFrameHost* frame) override;
+  bool WillInterceptWebSocket(content::RenderFrameHost* frame,
+                              content::RenderProcessHost* process,
+                              const url::Origin& origin) override;
   void CreateWebSocket(
+      content::RenderProcessHost* process,
       content::RenderFrameHost* frame,
       WebSocketFactory factory,
       const GURL& url,
+      const url::Origin& initiator_origin,
       const net::SiteForCookies& site_for_cookies,
       const std::optional<std::string>& user_agent,
       mojo::PendingRemote<network::mojom::WebSocketHandshakeClient>
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_api.cc b/chrome/browser/extensions/api/adblock_private/adblock_private_api.cc
--- a/chrome/browser/extensions/api/adblock_private/adblock_private_api.cc
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_api.cc
@@ -17,6 +17,7 @@
 
 #include "base/containers/flat_map.h"
 #include "base/i18n/time_formatting.h"
+#include "base/strings/utf_string_conversions.h"
 #include "base/logging.h"
 #include "base/no_destructor.h"
 #include "base/values.h"
@@ -94,27 +95,12 @@ std::vector<api::adblock_private::SessionStatsEntry> CopySessionsStats(
   return result;
 }
 
-std::string SubscriptionInstallationStateToString(
-    adblock::Subscription::InstallationState state) {
-  using State = adblock::Subscription::InstallationState;
-  switch (state) {
-    case State::Installed:
-      return "Installed";
-    case State::AutoInstalled:
-      return "AutoInstalled";
-    case State::Preloaded:
-      return "Preloaded";
-    case State::Installing:
-      return "Installing";
-    case State::Unknown:
-      return "Unknown";
-  }
-  return "";
-}
-
 std::vector<api::adblock_private::Subscription> CopySubscriptions(
+    raw_ptr<adblock::SubscriptionService> subscription_service,
     const std::vector<scoped_refptr<adblock::Subscription>>
         current_subscriptions) {
+  raw_ptr<adblock::SubscriptionPersistentMetadata> metadata =
+      subscription_service->GetMetadata();
   std::vector<api::adblock_private::Subscription> result;
   for (auto& sub : current_subscriptions) {
     api::adblock_private::Subscription js_sub;
@@ -122,12 +108,13 @@ std::vector<api::adblock_private::Subscription> CopySubscriptions(
     js_sub.title = sub->GetTitle();
     js_sub.current_version = sub->GetCurrentVersion();
     js_sub.installation_state =
-        SubscriptionInstallationStateToString(sub->GetInstallationState());
-    const auto installation_time = sub->GetInstallationTime();
+        adblock::Subscription::SubscriptionInstallationStateToString(sub->GetInstallationState());
     js_sub.last_installation_time =
-        installation_time.is_null()
-            ? ""
-            : base::TimeFormatAsIso8601(sub->GetInstallationTime());
+        base::UTF16ToUTF8(base::TimeFormatFriendlyDateAndTime(sub->GetInstallationTime()));
+    if (metadata) {
+      js_sub.download_success_count = metadata->GetDownloadSuccessCount(sub->GetSourceUrl());
+      js_sub.download_error_count = metadata->GetDownloadErrorCount(sub->GetSourceUrl());
+    }
     result.emplace_back(std::move(js_sub));
   }
   return result;
@@ -367,6 +354,47 @@ void AdblockPrivateAPI::OnListenerAdded(
 
 namespace api {
 
+AdblockPrivateStartUpdateFunction::AdblockPrivateStartUpdateFunction() {}
+
+AdblockPrivateStartUpdateFunction::~AdblockPrivateStartUpdateFunction() {}
+
+ExtensionFunction::ResponseAction AdblockPrivateStartUpdateFunction::Run() {
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          browser_context());
+  subscription_service->StartUpdate();
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateSetPrivilegedFiltersEnabledFunction::AdblockPrivateSetPrivilegedFiltersEnabledFunction() {}
+
+AdblockPrivateSetPrivilegedFiltersEnabledFunction::~AdblockPrivateSetPrivilegedFiltersEnabledFunction() {}
+
+ExtensionFunction::ResponseAction AdblockPrivateSetPrivilegedFiltersEnabledFunction::Run() {
+  std::optional<api::adblock_private::SetEnabled::Params> params =
+      api::adblock_private::SetEnabled::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          browser_context());
+  subscription_service->SetPrivilegedFiltersEnabled(params->enabled);
+  return RespondNow(NoArguments());
+}
+
+AdblockPrivateIsPrivilegedFiltersEnabledFunction::AdblockPrivateIsPrivilegedFiltersEnabledFunction() {}
+
+AdblockPrivateIsPrivilegedFiltersEnabledFunction::~AdblockPrivateIsPrivilegedFiltersEnabledFunction() {}
+
+ExtensionFunction::ResponseAction AdblockPrivateIsPrivilegedFiltersEnabledFunction::Run() {
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          browser_context());
+  return RespondNow(
+      ArgumentList(api::adblock_private::IsEnabled::Results::Create(
+          subscription_service->IsPrivilegedFiltersEnabled())));
+}
+
 AdblockPrivateSetEnabledFunction::AdblockPrivateSetEnabledFunction() {}
 
 AdblockPrivateSetEnabledFunction::~AdblockPrivateSetEnabledFunction() {}
@@ -555,7 +583,7 @@ AdblockPrivateGetInstalledSubscriptionsFunction::Run() {
       GetAdblockConfiguration(GetOriginalBrowserContext(browser_context()));
   return RespondNow(ArgumentList(
       api::adblock_private::GetInstalledSubscriptions::Results::Create(
-          CopySubscriptions(subscription_service->GetCurrentSubscriptions(
+          CopySubscriptions(subscription_service, subscription_service->GetCurrentSubscriptions(
               adblock_configuration)))));
 }
 
diff --git a/chrome/browser/extensions/api/adblock_private/adblock_private_api.h b/chrome/browser/extensions/api/adblock_private/adblock_private_api.h
--- a/chrome/browser/extensions/api/adblock_private/adblock_private_api.h
+++ b/chrome/browser/extensions/api/adblock_private/adblock_private_api.h
@@ -58,6 +58,55 @@ void BrowserContextKeyedAPIFactory<
 
 namespace api {
 
+class AdblockPrivateStartUpdateFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.startUpdate", UNKNOWN)
+  AdblockPrivateStartUpdateFunction();
+
+ private:
+  ~AdblockPrivateStartUpdateFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateStartUpdateFunction(const AdblockPrivateStartUpdateFunction&) =
+      delete;
+  AdblockPrivateStartUpdateFunction& operator=(
+      const AdblockPrivateStartUpdateFunction&) = delete;
+};
+
+
+class AdblockPrivateSetPrivilegedFiltersEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.setPrivilegedFiltersEnabled", UNKNOWN)
+  AdblockPrivateSetPrivilegedFiltersEnabledFunction();
+
+ private:
+  ~AdblockPrivateSetPrivilegedFiltersEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateSetPrivilegedFiltersEnabledFunction(const AdblockPrivateSetPrivilegedFiltersEnabledFunction&) =
+      delete;
+  AdblockPrivateSetPrivilegedFiltersEnabledFunction& operator=(
+      const AdblockPrivateSetPrivilegedFiltersEnabledFunction&) = delete;
+};
+
+class AdblockPrivateIsPrivilegedFiltersEnabledFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("adblockPrivate.isPrivilegedFiltersEnabled", UNKNOWN)
+  AdblockPrivateIsPrivilegedFiltersEnabledFunction();
+
+ private:
+  ~AdblockPrivateIsPrivilegedFiltersEnabledFunction() override;
+
+  ResponseAction Run() override;
+
+  AdblockPrivateIsPrivilegedFiltersEnabledFunction(const AdblockPrivateIsPrivilegedFiltersEnabledFunction&) =
+      delete;
+  AdblockPrivateIsPrivilegedFiltersEnabledFunction& operator=(
+      const AdblockPrivateIsPrivilegedFiltersEnabledFunction&) = delete;
+};
+
 class AdblockPrivateSetEnabledFunction : public ExtensionFunction {
  public:
   DECLARE_EXTENSION_FUNCTION("adblockPrivate.setEnabled", UNKNOWN)
diff --git a/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.cc b/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.cc
--- a/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.cc
+++ b/chrome/browser/extensions/api/eyeo_filtering_private/eyeo_filtering_private_api.cc
@@ -17,8 +17,10 @@
 
 #include "base/containers/flat_map.h"
 #include "base/i18n/time_formatting.h"
+#include "base/strings/utf_string_conversions.h"
 #include "base/logging.h"
 #include "base/no_destructor.h"
+#include "base/strings/stringprintf.h"
 #include "base/values.h"
 #include "chrome/browser/extensions/extension_tab_util.h"
 #include "chrome/browser/profiles/profile.h"
@@ -30,6 +32,7 @@
 #include "components/adblock/core/common/adblock_prefs.h"
 #include "components/adblock/core/common/adblock_utils.h"
 #include "components/adblock/core/common/content_type.h"
+#include "components/adblock/core/subscription/subscription.h"
 #include "components/adblock/core/configuration/filtering_configuration.h"
 #include "components/adblock/core/configuration/persistent_filtering_configuration.h"
 #include "components/adblock/core/session_stats.h"
@@ -95,24 +98,6 @@ std::vector<api::eyeo_filtering_private::SessionStatsEntry> CopySessionsStats(
   return result;
 }
 
-std::string SubscriptionInstallationStateToString(
-    adblock::Subscription::InstallationState state) {
-  using State = adblock::Subscription::InstallationState;
-  switch (state) {
-    case State::Installed:
-      return "Installed";
-    case State::AutoInstalled:
-      return "AutoInstalled";
-    case State::Preloaded:
-      return "Preloaded";
-    case State::Installing:
-      return "Installing";
-    case State::Unknown:
-      return "Unknown";
-  }
-  return "";
-}
-
 std::vector<api::eyeo_filtering_private::Subscription> CopySubscriptions(
     const std::vector<scoped_refptr<adblock::Subscription>>
         current_subscriptions) {
@@ -123,12 +108,12 @@ std::vector<api::eyeo_filtering_private::Subscription> CopySubscriptions(
     js_sub.title = sub->GetTitle();
     js_sub.current_version = sub->GetCurrentVersion();
     js_sub.installation_state =
-        SubscriptionInstallationStateToString(sub->GetInstallationState());
+        adblock::Subscription::SubscriptionInstallationStateToString(sub->GetInstallationState());
     const auto installation_time = sub->GetInstallationTime();
     js_sub.last_installation_time =
         installation_time.is_null()
             ? ""
-            : base::TimeFormatAsIso8601(sub->GetInstallationTime());
+            : base::UTF16ToUTF8(base::TimeFormatFriendlyDateAndTime(sub->GetInstallationTime()));
     result.emplace_back(std::move(js_sub));
   }
   return result;
diff --git a/chrome/browser/extensions/api/settings_private/prefs_util.cc b/chrome/browser/extensions/api/settings_private/prefs_util.cc
--- a/chrome/browser/extensions/api/settings_private/prefs_util.cc
+++ b/chrome/browser/extensions/api/settings_private/prefs_util.cc
@@ -36,6 +36,7 @@
 #include "chrome/common/chrome_features.h"
 #include "chrome/common/extensions/api/settings_private.h"
 #include "chrome/common/pref_names.h"
+#include "components/adblock/core/common/adblock_prefs.h"
 #include "components/autofill/core/common/autofill_prefs.h"
 #include "components/bookmarks/common/bookmark_pref_names.h"
 #include "components/browsing_data/core/pref_names.h"
@@ -182,6 +183,19 @@ const PrefsUtil::TypedPrefMap& PrefsUtil::GetAllowlistedKeys() {
   }
   s_allowlist = new PrefsUtil::TypedPrefMap();
 
+  // Adblock settings
+  (*s_allowlist)[adblock::common::prefs::kEnableAdblockLegacy] =
+      settings_api::PrefType::kBoolean;
+  (*s_allowlist)[adblock::common::prefs::kEnableAcceptableAdsLegacy] =
+      settings_api::PrefType::kBoolean;
+  (*s_allowlist)[adblock::common::prefs::kAdblockSubscriptionsLegacy] =
+      settings_api::PrefType::kList;
+  (*s_allowlist)[adblock::common::prefs::kAdblockCustomSubscriptionsLegacy] =
+      settings_api::PrefType::kList;
+  (*s_allowlist)[adblock::common::prefs::kAdblockAllowedDomainsLegacy] =
+      settings_api::PrefType::kList;
+  (*s_allowlist)[adblock::common::prefs::kAdblockCustomFiltersLegacy] =
+      settings_api::PrefType::kList;
   // Miscellaneous
   (*s_allowlist)[::embedder_support::kAlternateErrorPagesEnabled] =
       settings_api::PrefType::kBoolean;
diff --git a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
@@ -255,7 +255,6 @@
 #include "chrome/common/buildflags.h"
 #include "chrome/common/chrome_features.h"
 #include "components/adblock/content/browser/factories/adblock_request_throttle_factory.h"
-#include "components/adblock/content/browser/factories/adblock_telemetry_service_factory.h"
 #include "components/adblock/content/browser/factories/content_security_policy_injector_factory.h"
 #include "components/adblock/content/browser/factories/element_hider_factory.h"
 #include "components/adblock/content/browser/factories/resource_classification_runner_factory.h"
@@ -953,7 +952,6 @@ void ChromeBrowserMainExtraPartsProfiles::
   // Makes manual testing possible.
   FakeSmartCardDeviceServiceFactory::GetInstance();
 #endif
-  adblock::AdblockTelemetryServiceFactory::GetInstance();
   adblock::AdblockRequestThrottleFactory::GetInstance();
   adblock::ContentSecurityPolicyInjectorFactory::GetInstance();
   adblock::ElementHiderFactory::GetInstance();
diff --git a/chrome/browser/resources/settings/BUILD.gn b/chrome/browser/resources/settings/BUILD.gn
--- a/chrome/browser/resources/settings/BUILD.gn
+++ b/chrome/browser/resources/settings/BUILD.gn
@@ -68,6 +68,7 @@ build_webui("build") {
     "ai_page/ai_tab_organization_subpage.ts",
     "ai_page/history_search_page.ts",
     "ai_page/offer_writing_help_page.ts",
+    "adblock_page/adblock_page.ts",
     "appearance_page/appearance_fonts_page.ts",
     "appearance_page/appearance_page_index.ts",
     "appearance_page/appearance_page.ts",
@@ -446,6 +447,7 @@ build_webui("build") {
   ts_definitions = [
     "//tools/typescript/definitions/autofill_private.d.ts",
     "//tools/typescript/definitions/chrome_event.d.ts",
+    "//tools/typescript/definitions/adblock_private.d.ts",
     "//tools/typescript/definitions/chrome_send.d.ts",
     "//tools/typescript/definitions/language_settings_private.d.ts",
     "//tools/typescript/definitions/management.d.ts",
diff --git a/chrome/browser/resources/settings/adblock_page/adblock_page.html b/chrome/browser/resources/settings/adblock_page/adblock_page.html
new file mode 100644
--- /dev/null
+++ b/chrome/browser/resources/settings/adblock_page/adblock_page.html
@@ -0,0 +1,218 @@
+<!--
+    This file is part of Bromite.
+
+    Bromite is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Bromite is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Bromite. If not, see <https://www.gnu.org/licenses/>.
+-->
+<style include="settings-shared cr-shared-style">
+    #languagesCollapse .list-item.selected {
+        min-height: var(--settings-row-two-line-min-height);
+    }
+    .ad-fixed-width {
+        width: 80%;
+        text-overflow: ellipsis;
+        word-wrap: break-word;
+    }
+    settings-section[section="adblock"] {
+        width: 680px;
+        margin: auto;
+    }
+</style>
+
+<settings-section page-title="Adblock" section="adblock">
+    <settings-toggle-button class="hr" pref="{{prefs.adblock.enabled}}"
+                            on-change="onAdblockEnabled_"
+                            label="Enable Adblock Plus" data-qa="adblock-toogle"
+                            sub-label-icon="[[additionalMessageIcon]]"
+                            sub-label="[[additionalMessage]]">
+    </settings-toggle-button>
+
+    <div hidden$="[[!prefs.adblock.enabled.value]]">
+
+        <div class="cr-row first">
+            <div class="flex cr-padded-text">
+                <div>Enable anti-circumvention and snippets</div>
+                <div class="cr-secondary-text">
+                    Snippets are pieces of JavaScript code, injected by the Adblock Plus, that execute within the context of a website and combat advanced ads that circumvent ordinary blocking.
+                    The functionality is ONLY allowed for the list
+                    <a href="https://www.cromite.org/filters/abp-filters-anti-cv.txt">abp-filters-anti-cv.txt</a>
+                    which is activated by this setting.
+                    <br><a href="https://gitlab.com/eyeo/anti-cv/abp-filters-anti-cv">Open ABP anti-circumvention filter list repo</a>
+                    <br><a href="https://developers.eyeo.com/snippets/snippets-overview">Open ABP Snippets Overview</a>
+                </div>
+            </div>
+            <div class="separator"></div>
+            <cr-toggle id="enablePrivilegedFiltersToggle"
+                    checked="[[isEnablePrivilegedFiltersToggle_]]"
+                    on-change="onEnablePrivilegedFiltersToggle_">
+            </cr-toggle>
+        </div>
+
+        <div class="cr-row first">
+            <div class="flex cr-padded-text">
+            </div>
+            <cr-button class="button" on-click="startUpdateCycle">
+                Check for updates now
+            </cr-button>
+        </div>
+
+        <div style="border-top: 1px solid silver">
+            <cr-expand-button class="cr-row first" expanded="{{recommendedSubscriptions}}" data-qa="recommended-subscriptions-menu-item">
+                <div>
+                    <div>Built in Subscriptions ([[countEnabled]] selected)</div>
+                    <div class="cr-secondary-text">
+                        Add the languages in which you regularly browse websites in
+                    </div>
+                </div>
+            </cr-expand-button>
+            <cr-collapse opened="{{recommendedSubscriptions}}">
+                <div class="list-frame vertical-list">
+                    <template is="dom-repeat" items="[[subscriptions]]">
+                        <div class="list-item">
+                            <cr-checkbox id="[[item.url]]" no-set-pref on-change="selectRecommendedSubscription"
+                                checked="{{item.enabled}}">
+                            </cr-checkbox>
+                            <div class="start cr-padded-text">
+                                <div data-qa="recommended-subscription-list-item">
+                                    [[item.title]]
+                                </div>
+                                <div hidden="[[item.enabled]]">
+                                    <div><b>Download from:</b> [[item.url]]</div>
+                                </div>
+                                <div hidden="[[!item.enabled]]" style="margin-left: 20px; margin-top: 5px;">
+                                    <div><b>URL:</b> [[item.url]]</div>
+                                    <div><b>Version:</b> [[item.current_version]]</div>
+                                    <div><b>Status:</b> [[item.installation_state]] ([[item.last_installation_time]])</div>
+                                    <div><b>Download:</b> [[item.download_success_count]] <b>Errors:</b> [[item.download_error_count]]</div>
+                                </div>
+                            </div>
+                        </div>
+                    </template>
+                </div>
+            </cr-collapse>
+        </div>
+        <div>
+            <cr-expand-button class="cr-row first" expanded="{{allowedDomainsOpened}}" data-qa="allowed-domains-menu-item">
+                <div>
+                    Allowed Domains ([[allowedDomainsCount]] added)
+                </div>
+                <div class="cr-secondary-text">
+                    Support your favorite websites by adding them to this list. You might see ads on them.
+                </div>
+            </cr-expand-button>
+            <cr-collapse opened="{{allowedDomainsOpened}}">
+                <div class="list-frame vertical-list">
+                    <template is="dom-repeat" items="{{allowedDomains}}">
+                        <div class="list-item">
+                            <div class="start cr-padded-text">
+                                <div data-qa="allowed-domains-list-item">
+                                    [[item]]
+                                </div>
+                            </div>
+                            <cr-button class="button" id="[[item]]" on-click="removeAllowedDomain" data-qa="remove-allowed-domains-btn">
+                                Remove
+                            </cr-button>
+                        </div>
+                    </template>
+                    <div class="list-item">
+                        <div class="start cr-padded-text">
+                            <cr-input slot="inputs" value="{{allowedDomainInput}}" data-qa="allowed-domains-input">
+                                <cr-button slot="suffix" class="action-button" id="[[item]]" on-click="addAllowedDomain" data-qa="add-allowed-domains-btn">
+                                    Add
+                                </cr-button>
+                            </cr-input>
+                        </div>
+                    </div>
+                </div>
+            </cr-collapse>
+        </div>
+        <div>
+            <cr-expand-button class="cr-row first" expanded="{{customSubscriptionsOpened}}" data-qa="custom-subscriptions-menu-item">
+                <div>
+                    Custom Subscriptions ([[customSubscriptions.length]] added)
+                </div>
+                <div class="cr-secondary-text">
+                    Add custom filter urls
+                </div>
+            </cr-expand-button>
+            <cr-collapse opened="{{customSubscriptionsOpened}}">
+                <div class="list-frame vertical-list">
+                    <template is="dom-repeat" items="{{customSubscriptions}}">
+                        <div class="list-item">
+                            <div class="start cr-padded-text ad-fixed-width">
+                                <div data-qa="custom-subscriptions-list-item">
+                                    [[item.url]]
+                                    <div style="margin-left: 20px; margin-top: 5px;">
+                                        <div><b>Version:</b> [[item.current_version]]</div>
+                                        <div><b>Status:</b> [[item.installation_state]] ([[item.last_installation_time]])</div>
+                                        <div><b>Download:</b> [[item.download_success_count]] <b>Errors:</b> [[item.download_error_count]]</div>
+                                    </div>
+                                </div>
+                            </div>
+                            <cr-button class="button" id="[[item.url]]"
+                                    on-click="removeCustomSubscription" data-qa="remove-custom-subscriptions-btn">
+                                Remove
+                            </cr-button>
+                        </div>
+                    </template>
+                    <div class="list-item">
+                        <div class="start cr-padded-text">
+                            <cr-input slot="inputs" value="{{customSubscriptionInput}}" data-qa="custom-subscriptions-input">
+                                <cr-button slot="suffix" class="action-button" id="[[item]]" on-click="addCustomSubscription" data-qa="add-custom-subscription-btn">
+                                    Add
+                                </cr-button>
+                            </cr-input>
+                        </div>
+                    </div>
+                </div>
+            </cr-collapse>
+        </div>
+        <div>
+            <cr-expand-button class="cr-row first" expanded="{{customFiltersOpened}}" data-qa="custom-filters-menu-item">
+                <div>
+                    Custom Filters ([[customFilters.length]] added)
+                </div>
+                <div class="cr-secondary-text">
+                    Add custom filter commands
+                </div>
+            </cr-expand-button>
+            <cr-collapse opened="{{customFiltersOpened}}">
+                <div class="list-frame vertical-list">
+                    <template is="dom-repeat" items="{{customFilters}}">
+                        <div class="list-item">
+                            <div class="start cr-padded-text ad-fixed-width">
+                                <div data-qa="custom-filters-list-item">
+                                    [[item]]
+                                </div>
+                            </div>
+                            <cr-button class="button" id="[[item]]" on-click="removeCustomFilter" data-qa="remove-custom-filter-btn">
+                                Remove
+                            </cr-button>
+                        </div>
+                    </template>
+                    <div class="list-item">
+                        <div class="start cr-padded-text">
+                            <cr-input slot="inputs" value="{{customFilterInput}}" data-qa="custom-filter-input">
+                                <cr-button slot="suffix" class="action-button" id="[[item]]" on-click="addCustomFilter" data-qa="add-custom-filter-btn">
+                                    Add
+                                </cr-button>
+                            </cr-input>
+                        </div>
+                    </div>
+                </div>
+            </cr-collapse>
+        </div>
+
+    </div>
+    <cr-toast-manager></cr-toast-manager>
+</settings-section>
diff --git a/chrome/browser/resources/settings/adblock_page/adblock_page.ts b/chrome/browser/resources/settings/adblock_page/adblock_page.ts
new file mode 100644
--- /dev/null
+++ b/chrome/browser/resources/settings/adblock_page/adblock_page.ts
@@ -0,0 +1,319 @@
+/*
+    This file is part of Bromite.
+
+    Bromite is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Bromite is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Bromite. If not, see <https://www.gnu.org/licenses/>.
+*/
+import 'chrome://resources/polymer/v3_0/iron-flex-layout/iron-flex-layout-classes.js';
+import 'chrome://resources/polymer/v3_0/iron-icon/iron-icon.js';
+import 'chrome://resources/cr_elements/cr_button/cr_button.js';
+import 'chrome://resources/cr_elements/cr_shared_style.css.js';
+import 'chrome://resources/cr_elements/cr_collapse/cr_collapse.js';
+import 'chrome://resources/cr_elements/cr_toggle/cr_toggle.js';
+import 'chrome://resources/cr_elements/cr_expand_button/cr_expand_button.js';
+import 'chrome://resources/cr_elements/cr_checkbox/cr_checkbox.js';
+import 'chrome://resources/cr_elements/cr_input/cr_input.js';
+import 'chrome://resources/cr_elements/cr_toast/cr_toast_manager.js';
+import '../settings_shared.css.js';
+import '../settings_page/settings_section.js';
+import '../controls/settings_toggle_button.js';
+import '../controls/settings_dropdown_menu.js';
+
+import {I18nMixin} from 'chrome://resources/cr_elements/i18n_mixin.js';
+import {BaseMixin} from '../base_mixin.js';
+import {PolymerElement} from 'chrome://resources/polymer/v3_0/polymer/polymer_bundled.min.js';
+import {SettingsToggleButtonElement} from '../controls/settings_toggle_button.js';
+import {PrefsMixin} from '/shared/settings/prefs/prefs_mixin.js';
+import {CrCheckboxElement} from 'chrome://resources/cr_elements/cr_checkbox/cr_checkbox.js';
+import {getTemplate} from './adblock_page.html.js';
+import {getToastManager} from 'chrome://resources/cr_elements/cr_toast/cr_toast_manager.js';
+import {getSearchManager} from '../search_settings.js';
+import type {SettingsPlugin} from '../settings_main/settings_plugin.js';
+
+const SettingsAdblockPageElementBase =
+   I18nMixin(PrefsMixin(BaseMixin((PolymerElement))));
+
+interface Subscription {
+   url: string;
+   title: string;
+   enabled: boolean;
+   current_version: string;
+   download_error_count: number;
+   download_success_count: number;
+   installation_state: string;
+   last_installation_time: string;
+}
+
+export class SettingsAdblockPageElement extends SettingsAdblockPageElementBase
+                                        implements SettingsPlugin {
+   static get is() {
+      return 'settings-adblock-page';
+   }
+
+   static get template() {
+      return getTemplate();
+   }
+
+   static get properties() {
+      return {
+         customSubscriptionInput: String,
+         customFilterInput: String,
+         allowedDomainInput: String,
+         additionalMessage: String,
+         additionalMessageIcon: String,
+         countEnabled: Number,
+         allowedDomainsCount: Number,
+         isEnablePrivilegedFiltersToggle_: Boolean,
+         customSubscriptions: Array,
+         customFilters: Array,
+         allowedDomains: Array,
+         subscriptions: Array,
+      }
+   }
+
+   // input fields updated by html
+   declare private customSubscriptionInput: string;
+   declare private customFilterInput: string;
+   declare private allowedDomainInput: string;
+   declare private additionalMessage: string;
+   declare private additionalMessageIcon: string;
+   declare private countEnabled: number;
+   declare private allowedDomainsCount: number;
+   declare private isEnablePrivilegedFiltersToggle_: boolean;
+
+   // models that will fill templates lists in html
+   declare private customSubscriptions: Subscription[];
+   declare private customFilters: Array<string>;
+   declare private allowedDomains: Array<string>;
+   declare private subscriptions: Subscription[];
+
+   private syncSubscriptions() {
+      this.subscriptions = []
+      this.customSubscriptions = [];
+
+      chrome.adblockPrivate?.getBuiltInSubscriptions(list => {
+         chrome.adblockPrivate.getInstalledSubscriptions(activelist => {
+            let new_subscriptions: Subscription[] = [];
+            let custom_subscriptions: Subscription[] = [];
+
+            list.forEach(obj => {
+               new_subscriptions.push({
+                  title: obj.title,
+                  enabled: false,
+                  url: obj.url,
+                  current_version: '',
+                  download_error_count: 0,
+                  download_success_count: 0,
+                  installation_state: '',
+                  last_installation_time: ''
+               })
+            })
+
+            activelist.forEach(obj => {
+               var found = new_subscriptions.find(element => element.url == obj.url);
+               if (found === undefined) {
+                  found = {
+                     title: obj.title,
+                     enabled: false,
+                     url: obj.url,
+                     current_version: '',
+                     download_error_count: 0,
+                     download_success_count: 0,
+                     installation_state: '',
+                     last_installation_time: ''
+                  }
+                  custom_subscriptions.push(found)
+               }
+               found.enabled = true;
+               found.current_version = obj.current_version;
+               found.download_error_count = obj.download_error_count;
+               found.download_success_count = obj.download_success_count;
+               found.installation_state = obj.installation_state;
+               found.last_installation_time = obj.last_installation_time;
+            })
+
+            this.subscriptions = new_subscriptions;
+            this.customSubscriptions = custom_subscriptions;
+            this.updateUI();
+         })
+      });
+   }
+
+   private updateUI() {
+      this.additionalMessage = "";
+      this.additionalMessageIcon = "";
+      this.countEnabled = 0;
+
+      chrome.adblockPrivate?.isEnabled(enabled => {
+         if (!enabled) return;
+
+         let c = 0;
+         this.subscriptions.forEach(obj => {
+            if (obj.enabled) c++;
+         });
+         this.countEnabled = c;
+         if (this.countEnabled == 0 &&
+               this.customSubscriptions.length == 0 &&
+               this.customFilters.length == 0) {
+            this.additionalMessage = "No subscriptions selected. Adblock is not active.";
+            this.additionalMessageIcon = "cr:warning";
+         }
+      });
+
+      chrome.adblockPrivate?.isPrivilegedFiltersEnabled(enabled => {
+         this.isEnablePrivilegedFiltersToggle_ = enabled;
+      });
+   }
+
+   private syncCustomFilters() {
+      chrome.adblockPrivate?.getCustomFilters(domain => {
+         this.customFilters = [];
+         domain.forEach(value => {
+            this.customFilters.push(value);
+         })
+         this.updateUI();
+      });
+   }
+
+   private syncAllowedDomains() {
+      this.allowedDomainsCount = 0;
+      chrome.adblockPrivate?.getAllowedDomains(domain => {
+         this.allowedDomains = [];
+         domain.forEach(value => {
+            this.allowedDomains.push(value);
+         })
+         this.allowedDomainsCount = this.allowedDomains.length;
+         this.updateUI();
+      });
+   }
+
+   public override ready() {
+      super.ready();
+
+      this.syncSubscriptions();
+      this.syncCustomFilters();
+      this.syncAllowedDomains();
+   }
+
+   private onAdblockEnabled_(event: Event) {
+      if ((event.target as SettingsToggleButtonElement).checked) {
+        chrome.adblockPrivate.setEnabled(true);
+      } else {
+        chrome.adblockPrivate.setEnabled(false);
+      }
+      this.updateUI();
+   }
+
+   private onEnablePrivilegedFiltersToggle_(_evt: any, enabled: boolean) {
+      chrome.adblockPrivate.setPrivilegedFiltersEnabled(enabled);
+      this.syncSubscriptions();
+   }
+
+   private cleanUrl(url: string) : string {
+      let cleanedUrl : string = "";
+      try {
+         cleanedUrl = new URL(url).host;
+      } catch (err) {
+         try {
+            // one last try by adding schema
+            cleanedUrl = new URL("https://" + url).host;
+         }
+         catch (err) {
+            console.log("malformed url " + url);
+            return "";
+         }
+      }
+      return cleanedUrl;
+   }
+
+   private selectRecommendedSubscription(e: Event) {
+      const url = ((e.target as CrCheckboxElement).id);
+      const enabled = ((e.target as CrCheckboxElement).checked);
+      if (enabled) {
+         chrome.adblockPrivate.installSubscription(url);
+      } else {
+         chrome.adblockPrivate.uninstallSubscription(url);
+      }
+      this.updateUI();
+   }
+
+   private removeCustomFilter(e: Event) {
+      const filter = ((e.target as HTMLElement).id);
+      chrome.adblockPrivate.removeCustomFilter(filter);
+      const i = this.customFilters.indexOf(filter);
+      this.splice('customFilters', i, 1);
+      this.updateUI();
+   }
+
+   private addCustomFilter() {
+      if (this.customFilterInput == undefined || this.customFilterInput ==  "") return;
+      chrome.adblockPrivate.addCustomFilter(this.customFilterInput);
+      this.customFilterInput = "";
+      this.syncCustomFilters();
+   }
+
+   private removeAllowedDomain(e: Event) {
+      const allowedDomain = ((e.target as HTMLElement).id);
+      chrome.adblockPrivate.removeAllowedDomain(allowedDomain);
+      const i = this.allowedDomains.indexOf(allowedDomain);
+      this.splice('allowedDomains', i, 1);
+      this.allowedDomainsCount = this.allowedDomains.length;
+      this.updateUI();
+   }
+
+   private addAllowedDomain() {
+      if (this.allowedDomainInput == undefined || this.allowedDomainInput == "") return;
+      const cleanedUrl = this.cleanUrl(this.allowedDomainInput);
+      if (cleanedUrl == "") return;
+      chrome.adblockPrivate.addAllowedDomain(cleanedUrl);
+      this.allowedDomainInput = "";
+      this.syncAllowedDomains();
+   }
+
+   private removeCustomSubscription(e: Event) {
+      const url = ((e.target as HTMLElement).id);
+      const subscription = this.customSubscriptions.find( x => x.url = url);
+      chrome.adblockPrivate.uninstallSubscription(subscription!.url);
+      this.splice('customSubscriptions', this.customSubscriptions.indexOf(subscription!), 1);
+      this.updateUI();
+   }
+
+   private addCustomSubscription() {
+      if (this.customSubscriptionInput == undefined || this.customSubscriptionInput == "") return;
+      chrome.adblockPrivate.installSubscription(this.customSubscriptionInput);
+      this.customSubscriptionInput = "";
+      this.syncSubscriptions();
+   }
+
+   private startUpdateCycle() {
+      const toastManager = getToastManager();
+      chrome.adblockPrivate.startUpdate();
+      toastManager.duration = 5000;
+      toastManager.show("Starting update...");
+   }
+
+  // SettingsPlugin implementation
+  async searchContents(query: string) {
+    const searchRequest = await getSearchManager().search(query, this);
+    return searchRequest.getSearchResult();
+  }
+}
+
+declare global {
+   interface HTMLElementTagNameMap {
+      'settings-adblock-page': SettingsAdblockPageElement;
+   }
+}
+
+customElements.define(
+   SettingsAdblockPageElement.is, SettingsAdblockPageElement);
diff --git a/chrome/browser/resources/settings/page_visibility.ts b/chrome/browser/resources/settings/page_visibility.ts
--- a/chrome/browser/resources/settings/page_visibility.ts
+++ b/chrome/browser/resources/settings/page_visibility.ts
@@ -9,6 +9,7 @@ import {loadTimeData} from './i18n_setup.js';
  */
 export interface PageVisibility {
   a11y?: boolean;
+  adblock?: boolean;
   ai?: boolean;
   appearance?: boolean|AppearancePageVisibility;
   autofill?: boolean;
diff --git a/chrome/browser/resources/settings/route.ts b/chrome/browser/resources/settings/route.ts
--- a/chrome/browser/resources/settings/route.ts
+++ b/chrome/browser/resources/settings/route.ts
@@ -277,6 +277,10 @@ function createRoutes(): SettingsRoutes {
         '/onStartup', 'onStartup', loadTimeData.getString('onStartup'));
   }
 
+  if (visibility.adblock !== false) {
+    r.ADBLOCK = r.BASIC.createSection('/adblock', 'adblock');
+  }
+
   // Advanced Routes
   r.ADVANCED = new Route('/advanced');
 
diff --git a/chrome/browser/resources/settings/router.ts b/chrome/browser/resources/settings/router.ts
--- a/chrome/browser/resources/settings/router.ts
+++ b/chrome/browser/resources/settings/router.ts
@@ -13,6 +13,7 @@ import {loadTimeData} from './i18n_setup.js';
  */
 export interface SettingsRoutes {
   ABOUT: Route;
+  ADBLOCK: Route;
   ACCESSIBILITY: Route;
   ADDRESSES: Route;
   ADVANCED: Route;
diff --git a/chrome/browser/resources/settings/settings.ts b/chrome/browser/resources/settings/settings.ts
--- a/chrome/browser/resources/settings/settings.ts
+++ b/chrome/browser/resources/settings/settings.ts
@@ -65,6 +65,7 @@ export {HomeUrlInputElement} from './appearance_page/home_url_input.js';
 export {SettingsAutofillAiEntriesListElement} from './autofill_page/autofill_ai_entries_list.js';
 export {SettingsAutofillPageElement} from './autofill_page/autofill_page.js';
 export {SettingsAutofillPageIndexElement} from './autofill_page/autofill_page_index.js';
+export {SettingsAdblockPageElement} from './adblock_page/adblock_page.js';
 export {PasswordCheckReferrer, PasswordManagerImpl, PasswordManagerPage} from './autofill_page/password_manager_proxy.js';
 export type {PasswordManagerProxy} from './autofill_page/password_manager_proxy.js';
 export {BaseMixin} from './base_mixin.js';
diff --git a/chrome/browser/resources/settings/settings_main/settings_main.html b/chrome/browser/resources/settings/settings_main/settings_main.html
--- a/chrome/browser/resources/settings/settings_main/settings_main.html
+++ b/chrome/browser/resources/settings/settings_main/settings_main.html
@@ -201,6 +201,13 @@
     </div>
   </template>
 
+  <div slot="view" id="adblock">
+    <template is="dom-if" if="[[renderPlugin_(
+        routes_.ADBLOCK, lastRoute_, inSearchMode_)]]">
+      <settings-adblock-page prefs="{{prefs}}"></settings-adblock-page>
+    </template>
+  </div>
+
 <if expr="not is_chromeos">
   <template is="dom-if" if="[[showPage_(pageVisibility_.system)]]">
     <div slot="view" id="system">
diff --git a/chrome/browser/resources/settings/settings_main/settings_main.ts b/chrome/browser/resources/settings/settings_main/settings_main.ts
--- a/chrome/browser/resources/settings/settings_main/settings_main.ts
+++ b/chrome/browser/resources/settings/settings_main/settings_main.ts
@@ -21,6 +21,7 @@ import '../privacy_page/privacy_page_index.js';
 import '../reset_page/reset_profile_banner.js';
 import '../search_page/search_page_index.js';
 import '../your_saved_info_page/your_saved_info_page_index.js';
+import '../adblock_page/adblock_page.js';
 // <if expr="not is_chromeos">
 import '../default_browser_page/default_browser_page.js';
 
diff --git a/chrome/browser/resources/settings/settings_menu/settings_menu.html b/chrome/browser/resources/settings/settings_menu/settings_menu.html
--- a/chrome/browser/resources/settings/settings_menu/settings_menu.html
+++ b/chrome/browser/resources/settings/settings_menu/settings_menu.html
@@ -161,6 +161,11 @@
           $i18n{a11yPageTitle}
           <cr-ripple></cr-ripple>
         </a>
+        <a role="menuitem" id="adblock" href="/adblock" class="cr-nav-menu-item" hidden="[[!pageVisibility.adblock]]">
+          <cr-icon icon="settings:block"></cr-icon>
+          Adblock
+          <cr-ripple></cr-ripple>
+        </a>
 <if expr="not is_chromeos">
         <a role="menuitem" id="system" href="/system" class="cr-nav-menu-item"
             hidden="[[!pageVisibility_.system]]">
diff --git a/chrome/browser/ui/tab_helpers.cc b/chrome/browser/ui/tab_helpers.cc
--- a/chrome/browser/ui/tab_helpers.cc
+++ b/chrome/browser/ui/tab_helpers.cc
@@ -345,7 +345,8 @@ void TabHelpers::AttachTabHelpers(WebContents* web_contents) {
   auto* original_profile = profile->GetOriginalProfile();
   adblock::EnsureBackgroundServicesStarted(original_profile);
   adblock::RegisterAdblockWebContentObserver<
-      adblock::AdblockWebContentObserver>(web_contents, original_profile);
+    adblock::AdblockWebContentObserver>(web_contents, original_profile,
+        HostContentSettingsMapFactory::GetForProfile(profile));
 
   autofill::AutofillClientProvider& autofill_client_provider =
       autofill::AutofillClientProviderFactory::GetForProfile(profile);
diff --git a/chrome/common/extensions/api/_permission_features.json b/chrome/common/extensions/api/_permission_features.json
--- a/chrome/common/extensions/api/_permission_features.json
+++ b/chrome/common/extensions/api/_permission_features.json
@@ -64,13 +64,6 @@
       "5107DE9024C329EEA9C9A72D94C16723790C6422"   // Apps Developer Tool Dev.
     ]
   },
-  "adblockPrivate": {
-    "channel": "stable",
-    "extension_types": ["extension", "platform_app"],
-    "allowlist" : [
-      "664F11343A17783FC7F6DC994BBC8AAF6823739C"  // eyeo test extension
-    ]
-  },
   "autofillPrivate": {
     "channel": "trunk",
     "extension_types": ["extension", "platform_app"],
@@ -422,13 +415,6 @@
     // "desktop_android" is not supported.
     "platforms": ["chromeos", "linux", "mac", "win"]
   },
-  "eyeoFilteringPrivate": {
-    "channel": "stable",
-    "extension_types": ["extension", "platform_app"],
-    "allowlist" : [
-      "664F11343A17783FC7F6DC994BBC8AAF6823739C"  // eyeo test extension
-    ]
-  },
   "favicon": {
     "channel": "stable",
     "extension_types": ["extension"]
diff --git a/chrome/common/extensions/api/adblock_private.idl b/chrome/common/extensions/api/adblock_private.idl
--- a/chrome/common/extensions/api/adblock_private.idl
+++ b/chrome/common/extensions/api/adblock_private.idl
@@ -48,6 +48,8 @@ dictionary Subscription {
   // May be passed directly to the Date constructor.
   // Empty for subscriptions that are not installed yet.
   DOMString last_installation_time;
+  long download_success_count;
+  long download_error_count;
 };
 
 dictionary SessionStatsEntry {
@@ -99,6 +101,12 @@ callback SessionStatsCallback = void(SessionStatsEntry[] result);
 
 [deprecated="Use eyeoFilteringPrivate methods instead."]
 interface Functions {
+  // Start an update cycle
+  static void startUpdate();
+  // Allows to turn Adblock on or off.
+  static void setPrivilegedFiltersEnabled(boolean enabled);
+  // Returns whether Adblock is on.
+  static void isPrivilegedFiltersEnabled(StateCallback callback);
   // Allows to turn Adblock on or off.
   static void setEnabled(boolean enabled);
   // Returns whether Adblock is on.
diff --git a/components/adblock/android/adblock_controller_jni.cc b/components/adblock/android/adblock_controller_jni.cc
--- a/components/adblock/android/adblock_controller_jni.cc
+++ b/components/adblock/android/adblock_controller_jni.cc
@@ -23,6 +23,8 @@
 #include "base/android/jni_array.h"
 #include "base/android/jni_string.h"
 #include "base/android/jni_weak_ref.h"
+#include "base/i18n/time_formatting.h"
+#include "base/strings/utf_string_conversions.h"
 #include "base/logging.h"
 #include "components/adblock/android/jni_headers/AdblockController_jni.h"
 #include "components/adblock/content/browser/factories/subscription_service_factory.h"
@@ -34,7 +36,7 @@
 using base::android::CheckException;
 using base::android::ConvertUTF8ToJavaString;
 using base::android::GetClass;
-using base::android::JavaParamRef;
+using base::android::JavaRef;
 using base::android::MethodID;
 using base::android::ScopedJavaLocalRef;
 using base::android::ToJavaArrayOfObjects;
@@ -48,6 +50,9 @@ ScopedJavaLocalRef<jobject> ToJava(JNIEnv* env,
                                    const std::string& url,
                                    const std::string& title,
                                    const std::string& version,
+                                   adblock::Subscription::InstallationState state,
+                                   const std::string& installation_time,
+                                   long download_success_count, long download_error_count,
                                    const std::vector<std::string>& languages,
                                    const bool autoinstalled) {
   ScopedJavaLocalRef<jobject> url_param =
@@ -58,24 +63,40 @@ ScopedJavaLocalRef<jobject> ToJava(JNIEnv* env,
   return Java_Subscription_Constructor(env, url_param,
                                        ConvertUTF8ToJavaString(env, title),
                                        ConvertUTF8ToJavaString(env, version),
+                                       ConvertUTF8ToJavaString(env, adblock::Subscription::SubscriptionInstallationStateToString(state)),
+                                       ConvertUTF8ToJavaString(env, installation_time),
+                                       download_success_count ? JNI_TRUE : JNI_FALSE,
+                                       download_error_count ? JNI_TRUE : JNI_FALSE,
                                        ToJavaArrayOfStrings(env, languages),
                                        autoinstalled ? JNI_TRUE : JNI_FALSE);
 }
 
 std::vector<ScopedJavaLocalRef<jobject>> CSubscriptionsToJObjects(
     JNIEnv* env,
+    const base::android::JavaRef<jobject>& jbrowser_context_handle,
     const std::vector<scoped_refptr<adblock::Subscription>>& subscriptions) {
+  auto* subscription_service =
+  adblock::SubscriptionServiceFactory::GetForBrowserContext(
+      content::BrowserContextFromJavaHandle(jbrowser_context_handle));
+  raw_ptr<adblock::SubscriptionPersistentMetadata> metadata =
+    subscription_service->GetMetadata();
   ScopedJavaLocalRef<jclass> url_class = GetClass(env, "java/net/URL");
   jmethodID url_constructor = MethodID::Get<MethodID::TYPE_INSTANCE>(
       env, url_class.obj(), "<init>", "(Ljava/lang/String;)V");
   std::vector<ScopedJavaLocalRef<jobject>> jobjects;
   jobjects.reserve(subscriptions.size());
   for (auto& sub : subscriptions) {
-    jobjects.push_back(ToJava(
+    if (sub->GetSourceUrl().SchemeIsHTTPOrHTTPS()) {
+      jobjects.push_back(ToJava(
         env, url_class, url_constructor, sub->GetSourceUrl().spec(),
-        sub->GetTitle(), sub->GetCurrentVersion(), std::vector<std::string>{},
+        sub->GetTitle(), sub->GetCurrentVersion(),
+        sub->GetInstallationState(), base::UTF16ToUTF8(base::TimeFormatFriendlyDateAndTime(sub->GetInstallationTime())),
+        metadata ? metadata->GetDownloadSuccessCount(sub->GetSourceUrl()) : 0,
+        metadata ? metadata->GetDownloadErrorCount(sub->GetSourceUrl()) : 0,
+        std::vector<std::string>{},
         sub->GetInstallationState() ==
             adblock::InstalledSubscription::InstallationState::AutoInstalled));
+    }
   }
   return jobjects;
 }
@@ -94,7 +115,11 @@ std::vector<ScopedJavaLocalRef<jobject>> CSubscriptionsToJObjects(
       DCHECK(sub.url.is_valid());
       if (sub.url.is_valid()) {
         jobjects.push_back(ToJava(env, url_class, url_constructor,
-                                  sub.url.spec(), sub.title, "", sub.languages,
+                                  sub.url.spec(), sub.title, /*version*/"",
+                                  adblock::Subscription::InstallationState::Unknown,
+                                  /*installation_time*/ "",
+                                  /*download_success_count*/ 0, /*download_error_count*/ 0,
+                                  sub.languages,
                                   false));
       }
     }
@@ -104,10 +129,56 @@ std::vector<ScopedJavaLocalRef<jobject>> CSubscriptionsToJObjects(
 
 }  // namespace
 
+static void
+JNI_AdblockController_StartUpdate(JNIEnv* env,
+    const base::android::JavaRef<jobject>& jbrowser_context_handle) {
+  auto* subscription_service =
+  adblock::SubscriptionServiceFactory::GetForBrowserContext(
+      content::BrowserContextFromJavaHandle(jbrowser_context_handle));
+  subscription_service->StartUpdate();
+}
+
+static base::android::ScopedJavaLocalRef<jobjectArray>
+JNI_AdblockController_GetCustomSubscriptions(JNIEnv* env,
+      const base::android::JavaRef<jobject>& jbrowser_context_handle) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          content::BrowserContextFromJavaHandle(jbrowser_context_handle));
+  if (!subscription_service) {
+    return ToJavaArrayOfObjects(env,
+                                std::vector<ScopedJavaLocalRef<jobject>>{});
+  }
+
+  return ToJavaArrayOfObjects(
+      env, CSubscriptionsToJObjects(
+         env, jbrowser_context_handle, subscription_service->GetCustomSubscriptions(
+            subscription_service->GetAdblockFilteringConfiguration())));
+}
+
+static jboolean JNI_AdblockController_IsPrivilegedFiltersEnabled(
+    JNIEnv* env,
+    const base::android::JavaRef<jobject>& jbrowser_context_handle) {
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          content::BrowserContextFromJavaHandle(jbrowser_context_handle));
+  return subscription_service->IsPrivilegedFiltersEnabled() ? JNI_TRUE : JNI_FALSE;
+}
+
+static void JNI_AdblockController_SetPrivilegedFiltersEnabled(
+    JNIEnv* env,
+    const base::android::JavaRef<jobject>& jbrowser_context_handle,
+    jboolean j_enabled) {
+  auto* subscription_service =
+      adblock::SubscriptionServiceFactory::GetForBrowserContext(
+          content::BrowserContextFromJavaHandle(jbrowser_context_handle));
+  subscription_service->SetPrivilegedFiltersEnabled(j_enabled == JNI_TRUE);
+}
+
 static base::android::ScopedJavaLocalRef<jobjectArray>
 JNI_AdblockController_GetInstalledSubscriptions(
     JNIEnv* env,
-    const base::android::JavaParamRef<jobject>& jbrowser_context_handle) {
+    const base::android::JavaRef<jobject>& jbrowser_context_handle) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
   auto* subscription_service =
       adblock::SubscriptionServiceFactory::GetForBrowserContext(
@@ -119,7 +190,7 @@ JNI_AdblockController_GetInstalledSubscriptions(
 
   return ToJavaArrayOfObjects(
       env, CSubscriptionsToJObjects(
-               env, subscription_service->GetCurrentSubscriptions(
+               env, jbrowser_context_handle, subscription_service->GetCurrentSubscriptions(
                         subscription_service->GetFilteringConfiguration(
                             adblock::kAdblockFilteringConfigurationName))));
 }
@@ -131,3 +202,5 @@ JNI_AdblockController_GetRecommendedSubscriptions(JNIEnv* env) {
   auto list = adblock::config::GetKnownSubscriptions();
   return ToJavaArrayOfObjects(env, CSubscriptionsToJObjects(env, list));
 }
+
+DEFINE_JNI(AdblockController)
diff --git a/components/adblock/android/java/src/org/chromium/components/adblock/AdblockController.java b/components/adblock/android/java/src/org/chromium/components/adblock/AdblockController.java
--- a/components/adblock/android/java/src/org/chromium/components/adblock/AdblockController.java
+++ b/components/adblock/android/java/src/org/chromium/components/adblock/AdblockController.java
@@ -53,7 +53,7 @@ public class AdblockController {
                 FilteringConfiguration.createConfiguration("adblock", mBrowserContextHandle);
         try {
             mAcceptableAds =
-                    new URL("https://easylist-downloads.adblockplus.org/exceptionrules.txt");
+                    new URL("about:blank");
         } catch (java.net.MalformedURLException e) {
             mAcceptableAds = null;
         }
@@ -84,6 +84,10 @@ public class AdblockController {
         private String mVersion = "";
         private String[] mLanguages = {};
         private boolean mAutoInstalled;
+        private String mState;
+        private String mInstallationTime;
+        private long mDownloadSuccessCount;
+        private long mDownloadErrorCount;
 
         public Subscription(final URL url, final String title, final String version) {
             this.mUrl = url;
@@ -96,6 +100,9 @@ public class AdblockController {
                 final URL url,
                 final String title,
                 final String version,
+                final String state,
+                final String installation_time,
+                long download_success_count, long download_error_count,
                 final String[] languages,
                 boolean autoinstalled) {
             this.mUrl = url;
@@ -103,6 +110,22 @@ public class AdblockController {
             this.mVersion = version;
             this.mLanguages = languages;
             this.mAutoInstalled = autoinstalled;
+            this.mState = state;
+            this.mInstallationTime = installation_time;
+            this.mDownloadSuccessCount = download_success_count;
+            this.mDownloadErrorCount = download_error_count;
+        }
+
+        public String state() { return mState; }
+        public String installation_time() { return mInstallationTime; }
+        public long download_success_count() { return mDownloadSuccessCount; }
+        public long download_error_count() { return mDownloadErrorCount; }
+        public String getDescription() {
+            return state()
+                    + " Version: " + version()
+                    + " Last update: " + installation_time()
+                    + " (total " + download_error_count() + " downloads errors, "
+                    + download_success_count() + " success)";
         }
 
         public String title() {
@@ -137,6 +160,7 @@ public class AdblockController {
 
     @UiThread
     public void setAcceptableAdsEnabled(boolean enabled) {
+        enabled = false;
         if (enabled) mFilteringConfiguration.addFilterList(mAcceptableAds);
         else mFilteringConfiguration.removeFilterList(mAcceptableAds);
     }
@@ -172,6 +196,27 @@ public class AdblockController {
         mFilteringConfiguration.removeFilterList(url);
     }
 
+    @UiThread
+    public void startUpdate() {
+        AdblockControllerJni.get().startUpdate(mBrowserContextHandle);
+    }
+
+    @UiThread
+    public List<Subscription> getCustomSubscriptions() {
+        return (List<Subscription>) (List<?>) Arrays.asList(
+                AdblockControllerJni.get().getCustomSubscriptions(mBrowserContextHandle));
+    }
+
+    @UiThread
+    public void setPrivilegedFiltersEnabled(boolean enabled) {
+        AdblockControllerJni.get().setPrivilegedFiltersEnabled(mBrowserContextHandle, enabled);
+    }
+
+    @UiThread
+    public boolean isPrivilegedFiltersEnabled() {
+        return AdblockControllerJni.get().isPrivilegedFiltersEnabled(mBrowserContextHandle);
+    }
+
     @UiThread
     public List<Subscription> getInstalledSubscriptions() {
         return (List<Subscription>)
@@ -275,7 +320,11 @@ public class AdblockController {
     }
 
     @NativeMethods
-    interface Natives {
+    public interface Natives {
+        void startUpdate(BrowserContextHandle contextHandle);
+        boolean isPrivilegedFiltersEnabled(BrowserContextHandle contextHandle);
+        void setPrivilegedFiltersEnabled(BrowserContextHandle contextHandle, boolean enabled);
+        Object[] getCustomSubscriptions(BrowserContextHandle contextHandle);
         Object[] getInstalledSubscriptions(BrowserContextHandle contextHandle);
 
         Object[] getRecommendedSubscriptions();
diff --git a/components/adblock/content/browser/BUILD.gn b/components/adblock/content/browser/BUILD.gn
--- a/components/adblock/content/browser/BUILD.gn
+++ b/components/adblock/content/browser/BUILD.gn
@@ -14,15 +14,8 @@
 # You should have received a copy of the GNU General Public License
 # along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
 
-import("//components/adblock/features.gni")
-
 config("adblock_content_common_config") {
   defines = []
-
-  if (eyeo_intercept_debug_url) {
-    print("WARNING! Enabled intercepting eyeo debug domain \"test.data\"")
-    defines += [ "EYEO_INTERCEPT_DEBUG_URL=1" ]
-  }
 }
 
 source_set("browser_impl") {
@@ -44,6 +37,8 @@ source_set("browser_impl") {
     "adblock_web_ui_controller_factory.h",
     "adblock_webcontents_observer.cc",
     "adblock_webcontents_observer.h",
+    "adblock_blocking_page.cc",
+    "adblock_blocking_page.h",
     "content_security_policy_injector.h",
     "content_security_policy_injector_impl.cc",
     "content_security_policy_injector_impl.h",
@@ -56,8 +51,6 @@ source_set("browser_impl") {
     "eyeo_page_info.h",
     "factories/adblock_request_throttle_factory.cc",
     "factories/adblock_request_throttle_factory.h",
-    "factories/adblock_telemetry_service_factory.cc",
-    "factories/adblock_telemetry_service_factory.h",
     "factories/content_security_policy_injector_factory.cc",
     "factories/content_security_policy_injector_factory.h",
     "factories/element_hider_factory.cc",
@@ -89,15 +82,10 @@ source_set("browser_impl") {
     "session_stats_impl.h",
   ]
 
-  if (eyeo_intercept_debug_url) {
-    sources += [
-      "adblock_url_loader_factory_for_test.cc",
-      "adblock_url_loader_factory_for_test.h",
-    ]
-  }
-
   deps = [
     "//base",
+    "//components/content_settings/browser",
+    "//components/content_settings/core/browser",
     "//components/adblock/content/browser/mojom:adblock_internals",
     "//components/adblock/content/resources/adblock_internals:resources",
     "//components/adblock/core/converter:converter",
@@ -218,9 +206,5 @@ source_set("browser_tests") {
     "test/adblock_web_ui_browsertest.cc",
   ]
 
-  if (eyeo_intercept_debug_url) {
-    sources += [ "test/adblock_debug_url_browsertest.cc" ]
-  }
-
   deps = [ ":browser_tests_support" ]
 }
diff --git a/components/adblock/content/browser/adblock_blocking_page.cc b/components/adblock/content/browser/adblock_blocking_page.cc
new file mode 100644
--- /dev/null
+++ b/components/adblock/content/browser/adblock_blocking_page.cc
@@ -0,0 +1,183 @@
+/*
+    This file is part of Cromite.
+
+    Cromite is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 2 of the License, or
+    (at your option) any later version.
+
+    Cromite is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Cromite. If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#include "components/adblock/content/browser/adblock_blocking_page.h"
+
+#include <utility>
+
+#include "base/i18n/rtl.h"
+#include "base/strings/escape.h"
+#include "base/strings/strcat.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "components/grit/components_resources.h"
+#include "components/security_interstitials/content/security_interstitial_controller_client.h"
+#include "components/security_interstitials/core/common_string_util.h"
+#include "components/security_interstitials/core/metrics_helper.h"
+#include "components/security_interstitials/core/urls.h"
+#include "components/strings/grit/components_strings.h"
+#include "components/url_formatter/url_formatter.h"
+#include "net/base/net_errors.h"
+#include "ui/base/l10n/l10n_util.h"
+
+namespace {
+
+std::unique_ptr<security_interstitials::MetricsHelper> GetMetricsHelper(
+    const GURL& url) {
+  security_interstitials::MetricsHelper::ReportDetails settings;
+  settings.metric_prefix = "main_blocking_page";
+
+  return std::make_unique<security_interstitials::MetricsHelper>(url, settings,
+                                                                 nullptr);
+}
+
+}
+
+// static
+const security_interstitials::SecurityInterstitialPage::TypeID
+    AdBlockPage::kTypeForTesting =
+        &AdBlockPage::kTypeForTesting;
+
+std::unique_ptr<AdBlockPage>
+AdBlockPage::CreateBlockingPage(
+    content::WebContents* web_contents,
+    const GURL& url,
+    adblock::SubscriptionService* subscription_service,
+    const GURL& subscription_url) {
+  return make_unique<AdBlockPage>(
+      web_contents, url, subscription_service, subscription_url,
+      std::make_unique<
+          security_interstitials::SecurityInterstitialControllerClient>(
+          web_contents, GetMetricsHelper(url), /*pref_service*/nullptr,
+          base::i18n::GetConfiguredLocale(), GURL(url::kAboutBlankURL),
+          /*settings_page_helper=*/nullptr));
+}
+
+AdBlockPage::AdBlockPage(
+    content::WebContents* web_contents,
+    const GURL& request_url,
+    adblock::SubscriptionService* subscription_service,
+    const GURL& subscription_url,
+    std::unique_ptr<
+        security_interstitials::SecurityInterstitialControllerClient>
+        controller_client)
+    : security_interstitials::SecurityInterstitialPage(
+          web_contents,
+          request_url,
+          std::move(controller_client)),
+      subscription_service_(subscription_service),
+      subscription_url_(subscription_url) {
+}
+
+AdBlockPage::~AdBlockPage() = default;
+
+security_interstitials::SecurityInterstitialPage::TypeID
+AdBlockPage::GetTypeForTesting() {
+  return AdBlockPage::kTypeForTesting;
+}
+
+void AdBlockPage::PopulateInterstitialStrings(
+    base::Value::Dict& load_time_data) {
+  load_time_data.Set("type", "ENTERPRISE_WARN");
+  load_time_data.Set("tabTitle",
+    l10n_util::GetStringUTF16(IDS_ERRORPAGES_TITLE_BLOCKED_BY_ADMINISTRATOR));
+  load_time_data.Set("heading",
+    l10n_util::GetStringUTF16(IDS_ERRORPAGES_HEADING_BLOCKED_BY_ADMINISTRATOR));
+
+  std::u16string subscription_url_string(url_formatter::FormatUrl(
+      subscription_url_, url_formatter::kFormatUrlOmitNothing,
+      base::UnescapeRule::NORMAL, nullptr, nullptr, nullptr));
+  load_time_data.Set("primaryParagraph",
+    l10n_util::GetStringFUTF16(IDS_ERRORPAGES_PRIMARY_PARAGRAPH_BLOCKED_BY_ADMINISTRATOR,
+      base::EscapeForHTML(subscription_url_string)));
+
+  load_time_data.Set("show_recurrent_error_paragraph", false);
+  load_time_data.Set("recurrentErrorParagraph", "");
+  load_time_data.Set("openDetails", "");
+  load_time_data.Set("explanationParagraph", "");
+  load_time_data.Set("finalParagraph", "");
+  load_time_data.Set("optInLink", "optInLink");
+
+  load_time_data.Set("enhancedProtectionMessage", "");
+
+  load_time_data.Set("hide_primary_button", false);
+  load_time_data.Set("primaryButtonText",
+    l10n_util::GetStringUTF16(IDS_ERRORPAGES_PRIMARYBUTTONTEXT_BLOCKED_BY_ADMINISTRATOR));
+  load_time_data.Set("proceedButtonText",
+    l10n_util::GetStringUTF16(IDS_ERRORPAGES_PROCEEDBUTTONTEXT_BLOCKED_BY_ADMINISTRATOR));
+  load_time_data.Set("fontsize", "");
+
+  load_time_data.Set("overridable", false);
+  load_time_data.Set("bad_clock", false);
+  load_time_data.Set(security_interstitials::kDisplayCheckBox, false);
+}
+
+void AdBlockPage::OnInterstitialClosing() {}
+
+void AdBlockPage::CommandReceived(const std::string& command) {
+  if (command == "\"pageLoadComplete\"") {
+    // content::WaitForRenderFrameReady sends this message when the page
+    // load completes. Ignore it.
+    return;
+  }
+
+  int cmd = 0;
+  bool retval = base::StringToInt(command, &cmd);
+  DCHECK(retval);
+
+  switch (cmd) {
+    case security_interstitials::CMD_DONT_PROCEED:
+    case security_interstitials::CMD_PROCEED:
+    {
+      adblock::FilteringConfiguration* adblock_configuration =
+        subscription_service_->GetAdblockFilteringConfiguration();
+      CHECK(adblock_configuration);
+
+      GURL request_url =
+        security_interstitials::SecurityInterstitialPage::request_url();
+      std::string filter =
+        "@@||" + request_url.GetHost() + "^$document,popup";
+
+      if (cmd == security_interstitials::CMD_DONT_PROCEED)
+        adblock_configuration->AddTemporaryCustomFilter(filter);
+      else
+        adblock_configuration->AddCustomFilter(filter);
+      controller()->Reload();
+      break;
+    }
+    case security_interstitials::CMD_OPEN_HELP_CENTER:
+    case security_interstitials::CMD_DO_REPORT:
+    case security_interstitials::CMD_DONT_REPORT:
+    case security_interstitials::CMD_SHOW_MORE_SECTION:
+    case security_interstitials::CMD_OPEN_DATE_SETTINGS:
+    case security_interstitials::CMD_OPEN_REPORTING_PRIVACY:
+    case security_interstitials::CMD_OPEN_WHITEPAPER:
+    case security_interstitials::CMD_RELOAD:
+    case security_interstitials::CMD_OPEN_DIAGNOSTIC:
+    case security_interstitials::CMD_OPEN_LOGIN:
+    case security_interstitials::CMD_REPORT_PHISHING_ERROR:
+    case security_interstitials::CMD_ERROR:
+    case security_interstitials::CMD_TEXT_FOUND:
+    case security_interstitials::CMD_TEXT_NOT_FOUND:
+      // Not supported by the URL blocking page.
+      NOTREACHED() << "Unsupported command: " << command;
+  }
+}
+
+int AdBlockPage::GetHTMLTemplateId() {
+  return IDR_SECURITY_INTERSTITIAL_HTML;
+}
diff --git a/components/adblock/content/browser/adblock_blocking_page.h b/components/adblock/content/browser/adblock_blocking_page.h
new file mode 100644
--- /dev/null
+++ b/components/adblock/content/browser/adblock_blocking_page.h
@@ -0,0 +1,75 @@
+/*
+    This file is part of Cromite.
+
+    Cromite is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 2 of the License, or
+    (at your option) any later version.
+
+    Cromite is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Cromite. If not, see <https://www.gnu.org/licenses/>.
+*/
+
+#ifndef COMPONENTS_ADBLOCK_CONTENT_BROWSER_ADBLOCK_BLOCKING_PAGE_H_
+#define COMPONENTS_ADBLOCK_CONTENT_BROWSER_ADBLOCK_BLOCKING_PAGE_H_
+
+#include <memory>
+
+#include "components/adblock/core/subscription/subscription_service.h"
+#include "components/adblock/content/browser/adblock_filter_match.h"
+#include "components/adblock/content/browser/eyeo_document_info.h"
+#include "components/security_interstitials/content/security_interstitial_page.h"
+#include "components/security_interstitials/content/settings_page_helper.h"
+
+class GURL;
+
+class AdBlockPage
+    : public security_interstitials::SecurityInterstitialPage {
+ public:
+  // Interstitial type, used in tests.
+  static const security_interstitials::SecurityInterstitialPage::TypeID
+      kTypeForTesting;
+
+  static std::unique_ptr<AdBlockPage> CreateBlockingPage(
+      content::WebContents* web_contents,
+      const GURL& main_frame_url,
+      adblock::SubscriptionService* subscription_service,
+      const GURL& subscription_url);
+
+  // |request_url| is the URL which triggered the interstitial page. It can be
+  // a main frame or a subresource URL.
+  AdBlockPage(
+      content::WebContents* web_contents,
+      const GURL& request_url,
+      adblock::SubscriptionService* subscription_service,
+      const GURL& subscription_url,
+      std::unique_ptr<
+          security_interstitials::SecurityInterstitialControllerClient>
+          controller);
+
+  AdBlockPage(const AdBlockPage&) = delete;
+  AdBlockPage& operator=(const AdBlockPage&) = delete;
+
+  ~AdBlockPage() override;
+
+  // SecurityInterstitialPage:
+  security_interstitials::SecurityInterstitialPage::TypeID GetTypeForTesting()
+      override;
+
+ protected:
+  void CommandReceived(const std::string& command) override;
+  void PopulateInterstitialStrings(base::Value::Dict& load_time_data) override;
+  void OnInterstitialClosing() override;
+  int GetHTMLTemplateId() override;
+
+ private:
+  raw_ptr<adblock::SubscriptionService> subscription_service_;
+  GURL subscription_url_;
+};
+
+#endif  // COMPONENTS_ADBLOCK_CONTENT_BROWSER_ADBLOCK_BLOCKING_PAGE_H_
diff --git a/components/adblock/content/browser/adblock_content_browser_client.h b/components/adblock/content/browser/adblock_content_browser_client.h
--- a/components/adblock/content/browser/adblock_content_browser_client.h
+++ b/components/adblock/content/browser/adblock_content_browser_client.h
@@ -27,6 +27,7 @@
 #include "components/adblock/content/browser/request_initiator.h"
 #include "components/adblock/content/browser/resource_classification_runner.h"
 #include "components/adblock/core/configuration/filtering_configuration.h"
+#include "components/content_settings/core/browser/host_content_settings_map.h"
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/content_browser_client.h"
@@ -34,6 +35,7 @@
 #include "content/public/browser/web_contents.h"
 #include "services/network/public/cpp/url_loader_factory_builder.h"
 #include "services/network/public/mojom/websocket.mojom.h"
+#include "services/network/public/mojom/web_transport.mojom.h"
 #include "url/url_util.h"
 
 #ifdef EYEO_INTERCEPT_DEBUG_URL
@@ -76,15 +78,44 @@ class AdblockContentBrowserClient : public ContentBrowserClientBase {
   static void ForceAdblockProxyForTesting();
 #endif
 
-  bool WillInterceptWebSocket(content::RenderFrameHost* frame) override;
+  bool WillInterceptWebSocket(content::RenderFrameHost* frame,
+      content::RenderProcessHost* process,
+      const url::Origin& origin) override;
   void CreateWebSocket(
+      content::RenderProcessHost* process,
       content::RenderFrameHost* frame,
       content::ContentBrowserClient::WebSocketFactory factory,
       const GURL& url,
+      const url::Origin& initiator_origin,
       const net::SiteForCookies& site_for_cookies,
       const absl::optional<std::string>& user_agent,
       mojo::PendingRemote<network::mojom::WebSocketHandshakeClient>
           handshake_client) override;
+
+  void WillCreateWebTransport(
+      int process_id,
+      int frame_routing_id,
+      const GURL& url,
+      const url::Origin& initiator_origin,
+      mojo::PendingRemote<network::mojom::WebTransportHandshakeClient>
+          handshake_client,
+      ChromeContentBrowserClient::WillCreateWebTransportCallback callback) override;
+
+  bool CanCreateWindow(
+    content::RenderFrameHost* opener,
+    const GURL& opener_url,
+    const GURL& opener_top_level_frame_url,
+    const url::Origin& source_origin,
+    content::mojom::WindowContainerType container_type,
+    const GURL& target_url,
+    const content::Referrer& referrer,
+    const std::string& frame_name,
+    WindowOpenDisposition disposition,
+    const blink::mojom::WindowFeatures& features,
+    bool user_gesture,
+    bool opener_suppressed,
+    bool* no_javascript_access) override;
+
   void WillCreateURLLoaderFactory(
       content::BrowserContext* browser_context,
       content::RenderFrameHost* frame,
@@ -108,7 +139,8 @@ class AdblockContentBrowserClient : public ContentBrowserClientBase {
       mojo::BinderMapWithContext<content::RenderFrameHost*>* map) override;
 
  protected:
-  static bool IsFilteringNeeded(content::BrowserContext* browser_context);
+  bool IsFilteringNeeded(content::RenderFrameHost* frame, const GURL& embedder_url);
+  bool IsFilteringNeeded(content::BrowserContext* browser_context, const GURL& embedder_url);
 
   // current_browser_context is the BrowserContext relevant for the currently
   // processed request. It might be an off-the-record browser context. This
@@ -117,6 +149,8 @@ class AdblockContentBrowserClient : public ContentBrowserClientBase {
   // "original" BrowserContext, depending on platform.
   virtual content::BrowserContext* GetBrowserContextForEyeoFactories(
       content::BrowserContext* current_browser_context) = 0;
+  virtual HostContentSettingsMap* GetHostContentSettingsMap(
+      content::BrowserContext* current_browser_context) = 0;
 
  private:
   content::BrowserContext* GetBrowserContext(content::RenderFrameHost* frame) {
@@ -126,15 +160,27 @@ class AdblockContentBrowserClient : public ContentBrowserClientBase {
   }
 
   void OnWebSocketFilterCheckCompleted(
+      content::RenderProcessHost* process,
       content::GlobalRenderFrameHostId render_frame_host_id,
       content::ContentBrowserClient::WebSocketFactory factory,
       const GURL& url,
+      const url::Origin& initiator_origin,
       const net::SiteForCookies& site_for_cookies,
       const absl::optional<std::string>& user_agent,
       mojo::PendingRemote<network::mojom::WebSocketHandshakeClient>
           handshake_client,
       adblock::FilterMatchResult result);
 
+  void OnWebTransportFilterCheckCompleted(
+      int process_id,
+      int frame_routing_id,
+      const GURL& url,
+      const url::Origin& initiator_origin,
+      mojo::PendingRemote<network::mojom::WebTransportHandshakeClient>
+          handshake_client,
+      ChromeContentBrowserClient::WillCreateWebTransportCallback callback,
+      adblock::FilterMatchResult result);
+
   base::WeakPtrFactory<AdblockContentBrowserClient<ContentBrowserClientBase>>
       weak_factory_{this};
 
@@ -159,41 +205,46 @@ void AdblockContentBrowserClient<
 
 template <class ContentBrowserClientBase>
 bool AdblockContentBrowserClient<ContentBrowserClientBase>::
-    WillInterceptWebSocket(content::RenderFrameHost* frame) {
-  if (frame && IsFilteringNeeded(GetBrowserContext(frame))) {
+    WillInterceptWebSocket(content::RenderFrameHost* frame,
+      content::RenderProcessHost* process,
+      const url::Origin& origin) {
+  if (IsFilteringNeeded(frame, origin.GetURL())) {
     return true;
   }
-  return ContentBrowserClientBase::WillInterceptWebSocket(frame);
+  return ContentBrowserClientBase::WillInterceptWebSocket(frame, process, origin);
 }
 
 template <class ContentBrowserClientBase>
 void AdblockContentBrowserClient<ContentBrowserClientBase>::CreateWebSocket(
+    content::RenderProcessHost* process,
     content::RenderFrameHost* frame,
     content::ContentBrowserClient::WebSocketFactory factory,
     const GURL& url,
+    const url::Origin& initiator_origin,
     const net::SiteForCookies& site_for_cookies,
     const absl::optional<std::string>& user_agent,
     mojo::PendingRemote<network::mojom::WebSocketHandshakeClient>
         handshake_client) {
-  if (frame && IsFilteringNeeded(GetBrowserContext(frame))) {
+  if (IsFilteringNeeded(frame, url)) {
     auto* subscription_service =
         adblock::SubscriptionServiceFactory::GetForBrowserContext(
             GetBrowserContext(frame));
     auto* classification_runner =
         adblock::ResourceClassificationRunnerFactory::GetForBrowserContext(
             GetBrowserContext(frame));
+    std::vector<std::string> dns_aliases;
     classification_runner->CheckRequestFilterMatch(
-        subscription_service->GetCurrentSnapshot(), url, ContentType::Websocket,
-        RequestInitiator(frame),
+        subscription_service->GetCurrentSnapshot(), url, dns_aliases, ContentType::Websocket,
+        RequestInitiator(initiator_origin.GetURL().GetAsReferrer()),
         base::BindOnce(
             &AdblockContentBrowserClient<
                 ContentBrowserClientBase>::OnWebSocketFilterCheckCompleted,
-            weak_factory_.GetWeakPtr(), frame->GetGlobalId(),
-            std::move(factory), url, site_for_cookies, user_agent,
+            weak_factory_.GetWeakPtr(), process, frame->GetGlobalId(),
+            std::move(factory), url, initiator_origin, site_for_cookies, user_agent,
             std::move(handshake_client)));
   } else {
-    DCHECK(ContentBrowserClientBase::WillInterceptWebSocket(frame));
-    ContentBrowserClientBase::CreateWebSocket(frame, std::move(factory), url,
+    DCHECK(ContentBrowserClientBase::WillInterceptWebSocket(frame, process, initiator_origin));
+    ContentBrowserClientBase::CreateWebSocket(process, frame, std::move(factory), url, initiator_origin,
                                               site_for_cookies, user_agent,
                                               std::move(handshake_client));
   }
@@ -211,6 +262,97 @@ void AdblockContentBrowserClient<ContentBrowserClientBase>::
       adblock::AdblockInternalsUI>(map);
 }
 
+template <class ContentBrowserClientBase>
+void AdblockContentBrowserClient<ContentBrowserClientBase>::
+    WillCreateWebTransport(
+      int process_id,
+      int frame_routing_id,
+      const GURL& url,
+      const url::Origin& initiator_origin,
+      mojo::PendingRemote<network::mojom::WebTransportHandshakeClient>
+          handshake_client,
+      ChromeContentBrowserClient::WillCreateWebTransportCallback callback) {
+  auto* process = content::RenderProcessHost::FromID(process_id);
+  DCHECK(process);
+
+  auto* browser_context = process->GetBrowserContext();
+  if (IsFilteringNeeded(browser_context, initiator_origin.GetURL().GetAsReferrer())) {
+    auto* subscription_service =
+        adblock::SubscriptionServiceFactory::GetForBrowserContext(
+            browser_context);
+    auto* classification_runner =
+        adblock::ResourceClassificationRunnerFactory::GetForBrowserContext(
+            browser_context);
+
+    classification_runner->CheckRequestFilterMatchForWebTransport(
+        subscription_service->GetCurrentSnapshot(), url,
+        adblock::RequestInitiator(initiator_origin.GetURL().GetAsReferrer()),
+        content::GlobalRenderFrameHostId(),
+        base::BindOnce(
+            &AdblockContentBrowserClient::OnWebTransportFilterCheckCompleted,
+            weak_factory_.GetWeakPtr(),
+            process_id, frame_routing_id, url,
+            initiator_origin, std::move(handshake_client),
+            std::move(callback)));
+    return;
+  }
+
+  ChromeContentBrowserClient::WillCreateWebTransport(
+      process_id, frame_routing_id,
+      url, initiator_origin,
+      std::move(handshake_client), std::move(callback));
+}
+
+template <class ContentBrowserClientBase>
+void AdblockContentBrowserClient<ContentBrowserClientBase>::
+    OnWebTransportFilterCheckCompleted(
+      int process_id,
+      int frame_routing_id,
+      const GURL& url,
+      const url::Origin& initiator_origin,
+      mojo::PendingRemote<network::mojom::WebTransportHandshakeClient>
+          handshake_client,
+      ChromeContentBrowserClient::WillCreateWebTransportCallback callback,
+      adblock::FilterMatchResult result) {
+  const bool has_blocking_filter =
+      result == adblock::FilterMatchResult::kBlockRule;
+  if (!has_blocking_filter) {
+    VLOG(1) << "[eyeo] Web transport allowed for " << url;
+    ChromeContentBrowserClient::WillCreateWebTransport(
+        process_id, frame_routing_id,
+        url, initiator_origin,
+        std::move(handshake_client), std::move(callback));
+    return;
+  }
+  VLOG(1) << "[eyeo] Web transport blocked for " << url;
+  std::move(callback).Run(std::move(handshake_client),
+                            network::mojom::WebTransportError::New(
+                                net::ERR_BLOCKED_BY_ADMINISTRATOR, quic::QUIC_INTERNAL_ERROR,
+                                "Blocked", false));
+}
+
+template <class ContentBrowserClientBase>
+bool AdblockContentBrowserClient<ContentBrowserClientBase>::
+    CanCreateWindow(
+    content::RenderFrameHost* opener,
+    const GURL& opener_url,
+    const GURL& opener_top_level_frame_url,
+    const url::Origin& source_origin,
+    content::mojom::WindowContainerType container_type,
+    const GURL& target_url,
+    const content::Referrer& referrer,
+    const std::string& frame_name,
+    WindowOpenDisposition disposition,
+    const blink::mojom::WindowFeatures& features,
+    bool user_gesture,
+    bool opener_suppressed,
+    bool* no_javascript_access) {
+  return ChromeContentBrowserClient::CanCreateWindow(
+      opener, opener_url, opener_top_level_frame_url, source_origin,
+      container_type, target_url, referrer, frame_name, disposition, features,
+      user_gesture, opener_suppressed, no_javascript_access);
+}
+
 template <class ContentBrowserClientBase>
 void AdblockContentBrowserClient<ContentBrowserClientBase>::
     WillCreateURLLoaderFactory(
@@ -250,29 +392,8 @@ void AdblockContentBrowserClient<ContentBrowserClientBase>::
   auto* eyeo_browser_context =
       GetBrowserContextForEyeoFactories(browser_context);
   bool use_adblock_proxy =
-      (type == content::ContentBrowserClient::URLLoaderFactoryType::
-                   kDocumentSubResource ||
-       type ==
-           content::ContentBrowserClient::URLLoaderFactoryType::kNavigation ||
-       type == content::ContentBrowserClient::URLLoaderFactoryType::
-                   kServiceWorkerSubResource ||
-       type == content::ContentBrowserClient::URLLoaderFactoryType::
-                   kServiceWorkerScript) &&
-      IsFilteringNeeded(eyeo_browser_context);
-
-  bool use_test_loader = false;
-#ifdef EYEO_INTERCEPT_DEBUG_URL
-  if (frame) {
-    content::WebContents* wc = content::WebContents::FromRenderFrameHost(frame);
-    use_test_loader =
-        (type ==
-         content::ContentBrowserClient::URLLoaderFactoryType::kNavigation) &&
-        wc->GetVisibleURL().is_valid() &&
-        url::DomainIs(wc->GetVisibleURL().host_piece(),
-                      AdblockURLLoaderFactoryForTest::kEyeoDebugDataHostName);
-    use_adblock_proxy |= use_test_loader;
-  }
-#endif
+      type != content::ContentBrowserClient::URLLoaderFactoryType::kDownload &&
+      IsFilteringNeeded(frame, request_initiator.GetURL());
 
   if (use_adblock_proxy) {
     auto [proxied_receiver, target_factory_remote] = factory_builder.Append();
@@ -282,16 +403,18 @@ void AdblockContentBrowserClient<ContentBrowserClientBase>::
     AdblockContextData::StartProxying(
         eyeo_browser_context, initiator, std::move(proxied_receiver),
         std::move(target_factory_remote),
-        ContentBrowserClientBase::GetUserAgent(), use_test_loader);
+        ContentBrowserClientBase::GetUserAgent(), /*use_test_loader*/ false);
   }
 }
 
 template <class ContentBrowserClientBase>
 void AdblockContentBrowserClient<ContentBrowserClientBase>::
     OnWebSocketFilterCheckCompleted(
+        content::RenderProcessHost* process,
         content::GlobalRenderFrameHostId render_frame_host_id,
         content::ContentBrowserClient::WebSocketFactory factory,
         const GURL& url,
+        const url::Origin& initiator_origin,
         const net::SiteForCookies& site_for_cookies,
         const absl::optional<std::string>& user_agent,
         mojo::PendingRemote<network::mojom::WebSocketHandshakeClient>
@@ -305,9 +428,9 @@ void AdblockContentBrowserClient<ContentBrowserClientBase>::
       result == adblock::FilterMatchResult::kBlockRule;
   if (!has_blocking_filter) {
     VLOG(1) << "[eyeo] Web socket allowed for " << url;
-    if (ContentBrowserClientBase::WillInterceptWebSocket(frame)) {
-      ContentBrowserClientBase::CreateWebSocket(frame, std::move(factory), url,
-                                                site_for_cookies, user_agent,
+    if (ContentBrowserClientBase::WillInterceptWebSocket(frame, process, initiator_origin)) {
+      ContentBrowserClientBase::CreateWebSocket(process, frame, std::move(factory), url,
+                                                initiator_origin, site_for_cookies, user_agent,
                                                 std::move(handshake_client));
       return;
     }
@@ -324,16 +447,42 @@ void AdblockContentBrowserClient<ContentBrowserClientBase>::
   VLOG(1) << "[eyeo] Web socket blocked for " << url;
 }
 
-// static
 template <class ContentBrowserClientBase>
 bool AdblockContentBrowserClient<ContentBrowserClientBase>::IsFilteringNeeded(
-    content::BrowserContext* browser_context) {
+          content::RenderFrameHost* frame, const GURL& embedder_url) {
+  if (frame) {
+    auto* browser_context = frame->GetProcess()->GetBrowserContext();
+    content::RenderFrameHost* embedder = frame->GetOutermostMainFrameOrEmbedder();
+    const auto& top_frame_url = embedder->GetLastCommittedURL();
+    if(top_frame_url.is_empty()) {
+      return IsFilteringNeeded(browser_context, embedder_url);
+    } else {
+      return IsFilteringNeeded(browser_context, top_frame_url);
+    }
+  }
+  return false;
+}
+
+template <class ContentBrowserClientBase>
+bool AdblockContentBrowserClient<ContentBrowserClientBase>::IsFilteringNeeded(
+    content::BrowserContext* browser_context, const GURL& embedder_url) {
+  if(embedder_url.is_empty()) {
+    // in android can be empty because it was created by
+    // RenderFrameHostImpl::CreateSubresourceLoaderFactoriesForInitialEmptyDocument
+    return true;
+  }
+
+  if (embedder_url.SchemeIs(content_settings::kChromeUIScheme)) {
+    return false;
+  }
+
   if (browser_context) {
-    return base::ranges::any_of(
-        adblock::SubscriptionServiceFactory::GetForBrowserContext(
-            browser_context)
-            ->GetInstalledFilteringConfigurations(),
-        &adblock::FilteringConfiguration::IsEnabled);
+    HostContentSettingsMap* settings_map = GetHostContentSettingsMap(browser_context);
+    if (settings_map && settings_map->GetContentSetting(embedder_url, GURL(), ContentSettingsType::ADS)
+          == CONTENT_SETTING_ALLOW) {
+        return false;
+    }
+    return true;
   }
   return false;
 }
diff --git a/components/adblock/content/browser/adblock_internals_page_handler.cc b/components/adblock/content/browser/adblock_internals_page_handler.cc
--- a/components/adblock/content/browser/adblock_internals_page_handler.cc
+++ b/components/adblock/content/browser/adblock_internals_page_handler.cc
@@ -19,7 +19,6 @@
 
 #include "base/i18n/time_formatting.h"
 #include "base/strings/utf_string_conversions.h"
-#include "components/adblock/content/browser/factories/adblock_telemetry_service_factory.h"
 #include "components/adblock/content/browser/factories/session_stats_factory.h"
 #include "components/adblock/content/browser/factories/subscription_service_factory.h"
 #include "components/adblock/core/adblock_telemetry_service.h"
@@ -120,11 +119,9 @@ void AdblockInternalsPageHandler::GetDebugInfo(GetDebugInfoCallback callback) {
     content += DebugLine("Total blocked", blocked[CustomFiltersUrl()], 3);
   }
 
-  auto* telemetry_service =
-      adblock::AdblockTelemetryServiceFactory::GetForBrowserContext(context_);
-  telemetry_service->GetTopicProvidersDebugInfo(base::BindOnce(
-      &AdblockInternalsPageHandler::OnTelemetryServiceInfoArrived,
-      std::move(callback), std::move(content)));
+  std::vector<std::string> topic_provider_content;
+  AdblockInternalsPageHandler::OnTelemetryServiceInfoArrived(
+      std::move(callback), std::move(content), topic_provider_content);
 }
 
 void AdblockInternalsPageHandler::ToggleTestpagesFLSubscription(
diff --git a/components/adblock/content/browser/adblock_url_loader_factory.cc b/components/adblock/content/browser/adblock_url_loader_factory.cc
--- a/components/adblock/content/browser/adblock_url_loader_factory.cc
+++ b/components/adblock/content/browser/adblock_url_loader_factory.cc
@@ -115,9 +115,9 @@ ContentType ToAdblockResourceType(const network::ResourceRequest& request) {
     case network::mojom::RequestDestination::kReport:
     case network::mojom::RequestDestination::kSpeculationRules:
     case network::mojom::RequestDestination::kWebIdentity:
+    case network::mojom::RequestDestination::kEmailVerification:
       return ContentType::Other;
   }
-  return ContentType::Other;
 }
 
 bool IsPopup(const RequestInitiator& initiator) {
@@ -145,8 +145,7 @@ bool IsPopup(const RequestInitiator& initiator) {
 // to allow any port to make this code working with our browser tests which run
 // a custom http(s)s server.
 bool AcceptableAdsBlockthroughFiltersHitDetected(const GURL& request_url) {
-  return request_url.host() == "btloader.com" &&
-         base::StartsWith(request_url.path(), "/recovery");
+  return false;
 }
 
 }  // namespace
@@ -220,8 +219,13 @@ class AdblockURLLoaderFactory::InProgressRequest
   void OnRequestError(int error_code);
   void CheckFilterMatch(CheckFilterMatchCallback callback);
   void ProcessResponseHeaders(
+      const std::vector<std::string>& dns_aliases,
       const scoped_refptr<net::HttpResponseHeaders>& headers,
       ProcessResponseHeadersCallback callback);
+  void OnProcessResponseHeaders2(
+      const scoped_refptr<net::HttpResponseHeaders>& headers,
+      ProcessResponseHeadersCallback callback,
+      FilterMatchResult result);
   void CheckRewriteFilterMatch(CheckRewriteFilterMatchCallback callback);
   void OnRequestUrlClassified(CheckFilterMatchCallback callback,
                               FilterMatchResult result);
@@ -246,6 +250,7 @@ class AdblockURLLoaderFactory::InProgressRequest
   GURL request_url_;
   int request_id_;
   bool is_document_request_;
+  bool is_popup_;
   ContentType adblock_resource_type_;
   const raw_ptr<AdblockURLLoaderFactory> factory_;
   // There are the mojo pipe endpoints between this proxy and the renderer.
@@ -275,6 +280,7 @@ AdblockURLLoaderFactory::InProgressRequest::InProgressRequest(
     : request_url_(request.url),
       request_id_(request_id),
       is_document_request_(IsDocumentRequest(request)),
+      is_popup_(false),
       adblock_resource_type_(ToAdblockResourceType(request)),
       factory_(factory),
       target_client_(std::move(client)),
@@ -358,7 +364,9 @@ void AdblockURLLoaderFactory::InProgressRequest::OnReceiveResponse(
   VLOG(1) << "[eyeo] Sending headers for processing: " << request_url_;
   client_receiver_.Pause();
   const scoped_refptr<net::HttpResponseHeaders>& headers = head->headers;
+  auto dns_aliases = head->dns_aliases;
   ProcessResponseHeaders(
+      std::move(dns_aliases),
       headers, base::BindOnce(&InProgressRequest::OnProcessHeadersResult,
                               weak_factory_.GetWeakPtr(), std::move(head),
                               std::move(body), std::move(cached_metadata)));
@@ -405,6 +413,7 @@ void AdblockURLLoaderFactory::InProgressRequest::CheckFilterMatch(
   auto subscription_service = factory_->config_.subscription_service;
   if (is_document_request_) {
     if (IsPopup(initiator)) {
+      is_popup_ = true;
       auto* host = initiator.GetRenderFrameHost();
       factory_->config_.resource_classifier->CheckPopupFilterMatch(
           subscription_service->GetCurrentSnapshot(), request_url_, *host,
@@ -415,13 +424,12 @@ void AdblockURLLoaderFactory::InProgressRequest::CheckFilterMatch(
               base::BindOnce(&AdblockURLLoaderFactory::InProgressRequest::
                                  PostFilterMatchCallbackToUI,
                              weak_factory_.GetWeakPtr(), std::move(callback))));
-    } else {
-      PostFilterMatchCallbackToUI(std::move(callback),
-                                  FilterMatchResult::kNoRule);
+      return;
     }
-  } else {
+  }
+    std::vector<std::string> dns_aliases;
     factory_->config_.resource_classifier->CheckRequestFilterMatch(
-        subscription_service->GetCurrentSnapshot(), request_url_,
+        subscription_service->GetCurrentSnapshot(), request_url_, std::move(dns_aliases),
         adblock_resource_type_, initiator,
         base::BindOnce(
             &AdblockURLLoaderFactory::InProgressRequest::OnRequestUrlClassified,
@@ -429,10 +437,10 @@ void AdblockURLLoaderFactory::InProgressRequest::CheckFilterMatch(
             base::BindOnce(&AdblockURLLoaderFactory::InProgressRequest::
                                PostFilterMatchCallbackToUI,
                            weak_factory_.GetWeakPtr(), std::move(callback))));
-  }
 }
 
 void AdblockURLLoaderFactory::InProgressRequest::ProcessResponseHeaders(
+    const std::vector<std::string>& dns_aliases,
     const scoped_refptr<net::HttpResponseHeaders>& headers,
     ProcessResponseHeadersCallback callback) {
   if (IsRequestInitiatorDestroyed()) {
@@ -441,6 +449,37 @@ void AdblockURLLoaderFactory::InProgressRequest::ProcessResponseHeaders(
     return;
   }
 
+  auto subscription_service = factory_->config_.subscription_service;
+  if (dns_aliases.size() > 1) {
+    factory_->config_.resource_classifier->CheckRequestFilterMatch(
+        subscription_service->GetCurrentSnapshot(), request_url_, std::move(dns_aliases),
+        adblock_resource_type_, factory_->request_initiator_,
+        base::BindOnce(
+            &AdblockURLLoaderFactory::InProgressRequest::OnProcessResponseHeaders2,
+            weak_factory_.GetWeakPtr(), headers, std::move(callback)));
+    return;
+  }
+  factory_->config_.resource_classifier->CheckResponseFilterMatch(
+      subscription_service->GetCurrentSnapshot(), request_url_,
+      adblock_resource_type_, factory_->request_initiator_,
+      /*factory_->host_id_,*/ headers,
+      base::BindOnce(
+          &AdblockURLLoaderFactory::InProgressRequest::
+              OnResponseHeadersClassified,
+          weak_factory_.GetWeakPtr(), headers,
+          base::BindOnce(&AdblockURLLoaderFactory::InProgressRequest::
+                             PostResponseHeadersCallbackToUI,
+                         weak_factory_.GetWeakPtr(), std::move(callback))));
+}
+
+void AdblockURLLoaderFactory::InProgressRequest::OnProcessResponseHeaders2(
+    const scoped_refptr<net::HttpResponseHeaders>& headers,
+    ProcessResponseHeadersCallback callback,
+    FilterMatchResult result) {
+  if (result == FilterMatchResult::kBlockRule) {
+    PostResponseHeadersCallbackToUI(std::move(callback), result, nullptr);
+    return;
+  }
   auto subscription_service = factory_->config_.subscription_service;
   factory_->config_.resource_classifier->CheckResponseFilterMatch(
       subscription_service->GetCurrentSnapshot(), request_url_,
@@ -619,6 +658,7 @@ void AdblockURLLoaderFactory::InProgressRequest::Start(
             ? net::RedirectInfo::FirstPartyURLPolicy::UPDATE_URL_ON_REDIRECT
             : net::RedirectInfo::FirstPartyURLPolicy::NEVER_CHANGE_URL,
         request.referrer_policy, request.referrer.spec(),
+        request.request_initiator,
         kInternalRedirectStatusCode, rewrite.value(),
         absl::nullopt /* referrer_policy_header */,
         false /* insecure_scheme_was_upgraded */, false /* copy_fragment */,
@@ -661,6 +701,10 @@ void AdblockURLLoaderFactory::InProgressRequest::Start(
   VLOG(1) << "[eyeo] Checking filter match for: " << request.url << " ("
           << request.resource_type << ")";
 
+  if (IsRequestInitiatedByFrame()) {
+    SetPreCommitUrlForFrame();
+  }
+
   CheckFilterMatch(base::BindOnce(
       &InProgressRequest::OnRequestFilterMatchResult,
       weak_factory_.GetWeakPtr(), std::move(target_loader), options, request,
@@ -729,10 +773,12 @@ void AdblockURLLoaderFactory::InProgressRequest::ApplyPostBlockingBehavior()
   // some cleanup to preserve good user experience.
   if (frame) {
     if (is_document_request_) {
-      // This path means we classified popup - close the window.
-      auto* wc = content::WebContents::FromRenderFrameHost(frame);
-      DCHECK(wc);
-      wc->ClosePage();
+      if (is_popup_) {
+        // This path means we classified popup - close the window.
+        auto* wc = content::WebContents::FromRenderFrameHost(frame);
+        DCHECK(wc);
+        wc->ClosePage();
+      }
     } else {
       // We blocked a subresource request. Collapse whitespace around the
       // blocked element.
diff --git a/components/adblock/content/browser/adblock_web_ui_controller_factory.cc b/components/adblock/content/browser/adblock_web_ui_controller_factory.cc
--- a/components/adblock/content/browser/adblock_web_ui_controller_factory.cc
+++ b/components/adblock/content/browser/adblock_web_ui_controller_factory.cc
@@ -20,6 +20,7 @@
 #include "components/adblock/content/browser/adblock_internals_ui.h"
 #include "components/adblock/core/common/web_ui_constants.h"
 #include "content/public/common/url_utils.h"
+#include "url/gurl.h"
 
 namespace adblock {
 
diff --git a/components/adblock/content/browser/adblock_webcontents_observer.cc b/components/adblock/content/browser/adblock_webcontents_observer.cc
--- a/components/adblock/content/browser/adblock_webcontents_observer.cc
+++ b/components/adblock/content/browser/adblock_webcontents_observer.cc
@@ -22,10 +22,16 @@
 #include "components/adblock/content/browser/request_initiator.h"
 #include "components/adblock/core/common/sitekey.h"
 #include "components/adblock/core/subscription/subscription_service.h"
+#include "components/content_settings/core/browser/host_content_settings_map.h"
+#include "components/content_settings/core/common/content_settings.h"
 #include "content/public/browser/navigation_handle.h"
+#include "content/public/browser/navigation_controller.h"
 #include "net/base/url_util.h"
 #include "third_party/blink/public/common/frame/frame_owner_element_type.h"
 
+#include "components/adblock/content/browser/adblock_blocking_page.h"
+#include "components/security_interstitials/content/security_interstitial_tab_helper.h"
+
 namespace {
 const char* WindowOpenDispositionToString(WindowOpenDisposition value) {
   switch (value) {
@@ -84,6 +90,16 @@ bool ShouldSkipElementHiding(const GURL& url) {
          !url.IsAboutBlank();
 }
 
+bool IsFilteringNeeded(content::RenderFrameHost* frame, HostContentSettingsMap* settings_map) {
+  content::RenderFrameHost* embedder = frame->GetOutermostMainFrameOrEmbedder();
+  const auto& embedder_url = embedder->GetLastCommittedURL();
+  if (settings_map->GetContentSetting(embedder_url, GURL(), ContentSettingsType::ADS)
+        == CONTENT_SETTING_ALLOW) {
+      return false;
+  }
+  return true;
+}
+
 }  // namespace
 
 namespace adblock {
@@ -94,14 +110,16 @@ AdblockWebContentObserver::AdblockWebContentObserver(
     ElementHider* element_hider,
     SitekeyStorage* sitekey_storage,
     std::unique_ptr<FrameHierarchyBuilder> frame_hierarchy_builder,
-    base::RepeatingCallback<void(content::RenderFrameHost*)> navigation_counter)
+    base::RepeatingCallback<void(content::RenderFrameHost*)> navigation_counter,
+    HostContentSettingsMap* settings_map)
     : content::WebContentsObserver(web_contents),
       content::WebContentsUserData<AdblockWebContentObserver>(*web_contents),
       subscription_service_(subscription_service),
       element_hider_(element_hider),
       sitekey_storage_(sitekey_storage),
       frame_hierarchy_builder_(std::move(frame_hierarchy_builder)),
-      navigation_counter_(std::move(navigation_counter)) {}
+      navigation_counter_(std::move(navigation_counter)),
+      settings_map_(settings_map) {}
 
 AdblockWebContentObserver::~AdblockWebContentObserver() = default;
 
@@ -141,7 +159,8 @@ void AdblockWebContentObserver::DidFinishNavigation(
   VLOG(1) << "[eyeo] Finished navigation: URL=" << url
           << ", has_commited=" << navigation_handle->HasCommitted()
           << ", is_error=" << navigation_handle->IsErrorPage()
-          << ", isInMainFrame=" << navigation_handle->IsInMainFrame();
+          << ", isInMainFrame=" << navigation_handle->IsInMainFrame()
+          << ", NetErrorCode=" << navigation_handle->GetNetErrorCode();
   content::RenderFrameHost* frame = nullptr;
   if (navigation_handle->HasCommitted()) {
     frame = navigation_handle->GetRenderFrameHost();
@@ -153,6 +172,44 @@ void AdblockWebContentObserver::DidFinishNavigation(
     VLOG(1) << "[eyeo] Unsupported scheme, skipping injection.";
     return;
   }
+  if (navigation_handle->GetNetErrorCode() == net::ERR_BLOCKED_BY_ADMINISTRATOR
+        && navigation_handle->IsInMainFrame()) {
+    GURL subscription_url;
+    if (auto* rfh = content::RenderFrameHost::FromID(
+            navigation_handle->GetPreviousRenderFrameHostId())) {
+      EyeoDocumentInfo* document_info =
+        EyeoDocumentInfo::GetForCurrentDocument(rfh);
+      if (document_info) {
+        subscription_url = document_info->GetSubscriptionUrl();
+      }
+    }
+
+    auto* web_contents = navigation_handle->GetWebContents();
+    security_interstitials::SecurityInterstitialTabHelper::CreateForWebContents(web_contents);
+
+    std::unique_ptr<AdBlockPage> blocking_page =
+        AdBlockPage::CreateBlockingPage(
+          navigation_handle->GetWebContents(), navigation_handle->GetURL(),
+          subscription_service_,
+          subscription_url);
+    std::string error_page_content = blocking_page->GetHTMLContents();
+
+    base::WeakPtr<content::NavigationHandle> error_page_navigation_handle =
+        web_contents->GetController().LoadPostCommitErrorPage(
+            web_contents->GetPrimaryMainFrame(), url,
+            blocking_page->GetHTMLContents());
+    if (error_page_navigation_handle) {
+      blocking_page->CreatedPostCommitErrorPageNavigation(
+          error_page_navigation_handle.get());
+      security_interstitials::SecurityInterstitialTabHelper::
+          AssociateBlockingPage(error_page_navigation_handle.get(),
+                                std::move(blocking_page));
+    }
+    return;
+  }
+  if (!IsFilteringNeeded(frame, settings_map_)) {
+    return;
+  }
   if (!navigation_handle->IsErrorPage()) {
     // Element hiding for ordinary main frame (or iframe)
     DVLOG(3) << "[eyeo] Ready to inject element hiding to " << url.spec();
diff --git a/components/adblock/content/browser/adblock_webcontents_observer.h b/components/adblock/content/browser/adblock_webcontents_observer.h
--- a/components/adblock/content/browser/adblock_webcontents_observer.h
+++ b/components/adblock/content/browser/adblock_webcontents_observer.h
@@ -23,6 +23,7 @@
 #include "components/adblock/content/browser/frame_hierarchy_builder.h"
 #include "components/adblock/core/sitekey_storage.h"
 #include "components/adblock/core/subscription/subscription_service.h"
+#include "components/content_settings/core/browser/host_content_settings_map.h"
 #include "content/public/browser/web_contents.h"
 #include "content/public/browser/web_contents_observer.h"
 #include "content/public/browser/web_contents_user_data.h"
@@ -53,7 +54,8 @@ class AdblockWebContentObserver
       SitekeyStorage* sitekey_storage,
       std::unique_ptr<FrameHierarchyBuilder> frame_hierarchy_builder,
       base::RepeatingCallback<void(content::RenderFrameHost*)>
-          navigation_counter);
+          navigation_counter,
+      HostContentSettingsMap* settings_map);
   ~AdblockWebContentObserver() override;
   AdblockWebContentObserver(const AdblockWebContentObserver&) = delete;
   AdblockWebContentObserver& operator=(const AdblockWebContentObserver&) =
@@ -86,6 +88,7 @@ class AdblockWebContentObserver
 
   std::unique_ptr<FrameHierarchyBuilder> frame_hierarchy_builder_;
   base::RepeatingCallback<void(content::RenderFrameHost*)> navigation_counter_;
+  raw_ptr<HostContentSettingsMap> settings_map_ = nullptr;
 };
 
 }  // namespace adblock
diff --git a/components/adblock/content/browser/element_hider_impl.cc b/components/adblock/content/browser/element_hider_impl.cc
--- a/components/adblock/content/browser/element_hider_impl.cc
+++ b/components/adblock/content/browser/element_hider_impl.cc
@@ -133,7 +133,7 @@ void GenerateElemHidingEmuJavaScript(const GURL& url,
 }
 
 std::string GenerateXpath3Dep() {
-  static std::string xpath3_dep =
+  std::string xpath3_dep =
       "(" +
       ui::ResourceBundle::GetSharedInstance().LoadDataResourceString(
           IDR_ADBLOCK_SNIPPETS_XPATH3_DEP_JS) +
@@ -155,7 +155,7 @@ void GenerateSnippetScript(const GURL& url,
   serializer.Serialize(std::move(input));
   // snippets_lib should be the library as-is, without any escaping or JSON
   // parsing.
-  static std::string snippets_lib =
+  std::string snippets_lib =
       ui::ResourceBundle::GetSharedInstance().LoadDataResourceString(
           IDR_ADBLOCK_SNIPPETS_JS);
 
@@ -242,7 +242,7 @@ void InsertUserCSSAndApplyElemHidingEmuJS(
   if (!frame_host) {
     // Render frame host was destroyed before element hiding could be applied.
     // This is not a bug, just legitimate a race condition.
-    std::move(on_finished).Run(std::move(input));
+    std::move(on_finished).Run(ElementHider::ElemhideInjectionData{});
     return;
   }
   auto* info = EyeoDocumentInfo::GetOrCreateForCurrentDocument(frame_host);
@@ -263,20 +263,17 @@ void InsertUserCSSAndApplyElemHidingEmuJS(
     frame_host->ExecuteJavaScriptInIsolatedWorld(
         base::UTF8ToUTF16(input.elemhide_js),
         content::RenderFrameHost::JavaScriptResultCallback(),
-        content::ISOLATED_WORLD_ID_ADBLOCK);
+        content::ISOLATED_WORLD_ID_ADBLOCK_VERIFIED);
 
     DVLOG(1) << "[eyeo] Element hiding emulation - executed JS in frame" << " '"
              << frame_host->GetFrameName() << "'";
   }
 
   if (!input.snippet_js.empty()) {
-    // PK: Extension API ends up generating isolated world for injected script
-    // execution. See GetIsolatedWorldIdForInstance in
-    // extensions/renderer/script_injection.cc. Why not to reuse adblock space?
-    frame_host->ExecuteJavaScriptInIsolatedWorld(
+    frame_host->ExecuteJavaScriptForTests(
         base::UTF8ToUTF16(input.snippet_js),
         content::RenderFrameHost::JavaScriptResultCallback(),
-        content::ISOLATED_WORLD_ID_ADBLOCK);
+        content::ISOLATED_WORLD_ID_GLOBAL);
 
     DVLOG(1) << "[eyeo] Snippet - executed JS in frame" << " '"
              << frame_host->GetFrameName() << "'";
@@ -358,7 +355,7 @@ void ElementHiderImpl::HideBlockedElement(
   render_frame_host->ExecuteJavaScriptInIsolatedWorld(
       base::UTF8ToUTF16(js),
       content::RenderFrameHost::JavaScriptResultCallback(),
-      content::ISOLATED_WORLD_ID_ADBLOCK);
+      content::ISOLATED_WORLD_ID_ADBLOCK_VERIFIED);
 
   DVLOG(1) << "[eyeo] Element hiding - executed JS in frame" << " '"
            << render_frame_host->GetFrameName() << "'";
diff --git a/components/adblock/content/browser/eyeo_document_info.cc b/components/adblock/content/browser/eyeo_document_info.cc
--- a/components/adblock/content/browser/eyeo_document_info.cc
+++ b/components/adblock/content/browser/eyeo_document_info.cc
@@ -47,4 +47,19 @@ void EyeoDocumentInfo::SetElementHidingDone() {
   element_hiding_done_ = true;
 }
 
+void EyeoDocumentInfo::SetFilterMatchResult(FilterMatchResult result,
+                                            const GURL& subscription,
+                                            const std::string& configuration_name) {
+  result_ = result;
+  subscription_url_ = subscription;
+}
+
+std::optional<FilterMatchResult> EyeoDocumentInfo::GetFilterMatchResult() const {
+  return result_;
+}
+
+const GURL& EyeoDocumentInfo::GetSubscriptionUrl() const {
+  return subscription_url_;
+}
+
 }  // namespace adblock
diff --git a/components/adblock/content/browser/eyeo_document_info.h b/components/adblock/content/browser/eyeo_document_info.h
--- a/components/adblock/content/browser/eyeo_document_info.h
+++ b/components/adblock/content/browser/eyeo_document_info.h
@@ -19,6 +19,7 @@
 #define COMPONENTS_ADBLOCK_CONTENT_BROWSER_EYEO_DOCUMENT_INFO_H_
 
 #include "content/public/browser/document_user_data.h"
+#include "components/adblock/content/browser/adblock_filter_match.h"
 #include "url/gurl.h"
 
 namespace adblock {
@@ -43,11 +44,19 @@ class EyeoDocumentInfo final
   bool IsElementHidingDone() const;
   void SetElementHidingDone();
 
+  void SetFilterMatchResult(FilterMatchResult result,
+    const GURL& subscription,
+    const std::string& configuration_name);
+  std::optional<FilterMatchResult> GetFilterMatchResult() const;
+  const GURL& GetSubscriptionUrl() const;
+
  private:
   explicit EyeoDocumentInfo(content::RenderFrameHost* rfh);
 
   bool element_hiding_done_ = false;
   GURL pre_commit_url_;
+  std::optional<FilterMatchResult> result_;
+  GURL subscription_url_;
 
   friend DocumentUserData;
   DOCUMENT_USER_DATA_KEY_DECL();
diff --git a/components/adblock/content/browser/factories/adblock_request_throttle_factory.cc b/components/adblock/content/browser/factories/adblock_request_throttle_factory.cc
--- a/components/adblock/content/browser/factories/adblock_request_throttle_factory.cc
+++ b/components/adblock/content/browser/factories/adblock_request_throttle_factory.cc
@@ -56,7 +56,7 @@ AdblockRequestThrottleFactory::BuildServiceInstanceForBrowserContext(
       base::CommandLine::ForCurrentProcess()->HasSwitch(
           adblock::switches::kDisableEyeoRequestThrottling)
           ? base::TimeDelta()
-          : base::Seconds(30);
+          : base::Seconds(5);
   throttle->AllowRequestsAfter(initial_delay);
   return std::move(throttle);
 }
diff --git a/components/adblock/content/browser/factories/adblock_telemetry_service_factory.cc b/components/adblock/content/browser/factories/adblock_telemetry_service_factory.cc
--- a/components/adblock/content/browser/factories/adblock_telemetry_service_factory.cc
+++ b/components/adblock/content/browser/factories/adblock_telemetry_service_factory.cc
@@ -45,13 +45,6 @@ base::TimeDelta GetCheckInterval() {
 
 }  // namespace
 
-// static
-AdblockTelemetryService* AdblockTelemetryServiceFactory::GetForBrowserContext(
-    content::BrowserContext* context) {
-  return static_cast<AdblockTelemetryService*>(
-      GetInstance()->GetServiceForBrowserContext(context, true));
-}
-
 // static
 AdblockTelemetryServiceFactory* AdblockTelemetryServiceFactory::GetInstance() {
   static base::NoDestructor<AdblockTelemetryServiceFactory> instance;
diff --git a/components/adblock/content/browser/factories/embedding_utils.cc b/components/adblock/content/browser/factories/embedding_utils.cc
--- a/components/adblock/content/browser/factories/embedding_utils.cc
+++ b/components/adblock/content/browser/factories/embedding_utils.cc
@@ -20,7 +20,6 @@
 #include <memory>
 
 #include "components/adblock/content/browser/adblock_webcontents_observer.h"
-#include "components/adblock/content/browser/factories/adblock_telemetry_service_factory.h"
 #include "components/adblock/content/browser/factories/content_security_policy_injector_factory.h"
 #include "components/adblock/content/browser/factories/element_hider_factory.h"
 #include "components/adblock/content/browser/factories/resource_classification_runner_factory.h"
@@ -34,7 +33,6 @@ namespace adblock {
 
 void EnsureBackgroundServicesStarted(content::BrowserContext* browser_context) {
   ResourceClassificationRunnerFactory::GetForBrowserContext(browser_context);
-  AdblockTelemetryServiceFactory::GetForBrowserContext(browser_context);
   SessionStatsFactory::GetForBrowserContext(browser_context);
   SitekeyStorageFactory::GetForBrowserContext(browser_context);
 }
diff --git a/components/adblock/content/browser/factories/embedding_utils.h b/components/adblock/content/browser/factories/embedding_utils.h
--- a/components/adblock/content/browser/factories/embedding_utils.h
+++ b/components/adblock/content/browser/factories/embedding_utils.h
@@ -23,6 +23,7 @@
 #include "components/adblock/content/browser/factories/subscription_service_factory.h"
 #include "components/adblock/content/browser/frame_hierarchy_builder.h"
 #include "components/adblock/content/browser/page_view_stats.h"
+#include "components/content_settings/core/browser/host_content_settings_map.h"
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/web_contents.h"
 
@@ -32,13 +33,15 @@ namespace adblock {
 template <typename ObserverClass>
 void RegisterAdblockWebContentObserver(
     content::WebContents* web_contents,
-    content::BrowserContext* browser_context) {
+    content::BrowserContext* browser_context,
+    HostContentSettingsMap* settings_map) {
   ObserverClass::CreateForWebContents(
       web_contents,
       SubscriptionServiceFactory::GetForBrowserContext(browser_context),
       ElementHiderFactory::GetForBrowserContext(browser_context),
       SitekeyStorageFactory::GetForBrowserContext(browser_context),
-      std::make_unique<FrameHierarchyBuilder>(), CountNavigationsCallback());
+      std::make_unique<FrameHierarchyBuilder>(), CountNavigationsCallback(),
+      settings_map);
 }
 
 // Ensures that all background services are started for the given browser
diff --git a/components/adblock/content/browser/factories/subscription_service_factory.cc b/components/adblock/content/browser/factories/subscription_service_factory.cc
--- a/components/adblock/content/browser/factories/subscription_service_factory.cc
+++ b/components/adblock/content/browser/factories/subscription_service_factory.cc
@@ -23,6 +23,7 @@
 #include <vector>
 
 #include "absl/types/optional.h"
+#include "base/rand_util.h"
 #include "base/command_line.h"
 #include "base/files/file_util.h"
 #include "base/functional/bind.h"
@@ -65,7 +66,7 @@ base::TimeDelta GetUpdateCheckInterval() {
   static base::TimeDelta kCheckInterval =
       g_update_check_interval_for_testing
           ? g_update_check_interval_for_testing.value()
-          : base::Hours(1);
+          : base::Hours(12) + base::Minutes(base::RandInt(-60,60));
   return kCheckInterval;
 }
 
@@ -93,7 +94,8 @@ std::unique_ptr<AdblockResourceRequest> MakeSubscriptionRequest(
 ConversionResult ConvertFilterFile(
     const scoped_refptr<FlatbufferConverter>& converter,
     const GURL& subscription_url,
-    const base::FilePath& path) {
+    const base::FilePath& path,
+    bool allow_privileged_filter) {
   TRACE_EVENT1("eyeo", "ConvertFileToFlatbuffer", "url",
                subscription_url.spec());
   ConversionResult result;
@@ -105,7 +107,7 @@ ConversionResult ConvertFilterFile(
   } else {
     result =
         converter->Convert(input_stream, subscription_url,
-                           config::AllowPrivilegedFilters(subscription_url));
+          allow_privileged_filter && config::AllowPrivilegedFilters(subscription_url));
   }
   base::DeleteFile(path);
   return result;
@@ -167,6 +169,7 @@ void CleanupPersistedConfiguration(PrefService* prefs,
 
 void InstallFirstRunDefaultAdblockSubscription(
     std::unique_ptr<FilteringConfiguration>& adblock_filtering_configuration) {
+  if ((true)) return;
   if (std::ranges::any_of(config::GetKnownSubscriptions(),
                            [&](const KnownSubscriptionInfo& subscription) {
                              return subscription.url ==
@@ -188,16 +191,8 @@ bool InstallFirstRunAdblockSubscriptionsCheckingLocale(
   bool language_specific_subscription_installed = false;
   // On first run, install additional subscriptions.
   for (const auto& subscription : adblock::config::GetKnownSubscriptions()) {
-    if (subscription.first_run == SubscriptionFirstRunBehavior::Subscribe) {
+    if (subscription.first_run == SubscriptionFirstRunBehavior::SubscribeAtFirstRun) {
       adblock_filtering_configuration->AddFilterList(subscription.url);
-    } else if (subscription.first_run ==
-                   SubscriptionFirstRunBehavior::SubscribeIfLocaleMatch &&
-               std::find(subscription.languages.begin(),
-                         subscription.languages.end(),
-                         language) != subscription.languages.end()) {
-      VLOG(1) << "[eyeo] Using recommended subscription for language \""
-              << language << "\": " << subscription.title;
-      language_specific_subscription_installed = true;
       adblock_filtering_configuration->AddFilterList(subscription.url);
     }
   }
@@ -451,11 +446,12 @@ SubscriptionServiceFactory::ConvertCustomFilters(
 void SubscriptionServiceFactory::ConvertFilterListFile(
     const GURL& subscription_url,
     const base::FilePath& path,
+    bool allow_privileged_filter,
     base::OnceCallback<void(ConversionResult)> result_callback) const {
   base::ThreadPool::PostTaskAndReplyWithResult(
       FROM_HERE, {base::MayBlock()},
       base::BindOnce(&ConvertFilterFile, flatbuffer_converter_,
-                     subscription_url, path),
+                     subscription_url, path, allow_privileged_filter),
       std::move(result_callback));
 }
 
diff --git a/components/adblock/content/browser/factories/subscription_service_factory.h b/components/adblock/content/browser/factories/subscription_service_factory.h
--- a/components/adblock/content/browser/factories/subscription_service_factory.h
+++ b/components/adblock/content/browser/factories/subscription_service_factory.h
@@ -43,6 +43,7 @@ class SubscriptionServiceFactory : public BrowserContextKeyedServiceFactory,
   void ConvertFilterListFile(
       const GURL& subscription_url,
       const base::FilePath& path,
+      bool allow_privileged_filter,
       base::OnceCallback<void(ConversionResult)>) const override;
 
  protected:
diff --git a/components/adblock/content/browser/frame_hierarchy_builder.cc b/components/adblock/content/browser/frame_hierarchy_builder.cc
--- a/components/adblock/content/browser/frame_hierarchy_builder.cc
+++ b/components/adblock/content/browser/frame_hierarchy_builder.cc
@@ -66,6 +66,7 @@ GURL GetUrlAsReferrer(content::RenderFrameHost* frame_host) {
 std::vector<GURL> BuildFrameHierarchyForRenderFrameHost(
     content::RenderFrameHost* frame_host) {
   std::vector<GURL> frame_hierarchy;
+  if (!frame_host) return frame_hierarchy;
   for (auto* iter = frame_host; iter; iter = iter->GetParent()) {
     auto last_commited_referrer = GetUrlAsReferrer(iter);
     if (IsValidForFrameHierarchy(last_commited_referrer)) {
diff --git a/components/adblock/content/browser/page_view_stats.cc b/components/adblock/content/browser/page_view_stats.cc
--- a/components/adblock/content/browser/page_view_stats.cc
+++ b/components/adblock/content/browser/page_view_stats.cc
@@ -57,47 +57,26 @@ const char kBlockedStatsCountKey[] = "blocked_pageviews";
 // than AA page views.
 const char kTotalPagesStatsCountKey[] = "pageviews";
 
-std::string_view GetReportedNameForMetric(PageViewStats::Metric metric) {
-  switch (metric) {
-    case PageViewStats::Metric::AcceptableAds:
-      return kAcceptableAdsStatsCountKey;
-    case PageViewStats::Metric::AcceptableAdsBlockThrough:
-      return kAcceptableAdsBlockthroughStatsCountKey;
-    case PageViewStats::Metric::Allowing:
-      return kAllowedStatsCountKey;
-    case PageViewStats::Metric::Blocking:
-      return kBlockedStatsCountKey;
-    case PageViewStats::Metric::TotalPages:
-      return kTotalPagesStatsCountKey;
-  }
+base::WeakPtr<PageViewStats>& GetLastUsedInstance() {
+  static base::NoDestructor<base::WeakPtr<PageViewStats>> instance;
+  return *instance;
 }
 
-base::WeakPtr<PageViewStats> g_last_used_instance;
-
 void RegisterNavigationWithLastUsedPageViewStats(
     content::RenderFrameHost* render_frame_host) {
-  if (g_last_used_instance) {
-    g_last_used_instance->RegisterMainFrameNavigation(render_frame_host);
+  if (GetLastUsedInstance()) {
+    GetLastUsedInstance()->RegisterMainFrameNavigation(render_frame_host);
   }
 }
 
 void RegisterAcceptableAdsBlockthroughtHitWithLastUsedPageViewStats(
     content::RenderFrameHost* render_frame_host) {
-  if (g_last_used_instance) {
-    g_last_used_instance->RegisterAcceptableAdsBlockthroughtHit(
+  if (GetLastUsedInstance()) {
+    GetLastUsedInstance()->RegisterAcceptableAdsBlockthroughtHit(
         render_frame_host);
   }
 }
 
-inline bool WasNavigationCommitted(PageViewStats::Metric metric,
-                                   EyeoPageInfo* page_info) {
-  return page_info->HasMatchedPageView(PageViewStats::Metric::TotalPages);
-}
-
-inline bool IsNavigationCommittingNow(PageViewStats::Metric metric) {
-  return metric == PageViewStats::Metric::TotalPages;
-}
-
 }  // namespace
 
 PageViewStats::PageViewStats(
@@ -107,7 +86,6 @@ PageViewStats::PageViewStats(
   DCHECK(classification_runner_);
   DCHECK(prefs_);
   classification_runner_->AddObserver(this);
-  g_last_used_instance = weak_factory_.GetWeakPtr();
 }
 
 PageViewStats::~PageViewStats() {
@@ -215,22 +193,6 @@ void PageViewStats::RecordParkedMetrics(content::Page& page) {
     }
     // If this is the entry matching Page we are looking for...
     if (main_frame_id == it->first) {
-      // ...and it contains some parked metrics...
-      if (!it->second.empty()) {
-        //...then record them
-        auto* page_info = EyeoPageInfo::GetOrCreateForPage(page);
-        ScopedDictPrefUpdate update(prefs_,
-                                    common::prefs::kTelemetryPageViewStats);
-        for (auto parked_metric : it->second) {
-          auto parked_metric_key = GetReportedNameForMetric(parked_metric);
-          const auto current_count_for_parked =
-              update->FindInt(parked_metric_key);
-          update->Set(parked_metric_key,
-                      current_count_for_parked.value_or(0) + 1);
-          // Now with "final" EyeoPageInfo we can mark metric as recorded
-          page_info->SetMatchedPageView(parked_metric);
-        }
-      }
       it = parked_metrics_before_main_navigation_.erase(it);
     } else {
       ++it;
@@ -239,42 +201,13 @@ void PageViewStats::RecordParkedMetrics(content::Page& page) {
 }
 
 void PageViewStats::RecordPageView(content::Page& page, Metric metric) {
-  auto dict_child_key = GetReportedNameForMetric(metric);
-  auto* page_info = EyeoPageInfo::GetOrCreateForPage(page);
-  if (!IsNavigationCommittingNow(metric) &&
-      !WasNavigationCommitted(metric, page_info)) {
-    ParkMetric(page, metric);
-    return;
-  }
-  // We don't count stats metrics for individual requests but for a whole page.
-  // If this is the first request matched a metric for this page, we increment
-  // the counter. We store previous matches in EyeoPageInfo, so we can check if
-  // this is the first metric match for this page.
-  if (!page_info->SetMatchedPageView(metric)) {
-    // metric was already counted
-    return;
-  }
-  ScopedDictPrefUpdate update(prefs_, common::prefs::kTelemetryPageViewStats);
-  const auto current_count = update->FindInt(dict_child_key);
-  update->Set(dict_child_key, current_count.value_or(0) + 1);
-  // Check parked metrics and record
-  if (WasNavigationCommitted(metric, page_info)) {
-    RecordParkedMetrics(page);
-  }
 }
 
 int PageViewStats::GetPageViewsCount(Metric metric) const {
-  auto dict_child_key = GetReportedNameForMetric(metric);
-  const base::Value::Dict& dict =
-      prefs_->GetDict(common::prefs::kTelemetryPageViewStats);
-  const auto current_count = dict.FindInt(dict_child_key);
-  return current_count.value_or(0);
+  return 0;
 }
 
 void PageViewStats::ResetPageViewsCount(Metric metric) {
-  auto dict_child_key = GetReportedNameForMetric(metric);
-  ScopedDictPrefUpdate update(prefs_, common::prefs::kTelemetryPageViewStats);
-  update->Set(dict_child_key, 0);
 }
 
 base::RepeatingCallback<void(content::RenderFrameHost*)>
diff --git a/components/adblock/content/browser/resource_classification_runner.h b/components/adblock/content/browser/resource_classification_runner.h
--- a/components/adblock/content/browser/resource_classification_runner.h
+++ b/components/adblock/content/browser/resource_classification_runner.h
@@ -77,9 +77,16 @@ class ResourceClassificationRunner : public KeyedService {
       const GURL& popup_url,
       content::RenderFrameHost& render_frame_host,
       CheckFilterMatchCallback callback) = 0;
+  virtual void CheckRequestFilterMatchForWebTransport(
+      SubscriptionService::Snapshot subscription_collections,
+      const GURL& request_url,
+      const RequestInitiator& request_initiator,
+      content::GlobalRenderFrameHostId render_frame_host_id,
+      CheckFilterMatchCallback callback) = 0;
   virtual void CheckRequestFilterMatch(
       SubscriptionService::Snapshot subscription_collections,
       const GURL& request_url,
+      const std::vector<std::string>& dns_aliases,
       ContentType adblock_resource_type,
       const RequestInitiator& request_initiator,
       CheckFilterMatchCallback callback) = 0;
diff --git a/components/adblock/content/browser/resource_classification_runner_impl.cc b/components/adblock/content/browser/resource_classification_runner_impl.cc
--- a/components/adblock/content/browser/resource_classification_runner_impl.cc
+++ b/components/adblock/content/browser/resource_classification_runner_impl.cc
@@ -21,6 +21,7 @@
 #include "base/task/task_traits.h"
 #include "base/task/thread_pool.h"
 #include "base/trace_event/trace_event.h"
+#include "components/adblock/content/browser/eyeo_document_info.h"
 #include "components/adblock/content/browser/frame_opener_info.h"
 #include "components/adblock/content/browser/request_initiator.h"
 #include "components/adblock/core/common/sitekey.h"
@@ -156,6 +157,19 @@ void ResourceClassificationRunnerImpl::CheckPopupFilterMatch(
           render_frame_host.GetGlobalId(), std::move(callback)));
 }
 
+void ResourceClassificationRunnerImpl::CheckRequestFilterMatchForWebTransport(
+    SubscriptionService::Snapshot subscription_collections,
+    const GURL& request_url,
+    const RequestInitiator& request_initiator,
+    content::GlobalRenderFrameHostId render_frame_host_id,
+    CheckFilterMatchCallback callback) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  std::vector<std::string> dns_aliases;
+  CheckRequestFilterMatch(std::move(subscription_collections), request_url, std::move(dns_aliases),
+                          ContentType::Other, request_initiator,
+                          std::move(callback));
+}
+
 void ResourceClassificationRunnerImpl::CheckDocumentAllowlisted(
     SubscriptionService::Snapshot subscription_collections,
     const GURL& request_url,
@@ -208,6 +222,7 @@ void ResourceClassificationRunnerImpl::ProcessDocumentAllowlistedResponse(
 void ResourceClassificationRunnerImpl::CheckRequestFilterMatch(
     SubscriptionService::Snapshot subscription_collections,
     const GURL& request_url,
+    const std::vector<std::string>& dns_aliases,
     ContentType adblock_resource_type,
     const RequestInitiator& request_initiator,
     CheckFilterMatchCallback callback) {
@@ -234,7 +249,7 @@ void ResourceClassificationRunnerImpl::CheckRequestFilterMatch(
       base::BindOnce(
           &ResourceClassificationRunnerImpl::CheckRequestFilterMatchInternal,
           resource_classifier_, std::move(subscription_collections),
-          request_url, frame_hierarchy, adblock_resource_type,
+          request_url, std::move(dns_aliases), frame_hierarchy, adblock_resource_type,
           std::move(site_key)),
       base::BindOnce(
           &ResourceClassificationRunnerImpl::OnCheckResourceFilterMatchComplete,
@@ -248,9 +263,16 @@ ResourceClassificationRunnerImpl::CheckRequestFilterMatchInternal(
     const scoped_refptr<ResourceClassifier>& resource_classifier,
     SubscriptionService::Snapshot subscription_collections,
     const GURL request_url,
+    const std::vector<std::string>& dns_aliases,
     const std::vector<GURL> frame_hierarchy,
     ContentType adblock_resource_type,
     const SiteKey sitekey) {
+  std::vector<std::string> aliases;
+  aliases.push_back(request_url.GetHost());
+  for (const std::string& alias : dns_aliases) {
+    aliases.push_back(alias);
+  }
+
   TRACE_EVENT1("eyeo",
                "ResourceClassificationRunnerImpl::"
                "CheckRequestFilterMatchInternal",
@@ -258,26 +280,35 @@ ResourceClassificationRunnerImpl::CheckRequestFilterMatchInternal(
 
   DVLOG(1) << "[eyeo] CheckRequestFilterMatchInternal start";
 
-  auto classification_result = resource_classifier->ClassifyRequest(
-      std::move(subscription_collections), request_url, frame_hierarchy,
-      adblock_resource_type, sitekey);
-
-  if (classification_result.decision == ClassificationDecision::Allowed) {
-    VLOG(1) << "[eyeo] Resource allowed due to allowing filter " << request_url;
-    return CheckResourceFilterMatchResult{
-        FilterMatchResult::kAllowRule,
-        classification_result.decisive_subscription,
-        classification_result.decisive_configuration_name};
-  }
+  GURL alias_url = request_url;
+  for (const std::string& alias : aliases) {
+    GURL::Replacements replace_host;
+    replace_host.SetHostStr(alias);
+    alias_url = request_url.ReplaceComponents(replace_host);
+
+    auto classification_result = resource_classifier->ClassifyRequest(
+        std::move(subscription_collections), alias_url, frame_hierarchy,
+        adblock_resource_type, sitekey);
+
+    if (classification_result.decision == ClassificationDecision::Allowed) {
+      VLOG(1) << "[eyeo] Resource allowed due to allowing filter " << alias_url
+              << " " << classification_result.decisive_subscription.spec();
+      return CheckResourceFilterMatchResult{
+          FilterMatchResult::kAllowRule,
+          classification_result.decisive_subscription,
+          classification_result.decisive_configuration_name};
+    }
 
-  if (classification_result.decision == ClassificationDecision::Blocked) {
-    VLOG(1) << "[eyeo] Resource blocked " << request_url;
-    return CheckResourceFilterMatchResult{
-        FilterMatchResult::kBlockRule,
-        classification_result.decisive_subscription,
-        classification_result.decisive_configuration_name};
+    if (classification_result.decision == ClassificationDecision::Blocked) {
+      VLOG(1) << "[eyeo] Resource blocked " << alias_url;
+      return CheckResourceFilterMatchResult{
+          FilterMatchResult::kBlockRule,
+          classification_result.decisive_subscription,
+          classification_result.decisive_configuration_name};
+    }
   }
 
+  VLOG(1) << "[eyeo] No Rule for " << request_url;
   return CheckResourceFilterMatchResult{FilterMatchResult::kNoRule, {}, {}};
 }
 
@@ -320,7 +351,9 @@ void ResourceClassificationRunnerImpl::NotifyResourceMatched(
     // The frame has been destroyed, so we can't notify observers.
     return;
   }
-
+  EyeoDocumentInfo* document_info =
+    EyeoDocumentInfo::GetOrCreateForCurrentDocument(render_frame_host);
+  document_info->SetFilterMatchResult(result, subscription, configuration_name);
   for (auto& observer : observers_) {
     observer.OnRequestMatched(
         url, result, parent_frame_urls, static_cast<ContentType>(content_type),
diff --git a/components/adblock/content/browser/resource_classification_runner_impl.h b/components/adblock/content/browser/resource_classification_runner_impl.h
--- a/components/adblock/content/browser/resource_classification_runner_impl.h
+++ b/components/adblock/content/browser/resource_classification_runner_impl.h
@@ -56,6 +56,7 @@ class ResourceClassificationRunnerImpl final
   void CheckRequestFilterMatch(
       SubscriptionService::Snapshot subscription_collections,
       const GURL& request_url,
+      const std::vector<std::string>& dns_aliases,
       ContentType adblock_resource_type,
       const RequestInitiator& request_initiator,
       CheckFilterMatchCallback callback) final;
@@ -64,6 +65,12 @@ class ResourceClassificationRunnerImpl final
       SubscriptionService::Snapshot subscription_collections,
       const GURL& request_url,
       const RequestInitiator& request_initiator) final;
+  void CheckRequestFilterMatchForWebTransport(
+      SubscriptionService::Snapshot subscription_collections,
+      const GURL& request_url,
+      const RequestInitiator& request_initiator,
+      content::GlobalRenderFrameHostId render_frame_host_id,
+      CheckFilterMatchCallback callback) final;
   void CheckResponseFilterMatch(
       SubscriptionService::Snapshot subscription_collections,
       const GURL& response_url,
@@ -88,6 +95,7 @@ class ResourceClassificationRunnerImpl final
       const scoped_refptr<ResourceClassifier>& resource_classifier,
       SubscriptionService::Snapshot subscription_collections,
       const GURL request_url,
+      const std::vector<std::string>& dns_aliases,
       const std::vector<GURL> frame_hierarchy,
       ContentType adblock_resource_type,
       const SiteKey sitekey);
diff --git a/components/adblock/core/BUILD.gn b/components/adblock/core/BUILD.gn
--- a/components/adblock/core/BUILD.gn
+++ b/components/adblock/core/BUILD.gn
@@ -14,7 +14,6 @@
 # You should have received a copy of the GNU General Public License
 # along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
 
-import("//components/adblock/features.gni")
 import("//third_party/flatbuffers/flatbuffer.gni")
 
 flatbuffer("schema") {
@@ -49,43 +48,9 @@ source_set("schema_hash") {
   deps = [ ":generate_schema_hash" ]
 }
 
-config("eyeo_telemetry_config") {
-  defines = []
-
-  if (eyeo_telemetry_server_url != "") {
-    # Explicitly setting Telemetry server URL, used for testing with a test
-    # server.
-    defines += [ "EYEO_TELEMETRY_SERVER_URL=\"$eyeo_telemetry_server_url\"" ]
-  } else {
-    # Implicitly setting production Telemetry server URL based on
-    # eyeo_telemetry_client_id (or a default client id as a fallback).
-    if (eyeo_telemetry_client_id != "") {
-      defines += [ "EYEO_TELEMETRY_CLIENT_ID=\"$eyeo_telemetry_client_id\"" ]
-    } else {
-      print("WARNING! gn arg eyeo_telemetry_client_id is not set. " +
-            "Users will not be counted correctly by eyeo.")
-      eyeo_telemetry_client_id = "eyeochromium"
-    }
-    eyeo_telemetry_server_url =
-        "https://${eyeo_telemetry_client_id}.telemetry.eyeo.com/"
-    defines += [ "EYEO_TELEMETRY_SERVER_URL=\"$eyeo_telemetry_server_url\"" ]
-  }
-
-  if (eyeo_telemetry_activeping_auth_token != "") {
-    defines += [ "EYEO_TELEMETRY_ACTIVEPING_AUTH_TOKEN=\"$eyeo_telemetry_activeping_auth_token\"" ]
-  } else {
-    print("WARNING! gn arg eyeo_telemetry_activeping_auth_token is not set. " +
-          "Users will not be counted correctly by eyeo.")
-  }
-}
-
 source_set("core") {
   output_name = "adblock_core"
   sources = [
-    "activeping_telemetry_topic_provider.cc",
-    "activeping_telemetry_topic_provider.h",
-    "adblock_telemetry_service.cc",
-    "adblock_telemetry_service.h",
     "features.cc",
     "features.h",
     "sitekey_storage.h",
@@ -109,8 +74,6 @@ source_set("core") {
     "//components/prefs",
     "//components/version_info",
   ]
-
-  configs += [ ":eyeo_telemetry_config" ]
 }
 
 source_set("test_support") {
@@ -151,6 +114,4 @@ source_set("unit_tests") {
     "//services/network:test_support",
     "//testing/gtest",
   ]
-
-  configs += [ ":eyeo_telemetry_config" ]
 }
diff --git a/components/adblock/core/common/BUILD.gn b/components/adblock/core/common/BUILD.gn
--- a/components/adblock/core/common/BUILD.gn
+++ b/components/adblock/core/common/BUILD.gn
@@ -34,14 +34,6 @@ config("eyeo_filtering_config") {
 
 config("eyeo_application_config") {
   defines = []
-
-  if (eyeo_application_name != "") {
-    defines += [ "EYEO_APPLICATION_NAME=\"$eyeo_application_name\"" ]
-  }
-
-  if (eyeo_application_version != "") {
-    defines += [ "EYEO_APPLICATION_VERSION=\"$eyeo_application_version\"" ]
-  }
 }
 
 source_set("common") {
diff --git a/components/adblock/core/common/adblock_constants.cc b/components/adblock/core/common/adblock_constants.cc
--- a/components/adblock/core/common/adblock_constants.cc
+++ b/components/adblock/core/common/adblock_constants.cc
@@ -17,14 +17,13 @@
 
 #include "components/adblock/core/common/adblock_constants.h"
 
+#include "base/no_destructor.h"
 #include "base/base64.h"
 #include "components/adblock/core/schema/filter_list_schema_generated.h"
 #include "components/adblock/core/schema/schema_hash.h"
 
 namespace adblock {
 
-const char kSiteKeyHeaderKey[] = "x-adblock-key";
-
 const char kAllowlistEverythingFilter[] = "@@*$document";
 
 const char kAdblockFilteringConfigurationName[] = "adblock";
@@ -108,20 +107,20 @@ const char kBlankPng32x32[] =
     "3BAQEAAACCIP+vbkhAAQAAAO8GECAAAZf3V9cAAAAASUVORK5CYII=";
 
 const std::string& CurrentSchemaVersion() {
-  static std::string kCurrentSchemaVersion =
-      base::Base64Encode(kSha256_filter_list_schema_generated_h);
-  return kCurrentSchemaVersion;
+  static const base::NoDestructor<std::string> kCurrentSchemaVersion(
+      base::Base64Encode(kSha256_filter_list_schema_generated_h));
+  return *kCurrentSchemaVersion;
 }
 
 const GURL& TestPagesSubscriptionUrl() {
-  static GURL kTestPagesUrl(
+  static const base::NoDestructor<GURL> kTestPagesUrl(
       "https://abptestpages.org/en/abp-testcase-subscription.txt");
-  return kTestPagesUrl;
+  return *kTestPagesUrl;
 }
 
 const GURL& CustomFiltersUrl() {
-  static GURL kCustomFiltersUrl("adblock:custom");
-  return kCustomFiltersUrl;
+  static const base::NoDestructor<GURL> kCustomFiltersUrl("adblock:custom");
+  return *kCustomFiltersUrl;
 }
 
 std::string_view RewriteUrl(flat::AbpResource type) {
diff --git a/components/adblock/core/common/adblock_constants.h b/components/adblock/core/common/adblock_constants.h
--- a/components/adblock/core/common/adblock_constants.h
+++ b/components/adblock/core/common/adblock_constants.h
@@ -29,7 +29,6 @@ namespace flat {
 enum AbpResource : int8_t;
 }
 
-extern const char kSiteKeyHeaderKey[];
 extern const char kAllowlistEverythingFilter[];
 extern const char kAdblockFilteringConfigurationName[];
 
diff --git a/components/adblock/core/common/adblock_prefs.cc b/components/adblock/core/common/adblock_prefs.cc
--- a/components/adblock/core/common/adblock_prefs.cc
+++ b/components/adblock/core/common/adblock_prefs.cc
@@ -17,13 +17,16 @@
 
 #include "components/adblock/core/common/adblock_prefs.h"
 
+#include "base/no_destructor.h"
 #include "base/logging.h"
 #include "components/prefs/pref_registry_simple.h"
 
 namespace adblock::common::prefs {
 
 // Legacy: Whether to block ads
-const char kEnableAdblockLegacy[] = "adblock.enable";
+const char kEnableAdblockLegacy[] = "adblock.enabled";
+
+const char kAllowPrivilegedFilters[] = "adblock.privilegedfilters_enabled";
 
 // Legacy: Whether to allow acceptable ads or block them all.
 // Used now just to map CLI switch. Otherwise use kAdblockSubscriptionsLegacy.
@@ -65,35 +68,6 @@ const char kLastUsedSchemaVersion[] = "adblock.last_used_schema_version";
 // and for setting query parameters in subscription download requests.
 const char kSubscriptionMetadata[] = "adblock.subscription_metadata";
 
-// Client-generated UUID4 that uniquely identifies the server response that
-// sent kTelemetryLastPingTime. Sent along with other ping times to
-// disambiguate between other clients who send ping requests the same day.
-// Regenerated on every successful response.
-const char kTelemetryLastPingTag[] =
-    "adblock.telemetry.activeping.last_ping_tag";
-
-// Server UTC time of last ping response, updated with every successful
-// response. Shall not be compared to client time (even UTC). Sent by the
-// telemetry server, stored as unparsed string (ex. "2022-02-08T09:30:00Z").
-const char kTelemetryLastPingTime[] =
-    "adblock.telemetry.activeping.last_ping_time";
-
-// Previous last ping time, gets replaced by kTelemetryLastPingTime when a new
-// successful ping response arrives. Sent in a ping request.
-const char kTelemetryPreviousLastPingTime[] =
-    "adblock.telemetry.activeping.previous_last_ping_time";
-
-// Time of first recorded response for a telemetry ping request, sent along
-// with future ping requests, to further disambiguate
-// user-counting without being able to uniquely track a user.
-const char kTelemetryFirstPingTime[] =
-    "adblock.telemetry.activeping.first_ping_time";
-
-// Client time, when to perform the next ping?
-// Not sent, used locally to ensure we don't ping too often.
-const char kTelemetryNextPingTime[] =
-    "adblock.telemetry.activeping.next_ping_time";
-
 // FilteringConfiguration data
 const char kConfigurationsPrefsPath[] = "filtering.configurations";
 
@@ -106,21 +80,12 @@ const char kAutoInstalledSubscriptionsNextUpdateTime[] =
     "adblock.auto_installed_subscriptions.last_update_time";
 
 // Dict containing stats about acceptable ads page views
-const char kTelemetryPageViewStats[] = "adblock.telemetry.page_view_stats";
-
-void RegisterTelemetryPrefs(PrefRegistrySimple* registry) {
-  registry->RegisterStringPref(kTelemetryLastPingTag, "");
-  registry->RegisterStringPref(kTelemetryLastPingTime, "");
-  registry->RegisterStringPref(kTelemetryPreviousLastPingTime, "");
-  registry->RegisterStringPref(kTelemetryFirstPingTime, "");
-  registry->RegisterTimePref(kTelemetryNextPingTime, base::Time());
-  registry->RegisterDictionaryPref(kTelemetryPageViewStats);
-}
 
 void RegisterProfilePrefs(PrefRegistrySimple* registry) {
+  registry->RegisterBooleanPref(kAllowPrivilegedFilters, false);
   registry->RegisterBooleanPref(kEnableAdblockLegacy, true);
-  registry->RegisterBooleanPref(kEnableAcceptableAdsLegacy, true);
-  registry->RegisterBooleanPref(kAdblockMoreOptionsEnabled, false);
+  registry->RegisterBooleanPref(kEnableAcceptableAdsLegacy, false);
+  registry->RegisterBooleanPref(kAdblockMoreOptionsEnabled, true);
   registry->RegisterListPref(kAdblockAllowedDomainsLegacy, {});
   registry->RegisterListPref(kAdblockCustomFiltersLegacy, {});
   registry->RegisterListPref(kAdblockSubscriptionsLegacy, {});
@@ -130,17 +95,16 @@ void RegisterProfilePrefs(PrefRegistrySimple* registry) {
   registry->RegisterStringPref(kLastUsedSchemaVersion, "");
   registry->RegisterDictionaryPref(kSubscriptionMetadata);
   registry->RegisterDictionaryPref(kConfigurationsPrefsPath);
-  registry->RegisterBooleanPref(kEnableAutoInstalledSubscriptions, true);
+  registry->RegisterBooleanPref(kEnableAutoInstalledSubscriptions, false);
   // Set to |now| so the first update happens ASAP
   registry->RegisterTimePref(kAutoInstalledSubscriptionsNextUpdateTime,
                              base::Time::Now());
-  RegisterTelemetryPrefs(registry);
 
   VLOG(3) << "[eyeo] Registered prefs";
 }
 
-std::vector<std::string_view> GetPrefs() {
-  static std::vector<std::string_view> prefs = {
+const std::vector<std::string_view>& GetPrefs() {
+  static const base::NoDestructor<std::vector<std::string_view>> prefs({
       kEnableAdblockLegacy,
       kEnableAcceptableAdsLegacy,
       kAdblockMoreOptionsEnabled,
@@ -152,16 +116,10 @@ std::vector<std::string_view> GetPrefs() {
       kSubscriptionSignatures,
       kLastUsedSchemaVersion,
       kSubscriptionMetadata,
-      kTelemetryLastPingTag,
-      kTelemetryLastPingTime,
-      kTelemetryPreviousLastPingTime,
-      kTelemetryFirstPingTime,
-      kTelemetryNextPingTime,
-      kTelemetryPageViewStats,
       kConfigurationsPrefsPath,
       kEnableAutoInstalledSubscriptions,
-      kAutoInstalledSubscriptionsNextUpdateTime};
-  return prefs;
+      kAutoInstalledSubscriptionsNextUpdateTime});
+  return *prefs;
 }
 
 }  // namespace adblock::common::prefs
diff --git a/components/adblock/core/common/adblock_prefs.h b/components/adblock/core/common/adblock_prefs.h
--- a/components/adblock/core/common/adblock_prefs.h
+++ b/components/adblock/core/common/adblock_prefs.h
@@ -26,6 +26,7 @@ class PrefRegistrySimple;
 namespace adblock::common::prefs {
 
 extern const char kEnableAdblockLegacy[];
+extern const char kAllowPrivilegedFilters[];
 extern const char kEnableAcceptableAdsLegacy[];
 extern const char kAdblockAllowedDomainsLegacy[];
 extern const char kAdblockCustomFiltersLegacy[];
@@ -36,19 +37,13 @@ extern const char kInstallFirstStartSubscriptions[];
 extern const char kSubscriptionSignatures[];
 extern const char kLastUsedSchemaVersion[];
 extern const char kSubscriptionMetadata[];
-extern const char kTelemetryLastPingTag[];
-extern const char kTelemetryLastPingTime[];
-extern const char kTelemetryPreviousLastPingTime[];
-extern const char kTelemetryFirstPingTime[];
-extern const char kTelemetryNextPingTime[];
-extern const char kTelemetryPageViewStats[];
 extern const char kConfigurationsPrefsPath[];
 extern const char kEnableAutoInstalledSubscriptions[];
 extern const char kAutoInstalledSubscriptionsNextUpdateTime[];
 
 void RegisterProfilePrefs(PrefRegistrySimple* registry);
 
-std::vector<std::string_view> GetPrefs();
+const std::vector<std::string_view>& GetPrefs();
 
 }  // namespace adblock::common::prefs
 
diff --git a/components/adblock/core/common/app_info.cc b/components/adblock/core/common/app_info.cc
--- a/components/adblock/core/common/app_info.cc
+++ b/components/adblock/core/common/app_info.cc
@@ -17,6 +17,7 @@
 
 #include "components/adblock/core/common/app_info.h"
 
+#include "base/no_destructor.h"
 #include "base/strings/string_util.h"
 #include "components/version_info/version_info.h"
 
@@ -24,23 +25,11 @@ namespace adblock {
 
 // static
 const AppInfo& AppInfo::Get() {
-  static AppInfo instance;
-  return instance;
+  static const base::NoDestructor<AppInfo> instance;
+  return *instance;
 }
 
 AppInfo::AppInfo() {
-#if defined(EYEO_APPLICATION_NAME)
-  name = EYEO_APPLICATION_NAME;
-#else
-  name = version_info::GetProductName();
-#endif
-#if defined(EYEO_APPLICATION_VERSION)
-  version = EYEO_APPLICATION_VERSION;
-#else
-  version = version_info::GetVersionNumber();
-#endif
-  base::ReplaceChars(version_info::GetOSType(), base::kWhitespaceASCII, "",
-                     &client_os);
 }
 
 }  // namespace adblock
diff --git a/components/adblock/core/common/app_info.h b/components/adblock/core/common/app_info.h
--- a/components/adblock/core/common/app_info.h
+++ b/components/adblock/core/common/app_info.h
@@ -34,7 +34,6 @@ class AppInfo {
   std::string client_os;
   std::string version;
 
- private:
   AppInfo();
 };
 
diff --git a/components/adblock/core/configuration/filtering_configuration.h b/components/adblock/core/configuration/filtering_configuration.h
--- a/components/adblock/core/configuration/filtering_configuration.h
+++ b/components/adblock/core/configuration/filtering_configuration.h
@@ -66,6 +66,9 @@ class FilteringConfiguration {
   virtual void SetEnabled(bool enabled) = 0;
   virtual bool IsEnabled() const = 0;
 
+  virtual void SetPrivilegedFiltersEnabled(bool enabled) = 0;
+  virtual bool IsPrivilegedFiltersEnabled() = 0;
+
   // Adding an existing filter list, or removing a non-existing filter list, are
   // NOPs and do not notify observers.
   virtual void AddFilterList(const GURL& url) = 0;
@@ -84,6 +87,8 @@ class FilteringConfiguration {
   virtual void AddCustomFilter(const std::string& filter) = 0;
   virtual void RemoveCustomFilter(const std::string& filter) = 0;
   virtual std::vector<std::string> GetCustomFilters() const = 0;
+  virtual void AddTemporaryCustomFilter(const std::string& filter) = 0;
+  virtual std::vector<std::string> GetTemporaryCustomFilters() const = 0;
 };
 
 }  // namespace adblock
diff --git a/components/adblock/core/configuration/persistent_filtering_configuration.cc b/components/adblock/core/configuration/persistent_filtering_configuration.cc
--- a/components/adblock/core/configuration/persistent_filtering_configuration.cc
+++ b/components/adblock/core/configuration/persistent_filtering_configuration.cc
@@ -21,10 +21,12 @@
 #include <string>
 #include <string_view>
 
+#include "base/no_destructor.h"
 #include "base/strings/string_util.h"
 #include "components/adblock/core/common/adblock_prefs.h"
 #include "components/prefs/pref_service.h"
 #include "components/prefs/scoped_user_pref_update.h"
+#include "components/adblock/core/common/adblock_prefs.h"
 
 #include "base/logging.h"
 
@@ -34,6 +36,7 @@ namespace {
 constexpr auto kEnabledKey = std::string_view("enabled");
 constexpr auto kDomainsKey = std::string_view("domains");
 constexpr auto kCustomFiltersKey = std::string_view("filters");
+constexpr auto kCustomTemporaryFiltersKey = std::string_view("temp_filters");
 constexpr auto kFilterListsKey = std::string_view("subscriptions");
 
 base::Value::Dict ReadFromPrefs(PrefService* pref_service,
@@ -42,7 +45,9 @@ base::Value::Dict ReadFromPrefs(PrefService* pref_service,
       pref_service->GetValue(common::prefs::kConfigurationsPrefsPath).GetDict();
   const auto* this_config = all_configurations.FindDict(configuration_name);
   if (this_config) {
-    return base::Value::Dict(this_config->Clone());
+    auto clone = base::Value::Dict(this_config->Clone());
+    clone.Remove(kCustomTemporaryFiltersKey);
+    return clone;
   }
   return base::Value::Dict();
 }
@@ -51,9 +56,9 @@ void StoreToPrefs(const base::Value::Dict& configuration,
                   PrefService* pref_service,
                   std::string_view configuration_name) {
   // ScopedDictPrefUpdate requires an std::string for some reason:
-  static std::string kConfigurationsPrefsPathString(
+  static const base::NoDestructor<std::string> kConfigurationsPrefsPathString(
       common::prefs::kConfigurationsPrefsPath);
-  ScopedDictPrefUpdate update(pref_service, kConfigurationsPrefsPathString);
+  ScopedDictPrefUpdate update(pref_service, *kConfigurationsPrefsPathString);
   update.Get().Set(configuration_name, configuration.Clone());
 }
 
@@ -63,6 +68,7 @@ void SetDefaultValuesIfNeeded(base::Value::Dict& configuration) {
   }
   configuration.EnsureList(kDomainsKey);
   configuration.EnsureList(kCustomFiltersKey);
+  configuration.EnsureList(kCustomTemporaryFiltersKey);
   configuration.EnsureList(kFilterListsKey);
 }
 
@@ -133,6 +139,7 @@ const std::string& PersistentFilteringConfiguration::GetName() const {
 }
 
 void PersistentFilteringConfiguration::SetEnabled(bool enabled) {
+  pref_service_->SetBoolean(common::prefs::kEnableAdblockLegacy, enabled);
   if (IsEnabled() == enabled) {
     return;
   }
@@ -141,6 +148,14 @@ void PersistentFilteringConfiguration::SetEnabled(bool enabled) {
   NotifyEnabledStateChanged();
 }
 
+bool PersistentFilteringConfiguration::IsPrivilegedFiltersEnabled() {
+  return pref_service_->GetBoolean(common::prefs::kAllowPrivilegedFilters);
+}
+
+void PersistentFilteringConfiguration::SetPrivilegedFiltersEnabled(bool enabled) {
+  pref_service_->SetBoolean(common::prefs::kAllowPrivilegedFilters, enabled);
+}
+
 bool PersistentFilteringConfiguration::IsEnabled() const {
   const auto pref_value = dictionary_.FindBool(kEnabledKey);
   DCHECK(pref_value);
@@ -209,6 +224,18 @@ void PersistentFilteringConfiguration::RemoveCustomFilter(
   }
 }
 
+void PersistentFilteringConfiguration::AddTemporaryCustomFilter(
+  const std::string& filter) {
+  if (AppendToList(dictionary_, kCustomTemporaryFiltersKey, filter)) {
+    NotifyCustomFiltersChanged();
+  }
+}
+
+std::vector<std::string> PersistentFilteringConfiguration::GetTemporaryCustomFilters()
+    const {
+  return GetFromList<std::string>(dictionary_, kCustomTemporaryFiltersKey);
+}
+
 std::vector<std::string> PersistentFilteringConfiguration::GetCustomFilters()
     const {
   return GetFromList<std::string>(dictionary_, kCustomFiltersKey);
@@ -261,9 +288,9 @@ PersistentFilteringConfiguration::GetPersistedConfigurations(
 void PersistentFilteringConfiguration::RemovePersistedData(
     PrefService* pref_service,
     const std::string& name) {
-  static std::string kConfigurationsPrefsPathString(
+  static const base::NoDestructor<std::string> kConfigurationsPrefsPathString(
       common::prefs::kConfigurationsPrefsPath);
-  ScopedDictPrefUpdate update(pref_service, kConfigurationsPrefsPathString);
+  ScopedDictPrefUpdate update(pref_service, *kConfigurationsPrefsPathString);
   update.Get().Remove(name);
 }
 
diff --git a/components/adblock/core/configuration/persistent_filtering_configuration.h b/components/adblock/core/configuration/persistent_filtering_configuration.h
--- a/components/adblock/core/configuration/persistent_filtering_configuration.h
+++ b/components/adblock/core/configuration/persistent_filtering_configuration.h
@@ -48,6 +48,9 @@ class PersistentFilteringConfiguration final : public FilteringConfiguration {
   void SetEnabled(bool enabled) final;
   bool IsEnabled() const final;
 
+  void SetPrivilegedFiltersEnabled(bool enabled) final;
+  bool IsPrivilegedFiltersEnabled() final;
+
   void AddFilterList(const GURL& url) final;
   void RemoveFilterList(const GURL& url) final;
   std::vector<GURL> GetFilterLists() const final;
@@ -61,6 +64,9 @@ class PersistentFilteringConfiguration final : public FilteringConfiguration {
   void RemoveCustomFilter(const std::string& filter) final;
   std::vector<std::string> GetCustomFilters() const final;
 
+  void AddTemporaryCustomFilter(const std::string& filter) final;
+  std::vector<std::string> GetTemporaryCustomFilters() const final;
+
   static std::vector<std::unique_ptr<PersistentFilteringConfiguration>>
   GetPersistedConfigurations(PrefService* pref_service);
   static void RemovePersistedData(PrefService* pref_service,
diff --git a/components/adblock/core/converter/flatbuffer_converter.cc b/components/adblock/core/converter/flatbuffer_converter.cc
--- a/components/adblock/core/converter/flatbuffer_converter.cc
+++ b/components/adblock/core/converter/flatbuffer_converter.cc
@@ -144,7 +144,7 @@ void FlatbufferConverter::ConvertFilter(
               std::string(filter_str.data(), filter_str.size()))) {
         flatbuffer_serializer.SerializeUrlFilter(std::move(url_filter.value()));
       } else {
-        VLOG(1) << "[eyeo] Invalid url filter: " << line;
+        LOG(INFO) << "[eyeo] Invalid url filter: " << line;
       }
       break;
   }
diff --git a/components/adblock/core/converter/parser/filter_classifier.cc b/components/adblock/core/converter/parser/filter_classifier.cc
--- a/components/adblock/core/converter/parser/filter_classifier.cc
+++ b/components/adblock/core/converter/parser/filter_classifier.cc
@@ -17,6 +17,7 @@
 
 #include "components/adblock/core/converter/parser/filter_classifier.h"
 
+#include "base/no_destructor.h"
 #include "third_party/re2/src/re2/re2.h"
 
 namespace adblock {
@@ -26,8 +27,8 @@ FilterType FilterClassifier::Classify(std::string_view filter) {
   if (!filter.empty() && filter.back() == '}' &&
       (base::StartsWith(filter, kElemHideFilterSeparator) ||
        base::StartsWith(filter, kElemHideEmulationFilterSeparator))) {
-    static re2::RE2 remove_re("\\{\\s*remove\\s*:\\s*true\\s*;\\s*\\}$");
-    if (re2::RE2::PartialMatch(filter, remove_re)) {
+    static const base::NoDestructor<re2::RE2> remove_re("\\{\\s*remove\\s*:\\s*true\\s*;\\s*\\}$");
+    if (re2::RE2::PartialMatch(filter, *remove_re)) {
       return FilterType::Remove;
     } else {
       return FilterType::InlineCss;
diff --git a/components/adblock/core/converter/parser/metadata.cc b/components/adblock/core/converter/parser/metadata.cc
--- a/components/adblock/core/converter/parser/metadata.cc
+++ b/components/adblock/core/converter/parser/metadata.cc
@@ -19,6 +19,7 @@
 
 #include <algorithm>
 
+#include "base/no_destructor.h"
 #include "base/logging.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/string_util.h"
@@ -30,7 +31,7 @@ namespace adblock {
 // comment line any upcoming comments will be skipped.
 // static
 absl::optional<Metadata> Metadata::FromStream(std::istream& filter_stream) {
-  static re2::RE2 comment_re("^!\\s*(.*?)\\s*:\\s*(.*)");
+  static base::NoDestructor<re2::RE2> comment_re("^!\\s*(.*?)\\s*:\\s*(.*)");
 
   std::string homepage;
   std::string title;
@@ -51,7 +52,7 @@ absl::optional<Metadata> Metadata::FromStream(std::istream& filter_stream) {
   auto position_in_stream = filter_stream.tellg();
   while (std::getline(filter_stream, line)) {
     base::TrimWhitespaceASCII(line, base::TRIM_ALL, &line);
-    if (!re2::RE2::FullMatch(line, comment_re, &key, &value)) {
+    if (!re2::RE2::FullMatch(line, *comment_re, &key, &value)) {
       break;
     }
 
@@ -108,14 +109,15 @@ Metadata::~Metadata() = default;
 
 // static
 bool Metadata::IsValidAdblockHeader(const std::string& adblock_header) {
-  static re2::RE2 adblock_header_re("^\\[Adblock.*\\]");
+  if ((true)) return true;
+  static base::NoDestructor<re2::RE2> adblock_header_re("^\\[Adblock.*\\]");
   std::string adblock_header_trimmed;
 
   base::TrimWhitespaceASCII(adblock_header, base::TRIM_ALL,
                             &adblock_header_trimmed);
   if (!re2::RE2::FullMatch(re2::StringPiece(adblock_header_trimmed.data(),
                                             adblock_header_trimmed.size()),
-                           adblock_header_re)) {
+                           *adblock_header_re)) {
     return false;
   }
   return true;
@@ -126,11 +128,11 @@ bool Metadata::IsValidAdblockHeader(const std::string& adblock_header) {
 // static
 base::TimeDelta Metadata::ParseExpirationTime(
     const std::string& expiration_value) {
-  static re2::RE2 expiration_time_re("\\s*([0-9]+)\\s*(h)?.*");
+  static base::NoDestructor<re2::RE2> expiration_time_re("\\s*([0-9]+)\\s*(h)?.*");
   std::string expiration_unit;
   uint64_t expiration_time;
 
-  if (!re2::RE2::FullMatch(expiration_value, expiration_time_re,
+  if (!re2::RE2::FullMatch(expiration_value, *expiration_time_re,
                            &expiration_time, &expiration_unit)) {
     VLOG(1) << "[eyeo] Invalid expiration time format: " << expiration_value
             << ". Will use default value of "
diff --git a/components/adblock/core/converter/parser/test/test_rules.txt b/components/adblock/core/converter/parser/test/test_rules.txt
new file mode 100644
--- /dev/null
+++ b/components/adblock/core/converter/parser/test/test_rules.txt
@@ -0,0 +1,21 @@
+! gn gen --args="is_component_build=false is_debug=false target_os=\"linux\"" --filters="//components/adblock/core/converter/parser" out/linux
+! date && autoninja -C out/linux components/adblock/core/converter:adblock_flatbuffer_converter && date
+! out/linux/adblock_flatbuffer_converter components/adblock/core/converter/parser/test/test_rules.txt http://localhost b
+!
+$csp=script-src: 'none',domain=example.org|~example.com
+$csp=base-uri,domain=example.org|~example.com
+$csp=script-src 'self' '*' 'unsafe-inline',domain=pirateproxy.live|thehiddenbay.com|downloadpirate.com|thepiratebay10.org|ukpass.co|linksmore.site
+$csp=worker-src 'none',domain=torlock.com|alltube.pl|alltube.tv|centrum-dramy.pl|coinfaucet.eu|crictime.com|crictime.is|doodcdn.com|estream.to|flashx.co|flashx.to|flashx.tv|gomo.to|hdvid.fun|hdvid.tv|hitomi.la|kinox.to|lewd.ninja|assia1.tv|nflbite.com|pirateproxy.live|plytv.me|potomy.ru|powvideo.cc|powvideo.net|putlocker.to|reactor.cc|rojadirecta.watch|sickrage.ca|streamtape.com|thehiddenbay.com|thepiratebay.org|thepiratebay10.org|tpb.party|uptomega.me|ustream.to|vidoza.co|vidoza.net|wallpoper.com|wearesaudis.net|yazilir.com
+@@1337x.to^$csp=script-src 'self' 'unsafe-inline' 'unsafe-eval' data:
+||bodysize.org^$csp=child-src *
+||convertfiles.com^$csp=script-src 'self' '*' 'unsafe-inline'
+||gelbooru.com^$csp=script-src 'self' '*' 'unsafe-inline' *.gstatic.com *.google.com *.googleapis.com *.bootstrapcdn.com
+||moviewatcher.is^$csp=script-src 'self' '*' 'unsafe-inline'
+||pirateiro.com^$csp=script-src 'self' 'unsafe-inline' https://hcaptcha.com *.hcaptcha.com
+! CSP Yavli
+||activistpost.com^$csp=script-src *.leadpages.net *.gstatic.com *.google.com *.googleapis.com *.playwire.com *.facebook.com *.bootstrapcdn.com
+! kinox
+$csp=script-src 'self' 'unsafe-inline' 'unsafe-eval' data: *.cloudflare.com *.google.com *.addthis.com *.addthisedge.com *.facebook.net *.twitter.com *.jquery.com,domain=kinos.to|kinox.am|kinox.bz|kinox.click|kinox.cloud|kinox.club|kinox.digital|kinox.direct|kinox.express|kinox.fun|kinox.fyi|kinox.gratis|kinox.io|kinox.lol|kinox.me|kinox.mobi|kinox.pub|kinox.sh|kinox.sx|kinox.to|kinox.tube|kinox.tv|kinox.wtf|kinoz.to,~third-party
+parenting.pl,echirurgia.pl,dobreprogramy.pl,abczdrowie.pl,wp.pl#$#override-property-read rekid 0
+parenting.pl,echirurgia.pl,dobreprogramy.pl,abczdrowie.pl,wp.pl#$#override-property-read
+parenting.pl,echirurgia.pl,dobreprogramy.pl,abczdrowie.pl,wp.pl#$#override-property-read 1 pippo
diff --git a/components/adblock/core/converter/parser/url_filter.cc b/components/adblock/core/converter/parser/url_filter.cc
--- a/components/adblock/core/converter/parser/url_filter.cc
+++ b/components/adblock/core/converter/parser/url_filter.cc
@@ -19,6 +19,7 @@
 
 #include <string_view>
 
+#include "base/no_destructor.h"
 #include "base/command_line.h"
 #include "base/logging.h"
 #include "base/strings/string_util.h"
@@ -50,6 +51,10 @@ std::string SanitizePipeCharacters(std::string pattern) {
   // Skip up to one trailing | characters, this is the right anchor.
   bool pattern_has_right_anchor = base::EndsWith(piece, "|");
   if (pattern_has_right_anchor) {
+    if (piece.size() == 0) {
+      LOG(ERROR) << "[eyeo] Found invalid pattern string '" << pattern << "'";
+      return std::string();
+    }
     piece.remove_suffix(1);
   }
   if (piece.find('|') == std::string_view::npos) {
@@ -81,8 +86,8 @@ bool IsInvalidHostAnchoredFilter(const std::string& pattern) {
   // "http://domain.com".
   // However, "||domain.com/url=http://example.com" is valid.
   // Discard filters that start with "||http://" or similar.
-  static re2::RE2 starts_with_protocol(R"(^\|\|\w*:\/\/)");
-  return re2::RE2::PartialMatch(pattern, starts_with_protocol);
+  static const base::NoDestructor<re2::RE2> starts_with_protocol(R"(^\|\|\w*:\/\/)");
+  return re2::RE2::PartialMatch(pattern, *starts_with_protocol);
 }
 
 }  // namespace
@@ -133,25 +138,18 @@ absl::optional<UrlFilter> UrlFilter::FromString(std::string filter_str) {
 
     if (options->Csp().has_value() && options->Csp().value().empty() &&
         !is_allowing) {
-      VLOG(1) << "[eyeo] Invalid CSP filter. Blocking CSP filter requires "
+      LOG(INFO) << "[eyeo] Invalid CSP filter. Blocking CSP filter requires "
                  "directives";
       return {};
     }
 
     if (options->Headers().has_value() && options->Headers().value().empty() &&
         !is_allowing) {
-      VLOG(1) << "[eyeo] Invalid header filter. Blocking header filter "
+      LOG(INFO) << "[eyeo] Invalid header filter. Blocking header filter "
                  "requires directives";
       return {};
     }
 
-    if (!options->IsSubresource() && !options->ExceptionTypes().empty() &&
-        !is_allowing) {
-      VLOG(1) << "[eyeo] Exception options can only be used with allowing "
-                 "filters";
-      return {};
-    }
-
     filter_str.erase(option_selector_it);
   }
 
diff --git a/components/adblock/core/converter/parser/url_filter_options.cc b/components/adblock/core/converter/parser/url_filter_options.cc
--- a/components/adblock/core/converter/parser/url_filter_options.cc
+++ b/components/adblock/core/converter/parser/url_filter_options.cc
@@ -17,6 +17,7 @@
 
 #include "components/adblock/core/converter/parser/url_filter_options.h"
 
+#include "base/no_destructor.h"
 #include "base/logging.h"
 #include "base/strings/string_split.h"
 #include "base/strings/string_util.h"
@@ -92,20 +93,14 @@ absl::optional<UrlFilterOptions> UrlFilterOptions::FromString(
         return {};
       }
     } else if (key == "sitekey") {
-      if (value.empty()) {
-        VLOG(1) << "[eyeo] Sitekey option has to have a value.";
-        return {};
-      }
-      sitekeys = ParseSitekeys(value);
+      // not supported
+      return {};
     } else if (key == "csp") {
-      if (!IsValidCsp(value)) {
-        VLOG(1) << "[eyeo] Invalid CSP filter directives: " << value;
-        return {};
-      }
-      csp = value;
+      // not supported
+      return {};
     } else if (key == "header") {
-      ParseHeaders(value);
-      headers = value;
+      // not supported
+      return {};
     } else {
       ContentType content_type = ContentTypeFromString(key);
       if (content_type != ContentType::Unknown) {
@@ -188,6 +183,7 @@ absl::optional<UrlFilterOptions::RewriteOption> UrlFilterOptions::ParseRewrite(
 // static
 SiteKeys UrlFilterOptions::ParseSitekeys(const std::string& sitekey_value) {
   SiteKeys sitekeys;
+  if ((true)) return sitekeys;
   for (auto& sitekey : base::SplitString(
            base::ToUpperASCII(sitekey_value), kDomainOrSitekeySeparator,
            base::KEEP_WHITESPACE, base::SPLIT_WANT_NONEMPTY)) {
@@ -199,23 +195,25 @@ SiteKeys UrlFilterOptions::ParseSitekeys(const std::string& sitekey_value) {
 
 // static
 bool UrlFilterOptions::IsValidCsp(const std::string& csp_value) {
-  static re2::RE2 invalid_csp(
+  if ((true)) return false;
+  static const base::NoDestructor<re2::RE2> invalid_csp(
       "(;|^) "
       "?(base-uri|referrer|report-to|report-uri|upgrade-insecure-requests)\\b");
 
   return !(re2::RE2::PartialMatch(
-      re2::StringPiece(csp_value.data(), csp_value.size()), invalid_csp));
+      re2::StringPiece(csp_value.data(), csp_value.size()), *invalid_csp));
 }
 
 // static
 void UrlFilterOptions::ParseHeaders(std::string& headers_value) {
+  if ((true)) return;
   // replace \x2c with actual ,
-  static re2::RE2 r1("([^\\\\])\\\\x2c");
-  re2::RE2::GlobalReplace(&headers_value, r1, "\\1,");
+  static const base::NoDestructor<re2::RE2> r1("([^\\\\])\\\\x2c");
+  re2::RE2::GlobalReplace(&headers_value, *r1, "\\1,");
 
   // remove extra escape for \\x2c which left
-  static re2::RE2 r2("\\\\x2c");
-  re2::RE2::GlobalReplace(&headers_value, r2, "x2c");
+  static const base::NoDestructor<re2::RE2> r2("\\\\x2c");
+  re2::RE2::GlobalReplace(&headers_value, *r2, "x2c");
 }
 
 // static
diff --git a/components/adblock/core/converter/serializer/filter_keyword_extractor.cc b/components/adblock/core/converter/serializer/filter_keyword_extractor.cc
--- a/components/adblock/core/converter/serializer/filter_keyword_extractor.cc
+++ b/components/adblock/core/converter/serializer/filter_keyword_extractor.cc
@@ -20,6 +20,7 @@
 #include <algorithm>
 #include <cctype>
 
+#include "base/no_destructor.h"
 #include "base/strings/string_util.h"
 #include "components/adblock/core/common/keyword_extractor_utils.h"
 #include "third_party/re2/src/re2/re2.h"
@@ -38,16 +39,16 @@ absl::optional<std::string> FilterKeywordExtractor::GetNextKeyword() {
     // keyword because when we have a valid to block url like this one
     // domain.cc/in_discovery5 returns with "discovery5" as
     // one of the extracted keywords instead of "discovery"
-    static const re2::RE2 filter_keyword_extractor(
+    static const base::NoDestructor<re2::RE2> filter_keyword_extractor(
         "([^a-zA-Z0-9%*][a-zA-Z0-9%]{2,})");
-    static const re2::RE2 has_a_following_keyword("(^[^a-zA-Z0-9%*])");
-    static const re2::RE2 following_keyword_consume("(^[a-zA-Z0-9%*]*)");
-    if (!RE2::FindAndConsume(&input_, filter_keyword_extractor,
+    static const base::NoDestructor<re2::RE2> has_a_following_keyword("(^[^a-zA-Z0-9%*])");
+    static const base::NoDestructor<re2::RE2> following_keyword_consume("(^[a-zA-Z0-9%*]*)");
+    if (!RE2::FindAndConsume(&input_, *filter_keyword_extractor,
                              &current_keyword)) {
       return absl::nullopt;
     }
-    if (!RE2::PartialMatch(input_, has_a_following_keyword)) {
-      RE2::Consume(&input_, following_keyword_consume);
+    if (!RE2::PartialMatch(input_, *has_a_following_keyword)) {
+      RE2::Consume(&input_, *following_keyword_consume);
       current_keyword.clear();
       continue;
     }
diff --git a/components/adblock/core/converter/serializer/flatbuffer_serializer.cc b/components/adblock/core/converter/serializer/flatbuffer_serializer.cc
--- a/components/adblock/core/converter/serializer/flatbuffer_serializer.cc
+++ b/components/adblock/core/converter/serializer/flatbuffer_serializer.cc
@@ -20,6 +20,7 @@
 #include "base/logging.h"
 #include "base/notreached.h"
 #include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
 #include "components/adblock/core/common/adblock_constants.h"
 #include "components/adblock/core/common/regex_filter_pattern.h"
 #include "components/adblock/core/converter/parser/filter_classifier.h"
@@ -27,6 +28,70 @@
 
 namespace adblock {
 
+namespace {
+  const char16_t* kAllowedSnippets[] = {
+    // Debugging Snippets
+    u"log", u"debug", u"trace",
+
+    // Performance Snippets
+    u"race",
+
+    // Conditional Hiding Snippets
+    u"hide-if-classifies",
+    u"hide-if-contains",
+    u"hide-if-contains-image",
+    u"hide-if-contains-similar-text",
+    u"hide-if-contains-visible-text",
+    u"hide-if-contains-and-matches-style",
+    //u"hide-if-matches-computed-xpath", (deprecated)
+    //u"hide-if-graph-matches", (deprecated)
+    u"hide-if-has-and-matches-style",
+    u"hide-if-labelled-by",
+    u"hide-if-matches-xpath",
+    u"hide-if-matches-xpath3",
+    u"hide-if-matches-computed-xpath",
+    u"hide-if-shadow-contains",
+
+    // Behavioral Snippets
+    // u"array-override", (unsupported)
+    u"abort-current-inline-script",
+    u"abort-on-property-read",
+    u"abort-on-property-write",
+    u"abort-on-iframe-property-read",
+    u"abort-on-iframe-property-write",
+    u"cookie-remover",
+    u"freeze-element",
+    // u"json-override", (unsupported)
+    u"json-prune",
+    u"override-property-read",
+    // u"simulate-event-poc", (deprecated)
+    // u"simulate-mouse-event", (unsupported)
+    u"prevent-listener",
+    u"skip-video",
+    // u"strip-fetch-query-parameter", (unsupported)
+    // u"replace-fetch-response", (unsupported)
+
+    // Performance Snippets
+    u"race"
+  };
+
+  const char16_t* kAllowedPropertyReadValues[] = {
+    u"false", u"true", u"null", u"noopFunc",
+    u"trueFunc", u"falseFunc", u"emptyArray",
+    u"emptyObj", u"undefined",
+    u"0", u"1"
+  };
+
+  template<int N>
+  bool IsInList(const std::u16string& command, const char16_t*(&input)[N]) {
+    auto list = base::span(input);
+    for(int t = 0; t < N; ++t)
+      if (base::EqualsCaseInsensitiveASCII(command, list[t]))
+        return true;
+    return false;
+  }
+}
+
 class Buffer : public FlatbufferData {
  public:
   explicit Buffer(flatbuffers::DetachedBuffer&& buffer)
@@ -129,9 +194,25 @@ void FlatbufferSerializer::SerializeContentFilter(
 void FlatbufferSerializer::SerializeSnippetFilter(
     const SnippetFilter snippet_filter) {
   if (!allow_privileged_) {
-    VLOG(1) << "[eyeo] Snippet filters not allowed";
+    LOG(INFO) << "[eyeo] Snippet filters not allowed";
     return;
   }
+  for (const auto& cur : snippet_filter.snippet_script) {
+    auto command = base::UTF8ToUTF16(cur.front());
+    if (!IsInList(command, kAllowedSnippets)) {
+      LOG(INFO) << "[eyeo] Snippet filter command not allowed: " << command;
+      return;
+    }
+    if (base::EqualsCaseInsensitiveASCII(command, "override-property-read")) {
+      for (auto it = cur.begin()+2; it != cur.end(); ++it) {
+        auto p = base::UTF8ToUTF16(*it);
+        if (!IsInList(p, kAllowedPropertyReadValues)) {
+          LOG(INFO) << "[eyeo] Snippet override-property-read param not allowed: " << *it;
+          return;
+        }
+      }
+    }
+  }
 
   std::vector<flatbuffers::Offset<adblock::flat::SnippetFunctionCall>> offsets;
   offsets.reserve(snippet_filter.snippet_script.size());
@@ -152,7 +233,7 @@ void FlatbufferSerializer::SerializeSnippetFilter(
 void FlatbufferSerializer::SerializeUrlFilter(const UrlFilter url_filter) {
   const auto& options = url_filter.options;
   if (!allow_privileged_ && options.Headers().has_value()) {
-    VLOG(1) << "[eyeo] Header filters not allowed";
+    LOG(INFO) << "[eyeo] Header filters not allowed";
     return;
   }
 
@@ -210,6 +291,23 @@ void FlatbufferSerializer::SerializeUrlFilter(const UrlFilter url_filter) {
                         keyword_pattern, offset);
   }
 
+  if (!url_filter.is_allowing) {
+    if (!options.IsSubresource()) {
+      for (auto exception_type : options.ExceptionTypes()) {
+        switch (exception_type) {
+          case UrlFilterOptions::ExceptionType::Document:
+            AddUrlFilterToIndex(url_subresource_block_, keyword_pattern, offset);
+            break;
+          case UrlFilterOptions::ExceptionType::Genericblock:
+          case UrlFilterOptions::ExceptionType::Generichide:
+          case UrlFilterOptions::ExceptionType::Elemhide:
+            break;
+        }
+      }
+    }
+    return;
+  }
+
   for (auto exception_type : options.ExceptionTypes()) {
     switch (exception_type) {
       case UrlFilterOptions::ExceptionType::Genericblock:
diff --git a/components/adblock/core/features.cc b/components/adblock/core/features.cc
--- a/components/adblock/core/features.cc
+++ b/components/adblock/core/features.cc
@@ -19,8 +19,8 @@
 
 namespace adblock {
 
-BASE_FEATURE(kAdblockPlusFeature,
-             "AdblockPlus",
-             base::FEATURE_ENABLED_BY_DEFAULT);
+CROMITE_FEATURE(kAdblockPlusFeature,
+                "AdblockPlus",
+                base::FEATURE_ENABLED_BY_DEFAULT);
 
 }  // namespace adblock
diff --git a/components/adblock/core/net/adblock_resource_request_impl.cc b/components/adblock/core/net/adblock_resource_request_impl.cc
--- a/components/adblock/core/net/adblock_resource_request_impl.cc
+++ b/components/adblock/core/net/adblock_resource_request_impl.cc
@@ -31,7 +31,7 @@ namespace adblock {
 namespace {
 
 const net::NetworkTrafficAnnotationTag kTrafficAnnotation =
-    net::DefineNetworkTrafficAnnotation("adblock_resource_request", R"(
+    net::DefineNetworkTrafficAnnotation("adblock_subscription_download", R"(
         semantics {
           sender: "AdblockResourceRequest"
           description:
@@ -52,22 +52,7 @@ const net::NetworkTrafficAnnotationTag kTrafficAnnotation =
         })");
 
 GURL BuildUrlWithParams(const GURL& url, const std::string extra_query_params) {
-  std::string query = base::StrCat(
-      {"addonName=", "eyeo-chromium-sdk", "&addonVersion=", "2.0.0",
-       "&application=", base::EscapeQueryParamValue(AppInfo::Get().name, true),
-       "&applicationVersion=",
-       base::EscapeQueryParamValue(AppInfo::Get().version, true), "&platform=",
-       base::EscapeQueryParamValue(AppInfo::Get().client_os, true),
-       "&platformVersion=", "1.0"});
-
-  if (!extra_query_params.empty()) {
-    query += "&";
-    query += extra_query_params;
-  }
-
-  GURL::Replacements replacements;
-  replacements.SetQueryStr(query);
-  return url.ReplaceComponents(replacements);
+  return url;
 }
 
 }  // namespace
@@ -129,7 +114,7 @@ void AdblockResourceRequestImpl::StartInternal() {
     // indefinitely.
     return;
   }
-  VLOG(1) << "[eyeo] Downloading " << url_;
+  LOG(INFO) << "[eyeo] Downloading " << url_;
   auto request = std::make_unique<network::ResourceRequest>();
   request->url = url_;
   request->method = MethodToString();
@@ -181,11 +166,8 @@ void AdblockResourceRequestImpl::OnDownloadFinished(
     return;
   }
 
-  GURL::Replacements strip_query;
-  strip_query.ClearQuery();
-  GURL url = url_.ReplaceComponents(strip_query);
   response_callback_.Run(
-      url, std::move(downloaded_file),
+      url_, std::move(downloaded_file),
       loader_->ResponseInfo() ? loader_->ResponseInfo()->headers : nullptr);
   // response_callback_ may delete this, do not call any member variables now.
 }
diff --git a/components/adblock/core/resources/.gitignore b/components/adblock/core/resources/.gitignore
--- a/components/adblock/core/resources/.gitignore
+++ b/components/adblock/core/resources/.gitignore
@@ -1 +1 @@
-snippets
+# snippets
diff --git a/components/adblock/core/resources/BUILD.gn b/components/adblock/core/resources/BUILD.gn
--- a/components/adblock/core/resources/BUILD.gn
+++ b/components/adblock/core/resources/BUILD.gn
@@ -54,7 +54,7 @@ make_preloaded_subscription("make_anticv") {
 
 action("prepare_snippets") {
   script = "//components/adblock/core/resources/snippets_deps.py"
-  if (is_debug) {
+  if (true) {
     _snippet_lib = "//components/adblock/core/resources/snippets/dist/isolated-first-all.source.jst"
   } else {
     _snippet_lib = "//components/adblock/core/resources/snippets/dist/isolated-first-all.jst"
@@ -86,9 +86,6 @@ grit("adblock_resources") {
     "adblock_resources.pak",
   ]
   deps = [
-    ":make_anticv",
-    ":make_easylist",
-    ":make_exceptionrules",
     ":prepare_snippets",
   ]
   output_dir = "$root_gen_dir/components/adblock/core/resources"
diff --git a/components/adblock/core/resources/adblock_resources.grd b/components/adblock/core/resources/adblock_resources.grd
--- a/components/adblock/core/resources/adblock_resources.grd
+++ b/components/adblock/core/resources/adblock_resources.grd
@@ -15,7 +15,7 @@
   You should have received a copy of the GNU General Public License
   along with eyeo Chromium SDK.  If not, see <http://www.gnu.org/licenses/>.
 -->
-<grit latest_public_release="0" current_release="1" output_all_resource_defines="false">
+<grit latest_public_release="0" current_release="1">
   <outputs>
     <output filename="grit/adblock_resources.h" type="rc_header">
         <emit emit_type="prepend">
@@ -30,9 +30,6 @@
       <include name="IDR_ADBLOCK_ELEMHIDE_EMU_JS" file="elemhideemu.jst" type="BINDATA" />
       <include name="IDR_ADBLOCK_SNIPPETS_JS" file="${root_gen_dir}/components/adblock/core/resources/snippets.jst" use_base_dir="false" type="BINDATA" compress="gzip" />
       <include name="IDR_ADBLOCK_SNIPPETS_XPATH3_DEP_JS" file="${root_gen_dir}/components/adblock/core/resources/snippets-xpath3-dep.jst" use_base_dir="false" type="BINDATA" compress="gzip" />
-      <include name="IDR_ADBLOCK_FLATBUFFER_EASYLIST" file="${root_gen_dir}/components/adblock/core/resources/easylist.fb" use_base_dir="false" type="BINDATA" compress="gzip" />
-      <include name="IDR_ADBLOCK_FLATBUFFER_EXCEPTIONRULES" file="${root_gen_dir}/components/adblock/core/resources/exceptionrules.fb" use_base_dir="false" type="BINDATA" compress="gzip" />
-      <include name="IDR_ADBLOCK_FLATBUFFER_ANTICV" file="${root_gen_dir}/components/adblock/core/resources/anticv.fb" use_base_dir="false" type="BINDATA" compress="gzip" />
     </includes>
   </release>
 </grit>
diff --git a/components/adblock/core/resources/elemhide_for_selector.jst b/components/adblock/core/resources/elemhide_for_selector.jst
--- a/components/adblock/core/resources/elemhide_for_selector.jst
+++ b/components/adblock/core/resources/elemhide_for_selector.jst
@@ -34,7 +34,7 @@ if (typeof(elemhideForSelector) !== typeof(Function))
     }
     else
     {
-      console.debug("Nothing found for: " + selector);
+      // console.debug("Nothing found for: " + selector);
     }
   }
 }
@@ -50,4 +50,4 @@ if (typeof(elemhideForSelector) !== typeof(Function))
   {
     elemhideForSelector(url_to_hide, "[src$='" + filename_to_hide + "'], [srcset$='" + filename_to_hide + "']");
   }
-})("{{url}}", "{{filename_with_query}}");
\ No newline at end of file
+})("{{url}}", "{{filename_with_query}}");
diff --git a/components/adblock/core/resources/elemhideemu.jst b/components/adblock/core/resources/elemhideemu.jst
--- a/components/adblock/core/resources/elemhideemu.jst
+++ b/components/adblock/core/resources/elemhideemu.jst
@@ -1,3 +1,4 @@
+(function() {
 /*
  * This file is part of eyeo Chromium SDK,
  * Copyright (C) 2006-present eyeo GmbH
@@ -1408,3 +1409,4 @@ let elemHidingEmulatedPatterns = [{{elemHidingEmulatedPatternsDef}}];
 let elemHideEmulation = new ElemHideEmulation();
 
 elemHideEmulation.apply(elemHidingEmulatedPatterns);
+})()
diff --git a/components/adblock/core/resources/snippets/dist/dependencies.jst b/components/adblock/core/resources/snippets/dist/dependencies.jst
new file mode 100644
--- /dev/null
+++ b/components/adblock/core/resources/snippets/dist/dependencies.jst
@@ -0,0 +1,1690 @@
+/*!
+ * snippets v2.0.0
+ * https://gitlab.com/eyeo/anti-cv/snippets/-/blob/v2.0.0/dist/dependencies.jst?ref_type=heads
+ */
+ /*!
+ * This file is part of eyeo's Anti-Circumvention Snippets module (@eyeo/snippets),
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * @eyeo/snippets is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * @eyeo/snippets is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with @eyeo/snippets.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/**! Start hide-if-matches-xpath3 dependency !**/
+
+ function hideIfMatchesXPath3Dependency() {
+	// whynot.js 5.0.0
+
+	// 	The MIT License (MIT)
+
+	// Copyright (c) 2017 Stef Busking
+
+	// Permission is hereby granted, free of charge, to any person obtaining a copy of
+	// this software and associated documentation files (the "Software"), to deal in
+	// the Software without restriction, including without limitation the rights to
+	// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+	// the Software, and to permit persons to whom the Software is furnished to do so,
+	// subject to the following conditions:
+
+	// The above copyright notice and this permission notice shall be included in all
+	// copies or substantial portions of the Software.
+
+	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+	// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+	// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+	// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+	// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+	!function (t, s) { s((t = "undefined" != typeof globalThis ? globalThis : t || self).whynot = {}) }(this, (function (t) { "use strict"; function s(t, s, i, r) { const n = { op: s, func: i, data: r }; return t.push(n), n } function i(t, s) { return t } class r { constructor() { this.program = [] } test(t, i) { return s(this.program, 5, t, void 0 === i ? null : i) } jump(t) { return s(this.program, 3, null, t) } record(t, r) { return s(this.program, 4, void 0 === r ? i : r, t) } bad(t = 1) { return s(this.program, 1, null, t) } accept() { return s(this.program, 0, null, null) } fail(t) { return s(this.program, 2, t || null, null) } } class n { constructor(t, s, i) { this.programLength = t, this.maxFromByPc = s, this.maxSurvivorFromByPc = i } static fromProgram(t) { const s = t.length, i = [], r = []; return t.forEach((t => { i.push(0), r.push(0) })), t.forEach(((t, n) => { switch (t.op) { case 2: if (null === t.func) return; if (n + 1 >= s) throw new Error("Invalid program: program could run past end"); i[n + 1] += 1; break; case 1: case 4: if (n + 1 >= s) throw new Error("Invalid program: program could run past end"); i[n + 1] += 1; break; case 3: t.data.forEach((t => { if (t < 0 || t >= s) throw new Error("Invalid program: program could run past end"); i[t] += 1 })); break; case 5: if (n + 1 >= s) throw new Error("Invalid program: program could run past end"); r[n + 1] += 1; break; case 0: r[n] += 1 } })), new n(s, i, r) } static createStub(t) { const s = [], i = []; for (let r = 0; r < t; ++r)s.push(t), i.push(t); return new n(t, s, i) } } class e { constructor(t) { this.acceptingTraces = t, this.success = t.length > 0 } } const h = 255; class l { constructor(t) { this.t = 0, this.i = 0, this.h = new Uint16Array(t), this.l = new Uint8Array(t) } getBadness(t) { return this.l[t] } add(t, s) { this.l[t] = s > h ? h : s; const i = function (t, s, i, r, n) { let e = r, h = n; for (; e < h;) { const r = e + h >>> 1; i < s[t[r]] ? h = r : e = r + 1 } return e }(this.h, this.l, s, this.i, this.t); this.h.copyWithin(i + 1, i, this.t), this.h[i] = t, this.t += 1 } reschedule(t, s) { const i = Math.max(this.l[t], s > h ? h : s); if (this.l[t] !== i) { const s = this.h.indexOf(t, this.i); if (s < 0 || s >= this.t) return void (this.l[t] = i); this.h.copyWithin(s, s + 1, this.t), this.t -= 1, this.add(t, i) } } getNextPc() { return this.i >= this.t ? null : this.h[this.i++] } reset() { this.t = 0, this.i = 0, this.l.fill(0) } } class o { constructor(t) { this.o = []; let s = t.length; t.forEach((t => { this.o.push(t > 0 ? s : -1), s += t })), this.u = new Uint16Array(s) } clear() { this.u.fill(0, 0, this.o.length) } add(t, s) { const i = this.u[s], r = this.o[s]; this.u[s] += 1, this.u[r + i] = t } has(t) { return this.u[t] > 0 } forEach(t, s) { const i = this.u[t], r = this.o[t]; for (let t = r; t < r + i; ++t)s(this.u[t]) } } function c(t, s, i = !1) { return null === t ? s : Array.isArray(t) ? (-1 === t.indexOf(s) && (i && (t = t.slice()), t.push(s)), t) : t === s ? t : [t, s] } class u { constructor(t, s) { this.prefixes = t, this.record = s } } function a(t, s) { let i; if (null === s) { if (!Array.isArray(t)) return t; i = t } else i = t === u.EMPTY ? [] : Array.isArray(t) ? t : [t]; return new u(i, s) } u.EMPTY = new u([], null); class f { constructor(t) { this.p = [], this.v = []; for (let s = 0; s < t; ++s)this.p.push(0), this.v.push(null) } mergeTraces(t, s, i, r, n, e) { let h = !1; return i.forEach(s, (s => { const i = this.trace(s, r, n, e); var l, o, u; o = i, u = h, t = null === (l = t) ? o : null === o ? l : Array.isArray(o) ? o.reduce(((t, s) => c(t, s, t === o)), l) : c(l, o, u), h = t === i })), t } trace(t, s, i, r) { switch (this.p[t]) { case 2: return this.v[t]; case 1: return null }this.p[t] = 1; let n = null; const e = s[t]; if (null !== e) n = e; else if (!i.has(t)) throw new Error(`Trace without source at pc ${t}`); if (n = this.mergeTraces(n, t, i, s, i, r), null !== n) { const s = r[t]; null !== s && (n = a(n, s)) } return this.v[t] = n, this.p[t] = 2, n } buildSurvivorTraces(t, s, i, r, n) { for (let e = 0, h = t.length; e < h; ++e) { if (!i.has(e)) { s[e] = null; continue } this.v.fill(null), this.p.fill(0); const h = this.mergeTraces(null, e, i, t, r, n); if (null === h) throw new Error(`No non-cyclic paths found to survivor ${e}`); s[e] = a(h, null) } this.v.fill(null) } } class d { constructor(t) { this.g = [], this.k = [], this.m = [], this.A = new o(t.maxFromByPc), this.T = new o(t.maxSurvivorFromByPc), this.S = new f(t.programLength); for (let s = 0; s < t.programLength; ++s)this.g.push(null), this.k.push(null), this.m.push(null); this.k[0] = u.EMPTY } reset(t) { this.A.clear(), this.T.clear(), this.g.fill(null), t && (this.k.fill(null), this.m.fill(null), this.k[0] = u.EMPTY) } record(t, s) { this.g[t] = s } has(t) { return this.A.has(t) || null !== this.k[t] } add(t, s) { this.A.add(t, s) } hasSurvivor(t) { return this.T.has(t) } addSurvivor(t, s) { this.T.add(t, s) } buildSurvivorTraces() { const t = this.k; this.S.buildSurvivorTraces(t, this.m, this.T, this.A, this.g), this.k = this.m, this.m = t } getTraces(t) { const s = t.reduce(((t, s) => c(t, this.k[s])), null); return null === s ? [] : Array.isArray(s) ? s : [s] } } class w { constructor(t) { this.I = [], this.M = new l(t.programLength), this.N = new l(t.programLength), this.j = new d(t) } reset() { this.M.reset(), this.M.add(0, 0), this.I.length = 0, this.j.reset(!0) } getNextThreadPc() { return this.M.getNextPc() } step(t, s, i) { const r = this.j.has(s); this.j.add(t, s); const n = this.M.getBadness(t) + i; r ? this.M.reschedule(s, n) : this.M.add(s, n) } stepToNextGeneration(t, s) { const i = this.j.hasSurvivor(s); this.j.addSurvivor(t, s); const r = this.M.getBadness(t); i ? this.N.reschedule(s, r) : this.N.add(s, r) } accept(t) { this.I.push(t), this.j.addSurvivor(t, t) } fail(t) { } record(t, s) { this.j.record(t, s) } nextGeneration() { this.j.buildSurvivorTraces(), this.j.reset(!1); const t = this.M; t.reset(), this.M = this.N, this.N = t } getAcceptingTraces() { return this.j.getTraces(this.I) } } class p { constructor(t) { this.P = [], this.U = t, this.G = n.fromProgram(t), this.P.push(new w(this.G)) } execute(t, s) { const i = this.P.pop() || new w(this.G); i.reset(); const r = t.length; let n, h = -1; do { let e = i.getNextThreadPc(); if (null === e) break; for (++h, n = h >= r ? null : t[h]; null !== e;) { const t = this.U[e]; switch (t.op) { case 0: null === n ? i.accept(e) : i.fail(e); break; case 2: { const r = t.func; if (null === r || r(s)) { i.fail(e); break } i.step(e, e + 1, 0); break } case 1: i.step(e, e + 1, t.data); break; case 5: if (null === n) { i.fail(e); break } if (!(0, t.func)(n, t.data, s)) { i.fail(e); break } i.stepToNextGeneration(e, e + 1); break; case 3: { const s = t.data, r = s.length; if (0 === r) { i.fail(e); break } for (let t = 0; t < r; ++t)i.step(e, s[t], 0); break } case 4: { const r = (0, t.func)(t.data, h, s); null != r && i.record(e, r), i.step(e, e + 1, 0); break } }e = i.getNextThreadPc() } i.nextGeneration() } while (null !== n); const l = new e(i.getAcceptingTraces()); return i.reset(), this.P.push(i), l } } function b(t) { const s = new r; return t(s), new p(s.program) } var v = { Assembler: r, VM: p, compileVM: b }; t.Assembler = r, t.VM = p, t.compileVM = b, t.default = v, Object.defineProperty(t, "V", { value: !0 }) }));
+
+	// prsc 4.0.0
+
+	// The MIT License (MIT)
+
+	// Copyright (c) 2019 Stef Busking
+
+	// Permission is hereby granted, free of charge, to any person obtaining a copy of
+	// this software and associated documentation files (the "Software"), to deal in
+	// the Software without restriction, including without limitation the rights to
+	// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+	// the Software, and to permit persons to whom the Software is furnished to do so,
+	// subject to the following conditions:
+
+	// The above copyright notice and this permission notice shall be included in all
+	// copies or substantial portions of the Software.
+
+	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+	// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+	// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+	// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+	// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+	!function (n, t) { t((n = "undefined" != typeof globalThis ? globalThis : n || self).prsc = {}) }(this, (function (n) { "use strict"; function t(n, t) { return { success: !0, offset: n, value: t } } function e(n) { return t(n, void 0) } function r(n, t, e = !1) { return { success: !1, offset: n, expected: t, fatal: e } } function o(n) { return n > 65535 ? 2 : 1 } function u(n, t) { return (u, c) => { const s = u.codePointAt(c); return void 0 !== s && n(s) ? e(c + o(s)) : r(c, t) } } function c(n, e) { return (r, o) => { const u = n(r, o); return u.success ? t(u.offset, e(u.value)) : u } } function s(n) { return (e, r) => { let o = [], u = r; for (; ;) { const t = n(e, u); if (!t.success) { if (t.fatal) return t; break } if (o.push(t.value), t.offset === u) break; u = t.offset } return t(u, o) } } function f(n) { return (t, r) => { let o = r; for (; ;) { const e = n(t, o); if (!e.success) { if (e.fatal) return e; break } if (e.offset === o) break; o = e.offset } return e(o) } } function i(n, e, r) { return (o, u) => { const c = n(o, u); if (!c.success) return c; const s = e(o, c.offset); return s.success ? t(s.offset, r(c.value, s.value)) : s } } function l(n, t) { return n } function d(n, t) { return t } function a(n, t) { return i(n, t, d) } function p(n, t) { return i(n, t, l) } function v(n, t) { return (o, u) => n(o, u).success ? r(u, t) : e(u) } function m(n) { return (t, e) => { const o = n(t, e); return o.success ? o : r(o.offset, o.expected, !0) } } const x = (n, t) => n.length === t ? e(t) : r(t, ["end of input"]); function g(n) { const t = []; let e = n.next(); for (; !e.done;)t.push(e.value), e = n.next(); return [t, e.value] } n.codepoint = u, n.codepoints = function (n, t) { return (o, u) => { const c = u; for (; ;) { const t = o.codePointAt(u); if (void 0 === t) break; if (!n(t)) break; u += t > 65535 ? 2 : 1 } return void 0 !== t && u === c ? r(u, t) : e(u) } }, n.collect = g, n.complete = function (n) { return i(n, x, l) }, n.consume = function (n) { return c(n, (() => { })) }, n.cut = m, n.delimited = function (n, t, e, r = !1) { return a(n, r ? m(p(t, e)) : p(t, e)) }, n.dispatch = function (n, t, e = 0, o = []) { return (u, c) => { const s = u.codePointAt(c + e); if (void 0 === s) return r(c, o); const f = n[s]; return void 0 === f ? void 0 === t ? r(c, o) : t(u, c) : f(u, c) } }, n.end = x, n.error = r, n.except = function (n, t, e) { return a(v(t, e), n) }, n.filter = function (n, t, e, o) { return (u, c) => { const s = n(u, c); return s.success ? t(s.value) ? s : r(c, e, o) : s } }, n.filterUndefined = function (n) { return c(n, (n => n.filter((n => void 0 !== n)))) }, n.first = l, n.followed = p, n.map = c, n.not = v, n.ok = e, n.okWithValue = t, n.optional = function (n) { return (e, r) => { const o = n(e, r); return o.success || o.fatal ? o : t(r, null) } }, n.or = function (n, t) { return (e, o) => { let u = null; for (const r of n) { const n = r(e, o); if (n.success) return n; if (null === u || n.offset > u.offset ? u = n : n.offset === u.offset && void 0 === t && (u.expected = u.expected.concat(n.expected)), n.fatal) return n } return t = t || (null == u ? void 0 : u.expected) || [], u && (u.expected = t), u || r(o, t) } }, n.peek = function (n) { return (e, r) => { const o = n(e, r); return o.success ? t(r, o.value) : o } }, n.plus = function (n) { return i(n, s(n), ((n, t) => [n].concat(t))) }, n.plusConsumed = function (n) { return i(n, f(n), d) }, n.preceded = a, n.range = function (n, t, e) { return u((e => n <= e && e <= t), e || [`${String.fromCodePoint(n)}-${String.fromCodePoint(t)}`]) }, n.recognize = function (n) { return (e, r) => { const o = n(e, r); return o.success ? t(o.offset, e.slice(r, o.offset)) : o } }, n.second = d, n.sequence = function (...n) { return (e, r) => { const o = []; for (const t of n) { const n = t(e, r); if (!n.success) return n; r = n.offset, o.push(n.value) } return t(r, o) } }, n.sequenceConsumed = function (...n) { return (t, r) => { for (const e of n) { const n = e(t, r); if (!n.success) return n; r = n.offset } return e(r) } }, n.skipChars = function (n) { return (t, u) => { let c = n; for (; c > 0;) { const n = t.codePointAt(u); if (void 0 === n) return r(u, ["any character"]); u += o(n), c -= 1 } return e(u) } }, n.star = s, n.starConsumed = f, n.start = (n, t) => 0 === t ? e(t) : r(t, ["start of input"]), n.streaming = function (n) { return function* (t, e) { const r = n(t, e); return r.success && (yield r.value), r } }, n.streamingComplete = function (n) { return function* (t, e) { const r = yield* n(t, e); return r.success ? x(t, r.offset) : r } }, n.streamingFilterUndefined = function (n) { return function* (t, e) { const r = n(t, e); let o = r.next(); for (; !o.done;) { const n = o.value; void 0 !== n && (yield n), o = r.next() } return o.value } }, n.streamingOptional = function (n) { return function* (t, r) { const [o, u] = g(n(t, r)); return u.success ? (yield* o, u) : u.fatal ? u : e(r) } }, n.streamingStar = function (n) { return function* (t, r) { for (; ;) { const [o, u] = g(n(t, r)); if (!u.success) return u.fatal ? u : e(r); if (yield* o, r === u.offset) return e(r); r = u.offset } } }, n.streamingThen = function (n, t) { return function* (e, r) { const o = yield* n(e, r); return o.success ? yield* t(e, o.offset) : o } }, n.then = i, n.token = function (n) { return (e, o) => { const u = o + n.length; return e.slice(o, u) === n ? t(u, n) : r(o, [n]) } }, Object.defineProperty(n, "__esModule", { value: !0 }) }));
+
+	// xspattern 3.1.0
+
+	// 	The MIT License (MIT)
+
+	// Copyright (c) 2019 Stef Busking
+
+	// Permission is hereby granted, free of charge, to any person obtaining a copy of
+	// this software and associated documentation files (the "Software"), to deal in
+	// the Software without restriction, including without limitation the rights to
+	// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+	// the Software, and to permit persons to whom the Software is furnished to do so,
+	// subject to the following conditions:
+
+	// The above copyright notice and this permission notice shall be included in all
+	// copies or substantial portions of the Software.
+
+	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+	// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+	// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+	// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+	// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+	!function (A, B) { B((A = "undefined" != typeof globalThis ? globalThis : A || self).xspattern = {}, A.whynot) }(this, (function (A, B) { "use strict"; function a(A) { return B => B === A } function n(A, B) { if (null === A || null === B) throw new Error("unescaped hyphen may not be used as a range endpoint"); if (B < A) throw new Error("character range is in the wrong order"); return a => A <= a && a <= B } function e(A) { return !0 } function t() { return !1 } function G(A, B) { return a => A(a) || B(a) } const i = -1, r = -2; function o(A, B) { switch (B.kind) { case "predicate": return void A.test(B.value); case "regexp": return void H(A, B.value, !1) } } function l(A, B) { B.forEach((B => { !function (A, B) { const [a, { min: n, max: e }] = B; if (null !== e) { for (let B = 0; B < n; ++B)o(A, a); for (let B = n; B < e; ++B) { const B = A.jump([]); B.data.push(A.program.length), o(A, a), B.data.push(A.program.length) } } else if (n > 0) { for (let B = 0; B < n - 1; ++B)o(A, a); const B = A.program.length; o(A, a), A.jump([B]).data.push(A.program.length) } else { const B = A.program.length, n = A.jump([]); n.data.push(A.program.length), o(A, a), A.jump([B]), n.data.push(A.program.length) } }(A, B) })) } function H(A, B, a) { const n = A.program.length, e = A.jump([]); a && (e.data.push(A.program.length), A.test((() => !0)), A.jump([n])); const t = []; if (B.forEach((B => { e.data.push(A.program.length), l(A, B), t.push(A.jump([])) })), t.forEach((B => { B.data.push(A.program.length) })), a) { const B = A.program.length, a = A.jump([]); a.data.push(A.program.length), A.test((() => !0)), A.jump([B]), a.data.push(A.program.length) } } function u(A, B) { return { success: !0, offset: A, value: B } } function C(A) { return u(A, void 0) } function s(A, B, a = !1) { return { success: !1, offset: A, expected: B, fatal: a } } function c(A) { return (B, a) => { const n = a + A.length; return B.slice(a, n) === A ? u(n, A) : s(a, [A]) } } function D(A, B) { return (a, n) => { const e = A(a, n); return e.success ? u(e.offset, B(e.value)) : e } } function m(A, B, a, n) { return (e, t) => { const G = A(e, t); return G.success ? B(G.value) ? G : s(t, a, n) : G } } function d(A, B) { return (a, n) => { let e = null; for (const t of A) { const A = t(a, n); if (A.success) return A; if (null === e || A.offset > e.offset ? e = A : A.offset === e.offset && void 0 === B && (e.expected = e.expected.concat(A.expected)), A.fatal) return A } return B = B || (null == e ? void 0 : e.expected) || [], e && (e.expected = B), e || s(n, B) } } function I(A) { return (B, a) => { const n = A(B, a); return n.success || n.fatal ? n : u(a, null) } } function h(A) { return (B, a) => { let n = [], e = a; for (; ;) { const a = A(B, e); if (!a.success) { if (a.fatal) return a; break } if (n.push(a.value), a.offset === e) break; e = a.offset } return u(e, n) } } function p(A, B, a) { return (n, e) => { const t = A(n, e); if (!t.success) return t; const G = B(n, t.offset); return G.success ? u(G.offset, a(t.value, G.value)) : G } } function T(A) { return p(A, h(A), ((A, B) => [A].concat(B))) } function f(A, B) { return A } function F(A, B) { return B } function E(A, B) { return p(A, B, F) } function g(A, B) { return p(A, B, f) } function M(A, B, a, n = !1) { return E(A, n ? J(g(B, a)) : g(B, a)) } function P(A, B) { return (a, n) => A(a, n).success ? s(n, B) : C(n) } function J(A) { return (B, a) => { const n = A(B, a); return n.success ? n : s(n.offset, n.expected, !0) } } const S = (A, B) => A.length === B ? C(B) : s(B, ["end of input"]); const K = ["Lu", "Ll", "Lt", "Lm", "Lo", "Mn", "Mc", "Me", "Nd", "Nl", "No", "Pc", "Pd", "Ps", "Pe", "Pi", "Pf", "Po", "Zs", "Zl", "Zp", "Sm", "Sc", "Sk", "So", "Cc", "Cf", "Co", "Cn"]; const y = {}; function b(A) { return A.codePointAt(0) } "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("").forEach(((A, B) => { y[A] = B })); const x = A => A === i || A === r; function Q(A) { return B => !x(B) && !A(B) } function L(A, B) { return null === B ? A : a => A(a) && !B(a) } const X = function (A, B) { const a = new Map; let e = 0; return A.forEach(((A, t) => { const i = B[t]; null !== A && A.split("|").forEach((A => { const B = a.get(A), t = n(e, e + i - 1); a.set(A, B ? G(B, t) : t) })), e += i })), a }(["BasicLatin", "Latin-1Supplement", "LatinExtended-A", "LatinExtended-B", "IPAExtensions", "SpacingModifierLetters", "CombiningDiacriticalMarks", "GreekandCoptic|Greek", "Cyrillic", "CyrillicSupplement", "Armenian", "Hebrew", "Arabic", "Syriac", "ArabicSupplement", "Thaana", "NKo", "Samaritan", "Mandaic", "SyriacSupplement", "ArabicExtended-B", "ArabicExtended-A", "Devanagari", "Bengali", "Gurmukhi", "Gujarati", "Oriya", "Tamil", "Telugu", "Kannada", "Malayalam", "Sinhala", "Thai", "Lao", "Tibetan", "Myanmar", "Georgian", "HangulJamo", "Ethiopic", "EthiopicSupplement", "Cherokee", "UnifiedCanadianAboriginalSyllabics", "Ogham", "Runic", "Tagalog", "Hanunoo", "Buhid", "Tagbanwa", "Khmer", "Mongolian", "UnifiedCanadianAboriginalSyllabicsExtended", "Limbu", "TaiLe", "NewTaiLue", "KhmerSymbols", "Buginese", "TaiTham", "CombiningDiacriticalMarksExtended", "Balinese", "Sundanese", "Batak", "Lepcha", "OlChiki", "CyrillicExtended-C", "GeorgianExtended", "SundaneseSupplement", "VedicExtensions", "PhoneticExtensions", "PhoneticExtensionsSupplement", "CombiningDiacriticalMarksSupplement", "LatinExtendedAdditional", "GreekExtended", "GeneralPunctuation", "SuperscriptsandSubscripts", "CurrencySymbols", "CombiningDiacriticalMarksforSymbols|CombiningMarksforSymbols", "LetterlikeSymbols", "NumberForms", "Arrows", "MathematicalOperators", "MiscellaneousTechnical", "ControlPictures", "OpticalCharacterRecognition", "EnclosedAlphanumerics", "BoxDrawing", "BlockElements", "GeometricShapes", "MiscellaneousSymbols", "Dingbats", "MiscellaneousMathematicalSymbols-A", "SupplementalArrows-A", "BraillePatterns", "SupplementalArrows-B", "MiscellaneousMathematicalSymbols-B", "SupplementalMathematicalOperators", "MiscellaneousSymbolsandArrows", "Glagolitic", "LatinExtended-C", "Coptic", "GeorgianSupplement", "Tifinagh", "EthiopicExtended", "CyrillicExtended-A", "SupplementalPunctuation", "CJKRadicalsSupplement", "KangxiRadicals", null, "IdeographicDescriptionCharacters", "CJKSymbolsandPunctuation", "Hiragana", "Katakana", "Bopomofo", "HangulCompatibilityJamo", "Kanbun", "BopomofoExtended", "CJKStrokes", "KatakanaPhoneticExtensions", "EnclosedCJKLettersandMonths", "CJKCompatibility", "CJKUnifiedIdeographsExtensionA", "YijingHexagramSymbols", "CJKUnifiedIdeographs", "YiSyllables", "YiRadicals", "Lisu", "Vai", "CyrillicExtended-B", "Bamum", "ModifierToneLetters", "LatinExtended-D", "SylotiNagri", "CommonIndicNumberForms", "Phags-pa", "Saurashtra", "DevanagariExtended", "KayahLi", "Rejang", "HangulJamoExtended-A", "Javanese", "MyanmarExtended-B", "Cham", "MyanmarExtended-A", "TaiViet", "MeeteiMayekExtensions", "EthiopicExtended-A", "LatinExtended-E", "CherokeeSupplement", "MeeteiMayek", "HangulSyllables", "HangulJamoExtended-B", "HighSurrogates", "HighPrivateUseSurrogates", "LowSurrogates", "PrivateUseArea|PrivateUse", "CJKCompatibilityIdeographs", "AlphabeticPresentationForms", "ArabicPresentationForms-A", "VariationSelectors", "VerticalForms", "CombiningHalfMarks", "CJKCompatibilityForms", "SmallFormVariants", "ArabicPresentationForms-B", "HalfwidthandFullwidthForms", "Specials", "LinearBSyllabary", "LinearBIdeograms", "AegeanNumbers", "AncientGreekNumbers", "AncientSymbols", "PhaistosDisc", null, "Lycian", "Carian", "CopticEpactNumbers", "OldItalic", "Gothic", "OldPermic", "Ugaritic", "OldPersian", null, "Deseret", "Shavian", "Osmanya", "Osage", "Elbasan", "CaucasianAlbanian", "Vithkuqi", null, "LinearA", "LatinExtended-F", null, "CypriotSyllabary", "ImperialAramaic", "Palmyrene", "Nabataean", null, "Hatran", "Phoenician", "Lydian", null, "MeroiticHieroglyphs", "MeroiticCursive", "Kharoshthi", "OldSouthArabian", "OldNorthArabian", null, "Manichaean", "Avestan", "InscriptionalParthian", "InscriptionalPahlavi", "PsalterPahlavi", null, "OldTurkic", null, "OldHungarian", "HanifiRohingya", null, "RumiNumeralSymbols", "Yezidi", "ArabicExtended-C", "OldSogdian", "Sogdian", "OldUyghur", "Chorasmian", "Elymaic", "Brahmi", "Kaithi", "SoraSompeng", "Chakma", "Mahajani", "Sharada", "SinhalaArchaicNumbers", "Khojki", null, "Multani", "Khudawadi", "Grantha", null, "Newa", "Tirhuta", null, "Siddham", "Modi", "MongolianSupplement", "Takri", null, "Ahom", null, "Dogra", null, "WarangCiti", "DivesAkuru", null, "Nandinagari", "ZanabazarSquare", "Soyombo", "UnifiedCanadianAboriginalSyllabicsExtended-A", "PauCinHau", "DevanagariExtended-A", null, "Bhaiksuki", "Marchen", null, "MasaramGondi", "GunjalaGondi", null, "Makasar", "Kawi", null, "LisuSupplement", "TamilSupplement", "Cuneiform", "CuneiformNumbersandPunctuation", "EarlyDynasticCuneiform", null, "Cypro-Minoan", "EgyptianHieroglyphs", "EgyptianHieroglyphFormatControls", null, "AnatolianHieroglyphs", null, "BamumSupplement", "Mro", "Tangsa", "BassaVah", "PahawhHmong", null, "Medefaidrin", null, "Miao", null, "IdeographicSymbolsandPunctuation", "Tangut", "TangutComponents", "KhitanSmallScript", "TangutSupplement", null, "KanaExtended-B", "KanaSupplement", "KanaExtended-A", "SmallKanaExtension", "Nushu", null, "Duployan", "ShorthandFormatControls", null, "ZnamennyMusicalNotation", null, "ByzantineMusicalSymbols", "MusicalSymbols", "AncientGreekMusicalNotation", null, "KaktovikNumerals", "MayanNumerals", "TaiXuanJingSymbols", "CountingRodNumerals", null, "MathematicalAlphanumericSymbols", "SuttonSignWriting", null, "LatinExtended-G", "GlagoliticSupplement", "CyrillicExtended-D", null, "NyiakengPuachueHmong", null, "Toto", "Wancho", null, "NagMundari", null, "EthiopicExtended-B", "MendeKikakui", null, "Adlam", null, "IndicSiyaqNumbers", null, "OttomanSiyaqNumbers", null, "ArabicMathematicalAlphabeticSymbols", null, "MahjongTiles", "DominoTiles", "PlayingCards", "EnclosedAlphanumericSupplement", "EnclosedIdeographicSupplement", "MiscellaneousSymbolsandPictographs", "Emoticons", "OrnamentalDingbats", "TransportandMapSymbols", "AlchemicalSymbols", "GeometricShapesExtended", "SupplementalArrows-C", "SupplementalSymbolsandPictographs", "ChessSymbols", "SymbolsandPictographsExtended-A", "SymbolsforLegacyComputing", null, "CJKUnifiedIdeographsExtensionB", null, "CJKUnifiedIdeographsExtensionC", "CJKUnifiedIdeographsExtensionD", "CJKUnifiedIdeographsExtensionE", "CJKUnifiedIdeographsExtensionF", null, "CJKCompatibilityIdeographsSupplement", null, "CJKUnifiedIdeographsExtensionG", "CJKUnifiedIdeographsExtensionH", null, "Tags", null, "VariationSelectorsSupplement", null, "SupplementaryPrivateUseArea-A|PrivateUse", "SupplementaryPrivateUseArea-B|PrivateUse"], [128, 128, 128, 208, 96, 80, 112, 144, 256, 48, 96, 112, 256, 80, 48, 64, 64, 64, 32, 16, 48, 96, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 256, 160, 96, 256, 384, 32, 96, 640, 32, 96, 32, 32, 32, 32, 128, 176, 80, 80, 48, 96, 32, 32, 144, 80, 128, 64, 64, 80, 48, 16, 48, 16, 48, 128, 64, 64, 256, 256, 112, 48, 48, 48, 80, 64, 112, 256, 256, 64, 32, 160, 128, 32, 96, 256, 192, 48, 16, 256, 128, 128, 256, 256, 96, 32, 128, 48, 80, 96, 32, 128, 128, 224, 16, 16, 64, 96, 96, 48, 96, 16, 32, 48, 16, 256, 256, 6592, 64, 20992, 1168, 64, 48, 320, 96, 96, 32, 224, 48, 16, 64, 96, 32, 48, 48, 32, 96, 32, 96, 32, 96, 32, 48, 64, 80, 64, 11184, 80, 896, 128, 1024, 6400, 512, 80, 688, 16, 16, 16, 32, 32, 144, 240, 16, 128, 128, 64, 80, 64, 48, 128, 32, 64, 32, 48, 32, 48, 32, 64, 32, 80, 48, 48, 80, 48, 64, 80, 64, 384, 64, 64, 64, 32, 32, 48, 48, 32, 32, 32, 64, 32, 96, 96, 32, 32, 32, 64, 64, 32, 32, 48, 80, 80, 48, 128, 64, 288, 32, 64, 64, 48, 64, 64, 48, 32, 128, 80, 48, 80, 48, 96, 32, 80, 48, 48, 80, 128, 128, 128, 96, 160, 128, 96, 32, 80, 48, 80, 176, 80, 80, 96, 96, 64, 96, 80, 96, 16, 64, 96, 160, 112, 80, 64, 96, 80, 304, 32, 96, 80, 16, 64, 1024, 128, 208, 2624, 112, 1072, 48, 4e3, 640, 8576, 576, 48, 96, 48, 144, 688, 96, 96, 160, 64, 32, 6144, 768, 512, 128, 8816, 16, 256, 48, 64, 400, 2304, 160, 16, 4688, 208, 48, 256, 256, 80, 112, 32, 32, 96, 32, 128, 1024, 688, 1104, 256, 48, 96, 112, 80, 320, 48, 64, 464, 48, 736, 32, 224, 32, 96, 784, 80, 64, 80, 176, 256, 256, 48, 112, 96, 256, 256, 768, 80, 48, 128, 128, 128, 256, 256, 112, 144, 256, 1024, 42720, 32, 4160, 224, 5776, 7488, 3088, 544, 1504, 4944, 4192, 711760, 128, 128, 240, 65040, 65536, 65536]), Z = function (A) { const B = new Map, e = A.split(""), i = K.map((() => [])); let r = 0, o = 0; for (; o < e.length;) { const A = y[e[o]], B = (31 & A) - 2; let t = 1 + y[e[o + 1]]; switch (32 & A ? (t += y[e[o + 2]] << 6, t += y[e[o + 3]] << 12, t += y[e[o + 4]] << 18, o += 5) : o += 2, B) { case -2: { let A = 0; for (let B = r; B < r + t; ++B) { i[A].push(a(B)), A = (A + 1) % 2 } break } case -1: break; default: { const A = i[B]; 1 === t ? A.push(a(r)) : A.push(n(r, r + t - 1)); break } }r += t } const l = new Map; return K.forEach(((A, a) => { const n = i[a].reduce(G, t); B.set(A, n); const e = A.charAt(0), r = l.get(e) || []; l.set(e, r), r.push(n) })), l.forEach(((A, a) => { B.set(a, A.reduce(G, t)) })), B }("bfUATCYATCPAQATAXATAOATBKJTBXCTBCZPATAQAZANAZADZPAXAQAXAbgUATAYDaATAZAaAGARAXAcAaAZAaAXAMBZADATBZAMAGASAMCTACWXACGDXXADHA3DAAPDAAtCAAFDBCAADCAABCCDBCCABCAABCCDCCAABCAAFCAADDAABCAABCBADCBDBGACADCGDCAEADACAEADACAEADAAPDAARDACAEADAABCBA7DFCAABCBDBABCCAJjDBAAGADaFRZDFLZNFEZGFAZAFAZQnvBAAADFAZACADABBFADCTACABDZBCATACCBACABACAABCQBACIDiCADBCCDCAXDDCADAXAABCBDBCyDvAhaAHEJBA1CAANDAgfBAABAClBBFATFDoTAOABBaBYABAHsOAHATAHBTAHBTAHABHGaBDGDTBBKcFXCTBYATBaBHKTAcATCGfFAGJHUKJTDGBHAmiBAATAGAHGcAaAHFFBHBaAHDGBKJGCaBGATNBAcAGAHAGdHaBBmYBAAHKGABNKJGgHIFBaATCFABBHAYBGVHDFAHIFAHCFAHEBBTOBAGYHCBBTABAGKBEGXZAGFBAcBBFHHGoFAHXcAHfIAG1HAIAHAGAICHHIDHAIBGAHGGJHBTBKJTAFAGOHAIBBAGHBBGBBBGVBAGGBAGABCGDBBHAGAICHDBBIBBBIBHAGABHIABDGBBAGCHBBBKJGBYBMFaAYAGATAHABBHBIABAGFBDGBBBGVBAGGBAGBBAGBBAGBBBHABAICHBBDHBBBHCBCHABGGDBAGABGKJHBGCHATABJHBIABAGIBAGCBAGVBAGGBAGBBAGEBBHAGAICHEBAHBIABAIBHABBGABOGBHBBBKJTAYABGGAHFBAHAIBBAGHBBGBBBGVBAGGBAGBBAGEBBHAGAIAHAIAHDBBIBBBIBHABGHBIABDGBBAGCHBBBKJaAGAMFBJHAGABAGFBCGCBAGDBCGBBAGABAGBBCGBBCGCBCGLBDIBHAIBBCICBAICHABBGABFIABNKJMCaFYAaABEHAICHAGHBAGCBAGWBAGPBBHAGAHCIDBAHCBAHDBGHBBAGCBBGABBGBHBBBKJBGTAMGaAGAHAIBTAGHBAGCBAGWBAGJBAGEBBHAGAIAHAIEBAHAIBBAIBHBBGIBBFGBBAGBHBBBKJBAGBIABLHBIBGIBAGCBAGoHBGAICHDBAICBAICHAGAaABDGCIAMGGCHBBBKJMIaAGFBAHAIBBAGRBCGXBAGIBAGABBGGBCHABDICHCBAHABAIHBFKJBBIBTABLGvHAGBHGBDYAGFFAHHTAKJTBBkGBBAGABAGEBAGXBAGABAGJHAGBHIGABBGEBAFABAHGBAKJBBGDBfGAaCTOaATAaCHBaFKJMJaAHAaAHAaAHAPAQAPAQAIBGHBAGjBDHNIAHETAHBGEHKBAHjBAaHHAaFBAaBTEaDTBBkGqIBHDIAHFIAHBIBHBGAKJTFGFIBHBGDHCGAICGBIGGCHDGMHAIBHBIFHAGAIAKJICHAaBClBACABECABBDqTAFADCmIFAABAGDBBGGBAGABAGDBBGoBAGDBBGgBAGDBBGGBAGABAGDBBGOBAG4BAGDBBmCBAABBHCTIMTBCGPaJBFiVBAABBDFBBOAmrJAAaATAGQUAGZPAQABCmKBAATCLCGHBGGRHCIABIGSHBIATBBIGRHBBLGMBAGCBAHBBLGzHBIAHGIHHAIBHKTCFATCYAGAHABBKJBFMJBFTFOATDHCcAHAKJBFGiFAG0BGGEHBGhHAGABEmFBAABJGeBAHCIDHBICBDIBHAIFHCBDaABCTBKJGdBBGEBKGrBDGZBFKJMABCahGWHBIBHABBTBG0IAHAIAHGBAHAIAHAIBHHIFHJBBHAKJBFKJBFTGFATFBBHNJAHPBwHDIAGuHAIAHEIAHAIEHAIBGHBCKJTGaJHIaITBBAHBIAGdIAHDIBHBIAHCGBKJGrHAIAHBICHAIAHCIBBHTDGjIHHHIBHBBCTEKJBCGCKJGdFFTBDIBGCqBBCCTHBHHCTAHMIAHGGDHAGFHAGBIAHBGABEDrF+DMFADhFkH/gVCAADHghBAADHCHDFBBCFBBDHCHDHCHDFBBCFBBDHBACABACABACABACADHCHDNBBDHEHDHEHDHEHDEBADBCDEAZADAZCDCBADBCDEAZCDDBBDBCDBAZCDHCEZCBBDCBADBCDEAZBBAUKcEOFTBRASAPARBSAPARATHVAWAcEUATIRASATDNBTCXAPAQATKXATANATJUAcEBAcJMAFABBMFXCPAQAFAMJXCPAQABAFMBCYgBOHMJDHAJCHLBOaBCAaDCAaBDACCDBCCDAaACAaBXACEaFCAaACAaACAaACDaADACDDAGDDAaBDBCBXECADDaAXAaBDAaAMPLiCADALDMAaBBDXEaEXBaDXAaBXAaBXAaGXAaeXBaBXAaAXAae3LEAAaHPAQAPAQAaTXBaGPAQA6QBAAXAadXYanXF6EBAABYaKBUM76NBAAMV62CAAXAaIXAa1XH6uBAAXA63DAAPAQAPAQAPAQAPAQAPAQAPAQAPAQAMdarXEPAQAXePAQAPAQAPAQAPAQAPAQAXP6/DAA3CCAAPAQAPAQAPAQAPAQAPAQAPAQAPAQAPAQAPAQAPAQAPAQAX+PAQAPAQAXfPAQA3BEAAavXUaBXFamBBafBA6oBAACvDvABCCDBAFCCADDACADFFBCBgjBAADAaFADHCCADABETDMATBDlBADABEDABBG3BGFATABNHAGWBIGGBAGGBAGGBAGGBAGGBAGGBAGGBAGGBAHfTBRASARASATCRASATARASATIOATBOATARASATBRASAPAQAPAQAPAQAPAQATEFATJOBTDOATAPATMaBTCPAQAPAQAPAQAPAQAOABhaZBA6YBAABL6VDAABZaLBDUATCaAFAGALAPAQAPAQAPAQAPAQAPAQAaBPAQAPAQAPAQAPAQAOAPAQBaALIHDIBOAFEaBLCFAGATAaBBAmVBAABBHBZBFBGAOAmZBAATAFCGABEGqBAmdBAABAaBMDaJGfajBLGPaeBAMJadMHaAMOafMJamMO6/EAAm/mBAa/mUIFAFAm2RAABCa2BIGnFFTBmLEAAFATCGPKJGBBTAtGAHAJCTAHJTAFAAbFBHBmFBAALJHBTFBHZWFIZBANDBA9FADHADCAAJFAZBADGAADDBATCDABCDAPCCADBECADABADABADAADBXFCCADAGAFBDAGGHAGCHAGDHAGWIBHBIAaDHABCMFaBYAaABFGzTDBHIBGxIPHBBHTBKJBFHRGFTCGATAGBHAKJGbHHTBGWHKIBBKTAGcBCHCIAGuHAIBHDIBHBICTMBAFAKJBDTBGEHAFAGIKJGEBAGoHFIBHBIBHBBIGCHAGHHAIABBKJBBTDGPFAGFaCGAIAHAIAGxHAGAHCGBHBGEHBGAHAGABXGBFATBGKIAHBIBTBGAFBIAHABJGFBBGFBBGFBIGGBAGGBADqZAFDDIFAZBBDjPBAAGiIBHAIBHAIBTAIAHABBKJBFmjuCABLGWBDGwhDgAA9/jBAmtFAABBmpBAABlDGBLDEBEGAHAGJXAGMBAGEBAGABAGBBAGBBAmrBAAZQBPmqFAAQAPAaPG/BBG1BGaABfGLYAaCHPTGPAQATABFHPTAOBNBPAQAPAQAPAQAPAQAPAQAPAQAPAQAPAQATBPAQATDNCTCBATDOAPAQAPAQAPAQATCXAOAXCBATAYATBBDGEBAmGCAABBcABATCYATCPAQATAXATAOATBKJTBXCTBCZPATAQAZANAZADZPAXAQAXAPAQATAPAQATBGJFAGsFBGeBCGFBBGFBBGFBBGCBCYBXAZAaAYBBAaAXDaBBJcCaBBBGLBAGZBAGSBAGBBAGOBBGNBhm6BAABETCBDMsBCaIL0MDaQMBaCBAaMBCaABuasHAhBCAAGcBCGwBOHAMaBDGfMDBIGTLAGHLABEGlHEBEGdBATAGjBDGHTALEBpCnDnmNBAABBKJBFCjBDDjBDGnBHGzBKTACKBACOBACGBACBBADKBADOBADGBADBhCBAAm2EAABIGVBJGHBXFFBAFpBAFIhEBAAGFBBGABAGrBAGBBCGABBGWBATAMHGWaBMGGeBHMIBvGSBAGBBEMEGVMFBCTAGZBETAB/G3BDMBGBMPBBMtGAHCBAHBBEHDGDBAGCBAGcBBHCBDHAMIBGTIBGGcMBTAGcMCBfGHaAGbHBBDMETGBIG1BCTGGVBBMHGSBEMHGRBGTDBLMGhPBAAmIBAAB2CyBMDyBGMFGjHDBHKJhlEAAMeBAGpBAHBOABBGBhKBAAHCGcMJGABHGVHKMDTEBVGRHDTDBlGUMGBTGWBIIAHAIAG0HOTGBDMTKJHAGBHBGABIHCIAGsICHDIBHBTBcATDHABJcABBGYBGKJBFHCGjHEIAHHBAKJTDGAIBGABHGiHATBGABIHBIAGvICHIIBGDTDHDTAIAHAKJGATAGATCBAMTBKGRBAGYICHCIBHAIAHBTFHAGBHAB9GGBAGABAGDBAGOBAGJTABFGuHAICHHBEKJBFHBIBBAGHBBGBBBGVBAGGBAGBBAGEBAHBGAIBHAIDBBIBBBICBBGABFIABEGEIBBBHGBCHEhKCAAG0ICHHIBHCIAHAGDTEKJTBBATAHAGCBdGvICHFIAHAIDHBIAHBGBTAGABHKJhlCAAGuICHDBBIDHBIAHBTWGDHBBhGvICHHIBHAIAHBTCGABKKJBFTMBSGqHAIAHAIBHFIAHAGATABFKJB1GaBBHCIBHDIAHEBDKJMBTCaAGGh4CAAGrICHIIAHBTAhjBAACfDfKJMIBLGHBBGABBGHBAGBBAGXIFBAIBBBHBIAHAGAIAGAIAHATCBIKJhFBAAGHBBGmICHDBBHBIDHAGATAGAIABaGAHJGnHFIAGAHDTHHABHGAHFIBHCGtHMIAHBTCGATEBMmIBAABGTJh1DAAGIBAGkIAHGBAHFIAHAGATEBJKJMSBCTBGdBBHVBAIAHGIAHBIAHBhIBAAGGBAGBBAGlHFBCHABAHBBAHGGAHABHKJBFGFBAGBBAGfIEBAHBBAIBHAIAHAGABGKJh1EAAGSHBIBTBBGHBGAIAGMBAGhIBHEBCIBHAIAHATMKJhVBAAGABOMUaHYDaQBMTAmZOAAhlBAAruBAABATEBKmDDAAhLpAAmgBAATBBMmvQAAcPHAGFHOhp+AAmGJAAh4GCAm4IAABGGeBAKJBDTBmOBAABAKJBFGdBBHETABJGvHGTEaDFDTAaABJKJBAMGBAGUBEGShvKAACfDfMWTDhkBAAmKBAABDHAGAI2BGHDFMB/FBTAFAHABKIBBNm3fBABHmVTAABpGIhmLCAFDBAFGBAFBBAmiEAABOGABcGCBBGABNGDBHmLGAAhDkAAmqBAABEGMBCGIBGGJBBaAHBTAcDhbJBAHtBBHWBI6zBAAB761DAABJamBBa7IBHCaCIFcHHHaBHGadHDa8BU6BBAAHCaAh5BAAMTBLMTBL6WBAABIMYhGCAACZDZCZDGBADRCZDZCABACBBBCABBCBBBCDBACHDDBADABADGBADKCZDZCBBACDBBCHBACGBADZCBBACDBACEBACABCCGBADZCZDZCZDZCZDZCZDZCZDZCZDbBBCYXADYXADFCYXADYXADFCYXADYXADFCYXADYXADFCYXADYXADFCADABBKx6/HAAH2aDHxaHHAaNHAaBTEBOHEBAHOhPRAADJGADTBFDFhUDAAHGBAHQBBHGBAHBBAHEBEF9BgHAhvBAAGsBCHGFGBBKJBDGAaAh/EAAGdHABQGrHDKJBEYAhPHAAGaFAHDKJhlLAAGGBAGDBAGBBAGOBAmEDAABBMIHGBoChDhHGFABDKJBDTBhQMAAM6aAMCYAMDhLBAAMsaAMOhBDAAGDBAGaBAGBBAGABBGABAGJBAGDBAGABAGABFGABDGABAGABAGABAGCBAGBBAGABBGABAGABAGABAGABAGABAGBBAGABBGDBAGGBAGDBAGDBAGABAGJBAGQBEGCBAGEBAGQBzXBhNEAAarBD6jBAABLaOBBaOBAaOBAakBJMM6gCAAB3acBMarBDaIBGaBBNaFhZCAA66DAAZE6XLAABDaQBCaMBC62BAABD6eBAABFaLBDaABOaLBDa3BHaJBFanBHadBBaBhNBAA6TFAABLaNBBaMBCaIBGatBAaGBHaNBDaIBGaIBG6SCAABAa2BkKJhFQAAmfbKABfm5ABABFmdDAABBmBaBABNmw0BAhewAAmdIAAhhXAAmKNBABEmfBBAhQxtCcABd8fBAAh/BAAnvDAAhP4PA99/PABB99/PA"); function O(A) { return 32 === A || 9 === A || 10 === A || 13 === A } const k = [a(b(":")), n(b("A"), b("Z")), a(b("_")), n(b("a"), b("z")), n(192, 214), n(216, 246), n(192, 214), n(216, 246), n(248, 767), n(880, 893), n(895, 8191), n(8204, 8205), n(8304, 8591), n(11264, 12271), n(12289, 55295), n(63744, 64975), n(65008, 65533), n(65536, 983039)].reduce(G), N = [k, a(b("-")), a(b(".")), n(b("0"), b("9")), a(183), n(768, 879), n(8255, 8256)].reduce(G), v = Z.get("Nd"), w = Q(v), Y = L(n(0, 1114111), [Z.get("P"), Z.get("Z"), Z.get("C")].reduce(G)), U = Q(Y); function j(A) { return 10 !== A && 13 !== A && !x(A) } const R = { s: O, S: Q(O), i: k, I: Q(k), c: N, C: Q(N), d: v, D: w, w: Y, W: U }, V = c("*"), W = c("\\"), q = c("{"), z = c("}"), $ = c("["), _ = c("]"), AA = c("^"), BA = c("$"), aA = c(","), nA = c("-"), eA = c("("), tA = c(")"), GA = c("."), iA = c("|"), rA = c("+"), oA = c("?"), lA = c("-["), HA = b("0"); function uA(A) { function B(A) { return new Set(A.split("").map((A => b(A)))) } function t(A, B) { const a = A.codePointAt(B); return void 0 === a ? s(B, ["any character"]) : u(B + String.fromCodePoint(a).length, a) } const o = "xpath" === A.language ? E(W, d([D(c("n"), (() => 10)), D(c("r"), (() => 13)), D(c("t"), (() => 9)), D(d([W, iA, GA, nA, AA, oA, V, rA, q, z, BA, eA, tA, $, _]), (A => b(A)))])) : E(W, d([D(c("n"), (() => 10)), D(c("r"), (() => 13)), D(c("t"), (() => 9)), D(d([W, iA, GA, nA, AA, oA, V, rA, q, z, eA, tA, $, _]), (A => b(A)))])); function l(A, a) { const n = B(a); return p(c(A), I(m(t, (A => n.has(A)), a.split(""))), ((A, B) => function (A) { const B = Z.get(A); if (null == B) throw new Error(`${A} is not a valid unicode category`); return B }(null === B ? A : A + String.fromCodePoint(B)))) } const H = d([l("L", "ultmo"), l("M", "nce"), l("N", "dlo"), l("P", "cdseifo"), l("Z", "slp"), l("S", "mcko"), l("C", "cfon")]), C = [n(b("a"), b("z")), n(b("A"), b("Z")), n(b("0"), b("9")), a(45)].reduce(G), F = D(E(c("Is"), function (A) { return (B, a) => { const n = A(B, a); return n.success ? u(n.offset, B.slice(a, n.offset)) : n } }(T(m(t, C, ["block identifier"])))), (B => function (A, B) { const a = X.get(A); if (void 0 === a) { if (B) return e; throw new Error(`The unicode block identifier "${A}" is not known.`) } return a }(B, "xpath" !== A.language))), K = d([H, F]), y = M(c("\\p{"), K, z, !0), x = D(M(c("\\P{"), K, z, !0), Q), O = E(W, D(d("sSiIcCdDwW".split("").map((A => c(A)))), (A => R[A]))), k = D(GA, (() => j)), N = d([O, y, x]), v = B("\\[]"), w = m(t, (A => !v.has(A)), ["unescaped character"]), Y = d([o, w]), U = d([D(nA, (() => null)), Y]), uA = p(U, E(nA, U), n); function CA(A, B) { return [A].concat(B || []) } const sA = D(function (A) { return (B, a) => { const n = A(B, a); return n.success ? u(a, n.value) : n } }(d([_, lA])), (() => null)), cA = b("-"), DA = d([D(g(g(nA, P($, ["not ["])), sA), (() => cA)), E(P(nA, ["not -"]), Y)]), mA = d([p(D(DA, a), d([function (A, B) { return mA(A, B) }, sA]), CA), p(d([uA, N]), d([IA, sA]), CA)]); const dA = d([p(D(Y, a), d([mA, sA]), CA), p(d([uA, N]), d([IA, sA]), CA)]); function IA(A, B) { return dA(A, B) } const hA = D(dA, (A => A.reduce(G))), pA = D(E(AA, hA), Q), TA = p(d([E(P(AA, ["not ^"]), hA), pA]), I(E(nA, (function (A, B) { return fA(A, B) }))), L), fA = M($, TA, _, !0); const FA = "xpath" === A.language ? d([D(o, a), N, fA, k, D(AA, (() => A => A === i)), D(BA, (() => A => A === r))]) : d([D(o, a), N, fA, k]), EA = "xpath" === A.language ? B(".\\?*+{}()|^$[]") : B(".\\?*+{}()|[]"), gA = m(t, (A => !EA.has(A)), ["NormalChar"]), MA = D(E(W, p(D(m(t, n(b("1"), b("9")), ["digit"]), (A => A - HA)), h(D(m(t, n(HA, b("9")), ["digit"]), (A => A - HA))), ((A, B) => { B.reduce(((A, B) => 10 * A + B), A) }))), (A => { throw new Error("Backreferences in XPath patterns are not yet implemented.") })), PA = "xpath" === A.language ? d([D(gA, (A => ({ kind: "predicate", value: a(A) }))), D(FA, (A => ({ kind: "predicate", value: A }))), D(M(eA, E(I(c("?:")), QA), tA, !0), (A => ({ kind: "regexp", value: A }))), MA]) : d([D(gA, (A => ({ kind: "predicate", value: a(A) }))), D(FA, (A => ({ kind: "predicate", value: A }))), D(M(eA, QA, tA, !0), (A => ({ kind: "regexp", value: A })))]), JA = D(T(D(m(t, n(HA, b("9")), ["digit"]), (A => A - HA))), (A => A.reduce(((A, B) => 10 * A + B)))), SA = d([p(JA, E(aA, JA), ((A, B) => { if (B < A) throw new Error("quantifier range is in the wrong order"); return { min: A, max: B } })), p(JA, aA, (A => ({ min: A, max: null }))), D(JA, (A => ({ min: A, max: A })))]), KA = "xpath" === A.language ? p(d([D(oA, (() => ({ min: 0, max: 1 }))), D(V, (() => ({ min: 0, max: null }))), D(rA, (() => ({ min: 1, max: null }))), M(q, SA, z, !0)]), I(oA), ((A, B) => A)) : d([D(oA, (() => ({ min: 0, max: 1 }))), D(V, (() => ({ min: 0, max: null }))), D(rA, (() => ({ min: 1, max: null }))), M(q, SA, z, !0)]), yA = p(PA, D(I(KA), (A => null === A ? { min: 1, max: 1 } : A)), ((A, B) => [A, B])), bA = h(yA), xA = p(bA, h(E(iA, J(bA))), ((A, B) => [A].concat(B))); function QA(A, B) { return xA(A, B) } const LA = function (A) { return p(A, S, f) }(xA); return function (A) { let B; try { B = LA(A, 0) } catch (B) { throw new Error(`Error parsing pattern "${A}": ${B instanceof Error ? B.message : B}`) } return B.success ? B.value : function (A, B, a) { const n = a.map((A => `"${A}"`)); throw new Error(`Error parsing pattern "${A}" at offset ${B}: expected ${n.length > 1 ? "one of " + n.join(", ") : n[0]} but found "${A.slice(B, B + 1)}"`) }(A, B.offset, B.expected) } } function CA(A) { return [...A].map((A => A.codePointAt(0))) } A.compile = function (A, a = { language: "xsd" }) { const n = uA(a)(A), e = B.compileVM((A => { H(A, n, "xpath" === a.language), A.accept() })); return function (A) { const B = "xpath" === a.language ? [i, ...CA(A), r] : CA(A); return e.execute(B).success } }, Object.defineProperty(A, "__esModule", { value: !0 }) }));
+
+	// fontoxpath 3.29.0
+
+	// 	MIT License
+
+	// Copyright (c) 2017 Fonto Group BV
+
+	// Permission is hereby granted, free of charge, to any person obtaining a copy
+	// of this software and associated documentation files (the "Software"), to deal
+	// in the Software without restriction, including without limitation the rights
+	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+	// copies of the Software, and to permit persons to whom the Software is
+	// furnished to do so, subject to the following conditions:
+
+	// The above copyright notice and this permission notice shall be included in all
+	// copies or substantial portions of the Software.
+
+	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+	// SOFTWARE.
+
+	(function (root, factory) {
+
+		// Browser globals (root is window)
+		// Maybe it is in scope:
+		root.fontoxpath = factory(root.xspattern, root.prsc);
+	})(this, function (xspattern, prsc) {
+		return (function (xspattern, prsc) {
+			const VERSION = '3.29.0';
+			const fontoxpathGlobal = {};
+			var h; function aa(a) { var b = 0; return function () { return b < a.length ? { done: !1, value: a[b++] } : { done: !0 } } } var ba = "function" == typeof Object.defineProperties ? Object.defineProperty : function (a, b, c) { if (a == Array.prototype || a == Object.prototype) return a; a[b] = c.value; return a };
+			function ca(a) { a = ["object" == typeof globalThis && globalThis, a, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global]; for (var b = 0; b < a.length; ++b) { var c = a[b]; if (c && c.Math == Math) return c } throw Error("Cannot find global object"); } var da = ca(this); "function" === typeof Symbol && Symbol("x");
+			function fa(a, b) { if (b) a: { var c = da; a = a.split("."); for (var d = 0; d < a.length - 1; d++) { var e = a[d]; if (!(e in c)) break a; c = c[e] } a = a[a.length - 1]; d = c[a]; b = b(d); b != d && null != b && ba(c, a, { configurable: !0, writable: !0, value: b }) } }
+			fa("Symbol", function (a) { function b(f) { if (this instanceof b) throw new TypeError("Symbol is not a constructor"); return new c(d + (f || "") + "_" + e++, f) } function c(f, g) { this.h = f; ba(this, "description", { configurable: !0, writable: !0, value: g }) } if (a) return a; c.prototype.toString = function () { return this.h }; var d = "jscomp_symbol_" + (1E9 * Math.random() >>> 0) + "_", e = 0; return b });
+			fa("Symbol.iterator", function (a) { if (a) return a; a = Symbol("Symbol.iterator"); for (var b = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), c = 0; c < b.length; c++) { var d = da[b[c]]; "function" === typeof d && "function" != typeof d.prototype[a] && ba(d.prototype, a, { configurable: !0, writable: !0, value: function () { return ha(aa(this)) } }) } return a }); fa("Symbol.asyncIterator", function (a) { return a ? a : Symbol("Symbol.asyncIterator") });
+			function ha(a) { a = { next: a }; a[Symbol.iterator] = function () { return this }; return a } function p(a) { var b = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator]; return b ? b.call(a) : { next: aa(a) } } function ja(a) { for (var b, c = []; !(b = a.next()).done;)c.push(b.value); return c } function t(a) { return a instanceof Array ? a : ja(p(a)) } var ka = "function" == typeof Object.create ? Object.create : function (a) { function b() { } b.prototype = a; return new b }, la;
+			if ("function" == typeof Object.setPrototypeOf) la = Object.setPrototypeOf; else { var ma; a: { var na = { a: !0 }, pa = {}; try { pa.__proto__ = na; ma = pa.a; break a } catch (a) { } ma = !1 } la = ma ? function (a, b) { a.__proto__ = b; if (a.__proto__ !== b) throw new TypeError(a + " is not extensible"); return a } : null } var qa = la;
+			function v(a, b) { a.prototype = ka(b.prototype); a.prototype.constructor = a; if (qa) qa(a, b); else for (var c in b) if ("prototype" != c) if (Object.defineProperties) { var d = Object.getOwnPropertyDescriptor(b, c); d && Object.defineProperty(a, c, d) } else a[c] = b[c]; a.zc = b.prototype } function ra() { this.B = !1; this.o = null; this.l = void 0; this.h = 1; this.da = 0; this.v = null } function sa(a) { if (a.B) throw new TypeError("Generator is already running"); a.B = !0 } ra.prototype.s = function (a) { this.l = a }; function ta(a, b) { a.v = { kc: b, mc: !0 }; a.h = a.da }
+			ra.prototype.return = function (a) { this.v = { return: a }; this.h = this.da }; function ua(a) { this.h = new ra; this.o = a } function va(a, b) { sa(a.h); var c = a.h.o; if (c) return wa(a, "return" in c ? c["return"] : function (d) { return { value: d, done: !0 } }, b, a.h.return); a.h.return(b); return xa(a) }
+			function wa(a, b, c, d) { try { var e = b.call(a.h.o, c); if (!(e instanceof Object)) throw new TypeError("Iterator result " + e + " is not an object"); if (!e.done) return a.h.B = !1, e; var f = e.value } catch (g) { return a.h.o = null, ta(a.h, g), xa(a) } a.h.o = null; d.call(a.h, f); return xa(a) } function xa(a) { for (; a.h.h;)try { var b = a.o(a.h); if (b) return a.h.B = !1, { value: b.value, done: !1 } } catch (c) { a.h.l = void 0, ta(a.h, c) } a.h.B = !1; if (a.h.v) { b = a.h.v; a.h.v = null; if (b.mc) throw b.kc; return { value: b.return, done: !0 } } return { value: void 0, done: !0 } }
+			function ya(a) { this.next = function (b) { sa(a.h); a.h.o ? b = wa(a, a.h.o.next, b, a.h.s) : (a.h.s(b), b = xa(a)); return b }; this.throw = function (b) { sa(a.h); a.h.o ? b = wa(a, a.h.o["throw"], b, a.h.s) : (ta(a.h, b), b = xa(a)); return b }; this.return = function (b) { return va(a, b) }; this[Symbol.iterator] = function () { return this } } function za(a) { function b(d) { return a.next(d) } function c(d) { return a.throw(d) } return new Promise(function (d, e) { function f(g) { g.done ? d(g.value) : Promise.resolve(g.value).then(b, c).then(f, e) } f(a.next()) }) }
+			function Aa() { for (var a = Number(this), b = [], c = a; c < arguments.length; c++)b[c - a] = arguments[c]; return b }
+			fa("Promise", function (a) {
+				function b(g) { this.o = 0; this.v = void 0; this.h = []; this.da = !1; var k = this.B(); try { g(k.resolve, k.reject) } catch (l) { k.reject(l) } } function c() { this.h = null } function d(g) { return g instanceof b ? g : new b(function (k) { k(g) }) } if (a) return a; c.prototype.o = function (g) { if (null == this.h) { this.h = []; var k = this; this.v(function () { k.l() }) } this.h.push(g) }; var e = da.setTimeout; c.prototype.v = function (g) { e(g, 0) }; c.prototype.l = function () {
+					for (; this.h && this.h.length;) {
+						var g = this.h; this.h = []; for (var k = 0; k < g.length; ++k) {
+							var l =
+								g[k]; g[k] = null; try { l() } catch (m) { this.B(m) }
+						}
+					} this.h = null
+				}; c.prototype.B = function (g) { this.v(function () { throw g; }) }; b.prototype.B = function () { function g(m) { return function (q) { l || (l = !0, m.call(k, q)) } } var k = this, l = !1; return { resolve: g(this.la), reject: g(this.l) } }; b.prototype.la = function (g) {
+					if (g === this) this.l(new TypeError("A Promise cannot resolve to itself")); else if (g instanceof b) this.ab(g); else {
+						a: switch (typeof g) { case "object": var k = null != g; break a; case "function": k = !0; break a; default: k = !1 }k ? this.S(g) :
+							this.s(g)
+					}
+				}; b.prototype.S = function (g) { var k = void 0; try { k = g.then } catch (l) { this.l(l); return } "function" == typeof k ? this.Ba(k, g) : this.s(g) }; b.prototype.l = function (g) { this.ta(2, g) }; b.prototype.s = function (g) { this.ta(1, g) }; b.prototype.ta = function (g, k) { if (0 != this.o) throw Error("Cannot settle(" + g + ", " + k + "): Promise already settled in state" + this.o); this.o = g; this.v = k; 2 === this.o && this.pa(); this.A() }; b.prototype.pa = function () {
+					var g = this; e(function () { if (g.K()) { var k = da.console; "undefined" !== typeof k && k.error(g.v) } },
+						1)
+				}; b.prototype.K = function () { if (this.da) return !1; var g = da.CustomEvent, k = da.Event, l = da.dispatchEvent; if ("undefined" === typeof l) return !0; "function" === typeof g ? g = new g("unhandledrejection", { cancelable: !0 }) : "function" === typeof k ? g = new k("unhandledrejection", { cancelable: !0 }) : (g = da.document.createEvent("CustomEvent"), g.initCustomEvent("unhandledrejection", !1, !0, g)); g.promise = this; g.reason = this.v; return l(g) }; b.prototype.A = function () {
+					if (null != this.h) {
+						for (var g = 0; g < this.h.length; ++g)f.o(this.h[g]); this.h =
+							null
+					}
+				}; var f = new c; b.prototype.ab = function (g) { var k = this.B(); g.rb(k.resolve, k.reject) }; b.prototype.Ba = function (g, k) { var l = this.B(); try { g.call(k, l.resolve, l.reject) } catch (m) { l.reject(m) } }; b.prototype.then = function (g, k) { function l(z, A) { return "function" == typeof z ? function (D) { try { m(z(D)) } catch (F) { q(F) } } : A } var m, q, u = new b(function (z, A) { m = z; q = A }); this.rb(l(g, m), l(k, q)); return u }; b.prototype.catch = function (g) { return this.then(void 0, g) }; b.prototype.rb = function (g, k) {
+					function l() {
+						switch (m.o) {
+							case 1: g(m.v);
+								break; case 2: k(m.v); break; default: throw Error("Unexpected state: " + m.o);
+						}
+					} var m = this; null == this.h ? f.o(l) : this.h.push(l); this.da = !0
+				}; b.resolve = d; b.reject = function (g) { return new b(function (k, l) { l(g) }) }; b.race = function (g) { return new b(function (k, l) { for (var m = p(g), q = m.next(); !q.done; q = m.next())d(q.value).rb(k, l) }) }; b.all = function (g) {
+					var k = p(g), l = k.next(); return l.done ? d([]) : new b(function (m, q) {
+						function u(D) { return function (F) { z[D] = F; A--; 0 == A && m(z) } } var z = [], A = 0; do z.push(void 0), A++, d(l.value).rb(u(z.length -
+							1), q), l = k.next(); while (!l.done)
+					})
+				}; return b
+			}); function Ca(a, b) { return Object.prototype.hasOwnProperty.call(a, b) } var Da = "function" == typeof Object.assign ? Object.assign : function (a, b) { for (var c = 1; c < arguments.length; c++) { var d = arguments[c]; if (d) for (var e in d) Ca(d, e) && (a[e] = d[e]) } return a }; fa("Object.assign", function (a) { return a || Da });
+			function Ea(a, b, c) { if (null == a) throw new TypeError("The 'this' value for String.prototype." + c + " must not be null or undefined"); if (b instanceof RegExp) throw new TypeError("First argument to String.prototype." + c + " must not be a regular expression"); return a + "" } fa("String.prototype.repeat", function (a) { return a ? a : function (b) { var c = Ea(this, null, "repeat"); if (0 > b || 1342177279 < b) throw new RangeError("Invalid count value"); b |= 0; for (var d = ""; b;)if (b & 1 && (d += c), b >>>= 1) c += c; return d } });
+			function Fa(a, b) { a = void 0 !== a ? String(a) : " "; return 0 < b && a ? a.repeat(Math.ceil(b / a.length)).substring(0, b) : "" } fa("String.prototype.padEnd", function (a) { return a ? a : function (b, c) { var d = Ea(this, null, "padStart"); return d + Fa(c, b - d.length) } });
+			fa("WeakMap", function (a) {
+				function b(l) { this.h = (k += Math.random() + 1).toString(); if (l) { l = p(l); for (var m; !(m = l.next()).done;)m = m.value, this.set(m[0], m[1]) } } function c() { } function d(l) { var m = typeof l; return "object" === m && null !== l || "function" === m } function e(l) { if (!Ca(l, g)) { var m = new c; ba(l, g, { value: m }) } } function f(l) { var m = Object[l]; m && (Object[l] = function (q) { if (q instanceof c) return q; Object.isExtensible(q) && e(q); return m(q) }) } if (function () {
+					if (!a || !Object.seal) return !1; try {
+						var l = Object.seal({}), m = Object.seal({}),
+						q = new a([[l, 2], [m, 3]]); if (2 != q.get(l) || 3 != q.get(m)) return !1; q.delete(l); q.set(m, 4); return !q.has(l) && 4 == q.get(m)
+					} catch (u) { return !1 }
+				}()) return a; var g = "$jscomp_hidden_" + Math.random(); f("freeze"); f("preventExtensions"); f("seal"); var k = 0; b.prototype.set = function (l, m) { if (!d(l)) throw Error("Invalid WeakMap key"); e(l); if (!Ca(l, g)) throw Error("WeakMap key fail: " + l); l[g][this.h] = m; return this }; b.prototype.get = function (l) { return d(l) && Ca(l, g) ? l[g][this.h] : void 0 }; b.prototype.has = function (l) {
+					return d(l) && Ca(l,
+						g) && Ca(l[g], this.h)
+				}; b.prototype.delete = function (l) { return d(l) && Ca(l, g) && Ca(l[g], this.h) ? delete l[g][this.h] : !1 }; return b
+			});
+			fa("Map", function (a) {
+				function b() { var k = {}; return k.Ga = k.next = k.head = k } function c(k, l) { var m = k.h; return ha(function () { if (m) { for (; m.head != k.h;)m = m.Ga; for (; m.next != m.head;)return m = m.next, { done: !1, value: l(m) }; m = null } return { done: !0, value: void 0 } }) } function d(k, l) {
+					var m = l && typeof l; "object" == m || "function" == m ? f.has(l) ? m = f.get(l) : (m = "" + ++g, f.set(l, m)) : m = "p_" + l; var q = k.o[m]; if (q && Ca(k.o, m)) for (k = 0; k < q.length; k++) { var u = q[k]; if (l !== l && u.key !== u.key || l === u.key) return { id: m, list: q, index: k, ka: u } } return {
+						id: m,
+						list: q, index: -1, ka: void 0
+					}
+				} function e(k) { this.o = {}; this.h = b(); this.size = 0; if (k) { k = p(k); for (var l; !(l = k.next()).done;)l = l.value, this.set(l[0], l[1]) } } if (function () {
+					if (!a || "function" != typeof a || !a.prototype.entries || "function" != typeof Object.seal) return !1; try {
+						var k = Object.seal({ x: 4 }), l = new a(p([[k, "s"]])); if ("s" != l.get(k) || 1 != l.size || l.get({ x: 4 }) || l.set({ x: 4 }, "t") != l || 2 != l.size) return !1; var m = l.entries(), q = m.next(); if (q.done || q.value[0] != k || "s" != q.value[1]) return !1; q = m.next(); return q.done || 4 != q.value[0].x ||
+							"t" != q.value[1] || !m.next().done ? !1 : !0
+					} catch (u) { return !1 }
+				}()) return a; var f = new WeakMap; e.prototype.set = function (k, l) { k = 0 === k ? 0 : k; var m = d(this, k); m.list || (m.list = this.o[m.id] = []); m.ka ? m.ka.value = l : (m.ka = { next: this.h, Ga: this.h.Ga, head: this.h, key: k, value: l }, m.list.push(m.ka), this.h.Ga.next = m.ka, this.h.Ga = m.ka, this.size++); return this }; e.prototype.delete = function (k) {
+					k = d(this, k); return k.ka && k.list ? (k.list.splice(k.index, 1), k.list.length || delete this.o[k.id], k.ka.Ga.next = k.ka.next, k.ka.next.Ga = k.ka.Ga,
+						k.ka.head = null, this.size--, !0) : !1
+				}; e.prototype.clear = function () { this.o = {}; this.h = this.h.Ga = b(); this.size = 0 }; e.prototype.has = function (k) { return !!d(this, k).ka }; e.prototype.get = function (k) { return (k = d(this, k).ka) && k.value }; e.prototype.entries = function () { return c(this, function (k) { return [k.key, k.value] }) }; e.prototype.keys = function () { return c(this, function (k) { return k.key }) }; e.prototype.values = function () { return c(this, function (k) { return k.value }) }; e.prototype.forEach = function (k, l) {
+					for (var m = this.entries(),
+						q; !(q = m.next()).done;)q = q.value, k.call(l, q[1], q[0], this)
+				}; e.prototype[Symbol.iterator] = e.prototype.entries; var g = 0; return e
+			}); function Ga(a, b, c) { a instanceof String && (a = String(a)); for (var d = a.length, e = 0; e < d; e++) { var f = a[e]; if (b.call(c, f, e, a)) return { Jb: e, Qb: f } } return { Jb: -1, Qb: void 0 } } fa("Array.prototype.find", function (a) { return a ? a : function (b, c) { return Ga(this, b, c).Qb } });
+			fa("String.prototype.startsWith", function (a) { return a ? a : function (b, c) { var d = Ea(this, b, "startsWith"), e = d.length, f = b.length; c = Math.max(0, Math.min(c | 0, d.length)); for (var g = 0; g < f && c < e;)if (d[c++] != b[g++]) return !1; return g >= f } }); fa("Array.prototype.fill", function (a) { return a ? a : function (b, c, d) { var e = this.length || 0; 0 > c && (c = Math.max(0, e + c)); if (null == d || d > e) d = e; d = Number(d); 0 > d && (d = Math.max(0, e + d)); for (c = Number(c || 0); c < d; c++)this[c] = b; return this } }); function Ha(a) { return a ? a : Array.prototype.fill }
+			fa("Int8Array.prototype.fill", Ha); fa("Uint8Array.prototype.fill", Ha); fa("Uint8ClampedArray.prototype.fill", Ha); fa("Int16Array.prototype.fill", Ha); fa("Uint16Array.prototype.fill", Ha); fa("Int32Array.prototype.fill", Ha); fa("Uint32Array.prototype.fill", Ha); fa("Float32Array.prototype.fill", Ha); fa("Float64Array.prototype.fill", Ha);
+			fa("Array.from", function (a) { return a ? a : function (b, c, d) { c = null != c ? c : function (k) { return k }; var e = [], f = "undefined" != typeof Symbol && Symbol.iterator && b[Symbol.iterator]; if ("function" == typeof f) { b = f.call(b); for (var g = 0; !(f = b.next()).done;)e.push(c.call(d, f.value, g++)) } else for (f = b.length, g = 0; g < f; g++)e.push(c.call(d, b[g], g)); return e } }); fa("Object.is", function (a) { return a ? a : function (b, c) { return b === c ? 0 !== b || 1 / b === 1 / c : b !== b && c !== c } });
+			fa("Array.prototype.includes", function (a) { return a ? a : function (b, c) { var d = this; d instanceof String && (d = String(d)); var e = d.length; c = c || 0; for (0 > c && (c = Math.max(c + e, 0)); c < e; c++) { var f = d[c]; if (f === b || Object.is(f, b)) return !0 } return !1 } }); fa("String.prototype.includes", function (a) { return a ? a : function (b, c) { return -1 !== Ea(this, b, "includes").indexOf(b, c || 0) } }); fa("Number.MAX_SAFE_INTEGER", function () { return 9007199254740991 }); fa("Number.MIN_SAFE_INTEGER", function () { return -9007199254740991 });
+			fa("Math.trunc", function (a) { return a ? a : function (b) { b = Number(b); if (isNaN(b) || Infinity === b || -Infinity === b || 0 === b) return b; var c = Math.floor(Math.abs(b)); return 0 > b ? -c : c } }); fa("Number.isFinite", function (a) { return a ? a : function (b) { return "number" !== typeof b ? !1 : !isNaN(b) && Infinity !== b && -Infinity !== b } }); fa("String.prototype.padStart", function (a) { return a ? a : function (b, c) { var d = Ea(this, null, "padStart"); return Fa(c, b - d.length) + d } });
+			function Ia(a, b) { a instanceof String && (a += ""); var c = 0, d = !1, e = { next: function () { if (!d && c < a.length) { var f = c++; return { value: b(f, a[f]), done: !1 } } d = !0; return { done: !0, value: void 0 } } }; e[Symbol.iterator] = function () { return e }; return e } fa("Array.prototype.keys", function (a) { return a ? a : function () { return Ia(this, function (b) { return b }) } }); fa("Number.isInteger", function (a) { return a ? a : function (b) { return Number.isFinite(b) ? b === Math.floor(b) : !1 } });
+			fa("Number.isSafeInteger", function (a) { return a ? a : function (b) { return Number.isInteger(b) && Math.abs(b) <= Number.MAX_SAFE_INTEGER } }); fa("Array.prototype.findIndex", function (a) { return a ? a : function (b, c) { return Ga(this, b, c).Jb } }); fa("String.prototype.endsWith", function (a) { return a ? a : function (b, c) { var d = Ea(this, b, "endsWith"); void 0 === c && (c = d.length); c = Math.max(0, Math.min(c | 0, d.length)); for (var e = b.length; 0 < e && 0 < c;)if (d[--c] != b[--e]) return !1; return 0 >= e } });
+			fa("String.fromCodePoint", function (a) { return a ? a : function (b) { for (var c = "", d = 0; d < arguments.length; d++) { var e = Number(arguments[d]); if (0 > e || 1114111 < e || e !== Math.floor(e)) throw new RangeError("invalid_code_point " + e); 65535 >= e ? c += String.fromCharCode(e) : (e -= 65536, c += String.fromCharCode(e >>> 10 & 1023 | 55296), c += String.fromCharCode(e & 1023 | 56320)) } return c } });
+			fa("String.prototype.codePointAt", function (a) { return a ? a : function (b) { var c = Ea(this, null, "codePointAt"), d = c.length; b = Number(b) || 0; if (0 <= b && b < d) { b |= 0; var e = c.charCodeAt(b); if (55296 > e || 56319 < e || b + 1 === d) return e; b = c.charCodeAt(b + 1); return 56320 > b || 57343 < b ? e : 1024 * (e - 55296) + b + 9216 } } });
+			fa("Set", function (a) {
+				function b(c) { this.h = new Map; if (c) { c = p(c); for (var d; !(d = c.next()).done;)this.add(d.value) } this.size = this.h.size } if (function () {
+					if (!a || "function" != typeof a || !a.prototype.entries || "function" != typeof Object.seal) return !1; try {
+						var c = Object.seal({ x: 4 }), d = new a(p([c])); if (!d.has(c) || 1 != d.size || d.add(c) != d || 1 != d.size || d.add({ x: 4 }) != d || 2 != d.size) return !1; var e = d.entries(), f = e.next(); if (f.done || f.value[0] != c || f.value[1] != c) return !1; f = e.next(); return f.done || f.value[0] == c || 4 != f.value[0].x ||
+							f.value[1] != f.value[0] ? !1 : e.next().done
+					} catch (g) { return !1 }
+				}()) return a; b.prototype.add = function (c) { c = 0 === c ? 0 : c; this.h.set(c, c); this.size = this.h.size; return this }; b.prototype.delete = function (c) { c = this.h.delete(c); this.size = this.h.size; return c }; b.prototype.clear = function () { this.h.clear(); this.size = 0 }; b.prototype.has = function (c) { return this.h.has(c) }; b.prototype.entries = function () { return this.h.entries() }; b.prototype.values = function () { return this.h.values() }; b.prototype.keys = b.prototype.values; b.prototype[Symbol.iterator] =
+					b.prototype.values; b.prototype.forEach = function (c, d) { var e = this; this.h.forEach(function (f) { return c.call(d, f, f, e) }) }; return b
+			}); fa("Math.log10", function (a) { return a ? a : function (b) { return Math.log(b) / Math.LN10 } }); fa("Object.values", function (a) { return a ? a : function (b) { var c = [], d; for (d in b) Ca(b, d) && c.push(b[d]); return c } }); fa("Number.isNaN", function (a) { return a ? a : function (b) { return "number" === typeof b && isNaN(b) } });
+			fa("Array.prototype.values", function (a) { return a ? a : function () { return Ia(this, function (b, c) { return c }) } }); fa("Object.getOwnPropertySymbols", function (a) { return a ? a : function () { return [] } }); function Ka(a, b) { if (!("0" !== a && "-0" !== a || "0" !== b && "-0" !== b)) return 0; var c = /(?:\+|(-))?(\d+)?(?:\.(\d+))?/; a = c.exec(a + ""); var d = c.exec(b + ""), e = !a[1], f = !d[1]; b = (a[2] || "").replace(/^0*/, ""); c = (d[2] || "").replace(/^0*/, ""); a = a[3] || ""; d = d[3] || ""; if (e && !f) return 1; if (!e && f) return -1; e = e && f; if (b.length > c.length) return e ? 1 : -1; if (b.length < c.length) return e ? -1 : 1; if (b > c) return e ? 1 : -1; if (b < c) return e ? -1 : 1; b = Math.max(a.length, d.length); c = a.padEnd(b, "0"); b = d.padEnd(b, "0"); return c > b ? e ? 1 : -1 : c < b ? e ? -1 : 1 : 0 }; function La(a, b) { a = a.toString(); if (-1 < a.indexOf(".") && 0 === b) return !1; a = /^[-+]?0*([1-9]\d*)?(?:\.((?:\d*[1-9])*)0*)?$/.exec(a); return a[2] ? a[2].length <= b : !0 } function Ma() { return function (a, b) { return 1 > Ka(a, b) } } function Na() { return function (a, b) { return 0 > Ka(a, b) } } function Oa() { return function (a, b) { return -1 < Ka(a, b) } } function Pa() { return function (a, b) { return 0 < Ka(a, b) } }
+			function Qa(a, b) { switch (b) { case "required": return /(Z)|([+-])([01]\d):([0-5]\d)$/.test(a.toString()); case "prohibited": return !/(Z)|([+-])([01]\d):([0-5]\d)$/.test(a.toString()); case "optional": return !0 } } function Sa(a) { switch (a) { case 1: case 0: case 6: case 3: return {}; case 4: return { na: La, ya: Ma(), xc: Na(), za: Oa(), yc: Pa() }; case 18: return {}; case 9: case 8: case 7: case 11: case 12: case 13: case 15: case 14: return { Ea: Qa }; case 22: case 21: case 20: case 23: case 44: return {}; default: return null } } var Ta = {}, Ua = {}; function Va(a) { return /^([+-]?(\d*(\.\d*)?([eE][+-]?\d*)?|INF)|NaN)$/.test(a) } function Wa(a) { return /^[_:A-Za-z][-._:A-Za-z0-9]*$/.test(a) } function Xa(a) { return Wa(a) && /^[_A-Za-z]([-._A-Za-z0-9])*$/.test(a) } function Ya(a) { a = a.split(":"); return 1 === a.length ? Xa(a[0]) : 2 !== a.length ? !1 : Xa(a[0]) && Xa(a[1]) } function Za(a) { return !/[\u0009\u000A\u000D]/.test(a) } function $a(a) { return Xa(a) }
+			var ab = new Map([[45, function () { return !0 }], [46, function () { return !0 }], [1, function () { return !0 }], [0, function (a) { return /^(0|1|true|false)$/.test(a) }], [6, function (a) { return Va(a) }], [3, Va], [4, function (a) { return /^[+-]?\d*(\.\d*)?$/.test(a) }], [18, function (a) { return /^(-)?P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+(\.\d*)?S)?)?$/.test(a) }], [9, function (a) { return /^-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?|(24:00:00(\.0+)?))(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a) }],
+			[8, function (a) { return /^(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?|(24:00:00(\.0+)?))(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a) }], [7, function (a) { return /^-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a) }], [11, function (a) { return /^-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a) }], [12, function (a) { return /^-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a) }],
+			[13, function (a) { return /^--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a) }], [15, function (a) { return /^---(0[1-9]|[12][0-9]|3[01])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a) }], [14, function (a) { return /^--(0[1-9]|1[0-2])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$/.test(a) }], [22, function (a) { return /^([0-9A-Fa-f]{2})*$/.test(a) }], [21, function (a) { return (new RegExp(/^((([A-Za-z0-9+/] ?){4})*((([A-Za-z0-9+/] ?){3}[A-Za-z0-9+/])|(([A-Za-z0-9+/] ?){2}[AEIMQUYcgkosw048] ?=)|(([A-Za-z0-9+/] ?)[AQgw] ?= ?=)))?$/)).test(a) }],
+			[20, function () { return !0 }], [44, Ya], [48, Za], [52, function (a) { return Za(a) && !/^ | {2,}| $/.test(a) }], [51, function (a) { return /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/.test(a) }], [50, function (a) { return /^[-._:A-Za-z0-9]+$/.test(a) }], [25, Wa], [23, Ya], [24, Xa], [42, $a], [41, $a], [26, function (a) { return Xa(a) }], [5, function (a) { return /^[+-]?\d+$/.test(a) }], [16, function (a) { return /^-?P[0-9]+(Y([0-9]+M)?|M)$/.test(a) }], [17, function (a) { return /^-?P([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+(\.[0-9]+)?S)?)?$/.test(a) }]]); var bb = Object.create(null);
+			[{ D: 0, name: 59 }, { D: 0, name: 46, parent: 59, L: { whiteSpace: "preserve" } }, { D: 0, name: 19, parent: 46 }, { D: 0, name: 1, parent: 46 }, { D: 0, name: 0, parent: 46, L: { whiteSpace: "collapse" } }, { D: 0, name: 4, parent: 46, L: { whiteSpace: "collapse" } }, { D: 0, name: 6, parent: 46, L: { whiteSpace: "collapse" } }, { D: 0, name: 3, parent: 46, L: { whiteSpace: "collapse" } }, { D: 0, name: 18, parent: 46, L: { whiteSpace: "collapse" } }, { D: 0, name: 9, parent: 46, L: { Ea: "optional", whiteSpace: "collapse" } }, { D: 0, name: 8, parent: 46, L: { Ea: "optional", whiteSpace: "collapse" } }, {
+				D: 0, name: 7, parent: 46,
+				L: { Ea: "optional", whiteSpace: "collapse" }
+			}, { D: 0, name: 11, parent: 46, L: { Ea: "optional", whiteSpace: "collapse" } }, { D: 0, name: 12, parent: 46, L: { Ea: "optional", whiteSpace: "collapse" } }, { D: 0, name: 13, parent: 46, L: { Ea: "optional", whiteSpace: "collapse" } }, { D: 0, name: 15, parent: 46, L: { Ea: "optional", whiteSpace: "collapse" } }, { D: 0, name: 14, parent: 46, L: { Ea: "optional", whiteSpace: "collapse" } }, { D: 0, name: 22, parent: 46, L: { whiteSpace: "collapse" } }, { D: 0, name: 21, parent: 46, L: { whiteSpace: "collapse" } }, { D: 0, name: 20, parent: 46, L: { whiteSpace: "collapse" } },
+			{ D: 0, name: 23, parent: 46, L: { whiteSpace: "collapse" } }, { D: 0, name: 44, parent: 46, L: { whiteSpace: "collapse" } }, { D: 1, name: 10, T: 9, L: { whiteSpace: "collapse", Ea: "required" } }, { D: 1, name: 48, T: 1, L: { whiteSpace: "replace" } }, { D: 1, name: 52, T: 48, L: { whiteSpace: "collapse" } }, { D: 1, name: 51, T: 52, L: { whiteSpace: "collapse" } }, { D: 1, name: 50, T: 52, L: { whiteSpace: "collapse" } }, { D: 2, name: 49, type: 50, L: { minLength: 1, whiteSpace: "collapse" } }, { D: 1, name: 25, T: 52, L: { whiteSpace: "collapse" } }, { D: 1, name: 24, T: 25, L: { whiteSpace: "collapse" } }, {
+				D: 1, name: 42, T: 24,
+				L: { whiteSpace: "collapse" }
+			}, { D: 1, name: 41, T: 24, L: { whiteSpace: "collapse" } }, { D: 2, name: 43, type: 41, L: { minLength: 1, whiteSpace: "collapse" } }, { D: 1, name: 26, T: 24, L: { whiteSpace: "collapse" } }, { D: 2, name: 40, type: 26, L: { minLength: 1, whiteSpace: "collapse" } }, { D: 0, name: 5, parent: 4, L: { na: 0, whiteSpace: "collapse" } }, { D: 1, name: 27, T: 5, L: { na: 0, ya: "0", whiteSpace: "collapse" } }, { D: 1, name: 28, T: 27, L: { na: 0, ya: "-1", whiteSpace: "collapse" } }, { D: 1, name: 31, T: 5, L: { na: 0, ya: "9223372036854775807", za: "-9223372036854775808", whiteSpace: "collapse" } },
+			{ D: 1, name: 32, T: 31, L: { na: 0, ya: "2147483647", za: "-2147483648", whiteSpace: "collapse" } }, { D: 1, name: 33, T: 32, L: { na: 0, ya: "32767", za: "-32768", whiteSpace: "collapse" } }, { D: 1, name: 34, T: 33, L: { na: 0, ya: "127", za: "-128", whiteSpace: "collapse" } }, { D: 1, name: 30, T: 5, L: { na: 0, za: "0", whiteSpace: "collapse" } }, { D: 1, name: 36, T: 30, L: { na: 0, ya: "18446744073709551615", za: "0", whiteSpace: "collapse" } }, { D: 1, name: 35, T: 36, L: { na: 0, ya: "4294967295", za: "0", whiteSpace: "collapse" } }, { D: 1, name: 38, T: 35, L: { na: 0, ya: "65535", za: "0", whiteSpace: "collapse" } },
+			{ D: 1, name: 37, T: 38, L: { na: 0, ya: "255", za: "0", whiteSpace: "collapse" } }, { D: 1, name: 29, T: 30, L: { na: 0, za: "1", whiteSpace: "collapse" } }, { D: 1, name: 16, T: 18, L: { whiteSpace: "collapse" } }, { D: 1, name: 17, T: 18, L: { whiteSpace: "collapse" } }, { D: 1, name: 60, T: 59 }, { D: 3, name: 39, Fa: [] }, { D: 1, name: 61, T: 60 }, { D: 1, name: 62, T: 60 }, { D: 0, name: 53, parent: 59 }, { D: 1, name: 54, T: 53 }, { D: 1, name: 58, T: 53 }, { D: 1, name: 47, T: 53 }, { D: 1, name: 56, T: 53 }, { D: 1, name: 57, T: 53 }, { D: 1, name: 55, T: 53 }, { D: 3, name: 2, Fa: [4, 5, 6, 3] }, { D: 3, name: 63, Fa: [] }].forEach(function (a) {
+				var b =
+					a.name, c = a.L || {}; switch (a.D) { case 0: a = a.parent ? bb[a.parent] : null; var d = ab.get(b) || null; bb[b] = { D: 0, type: b, Na: c, parent: a, kb: d, Pa: Sa(b), Fa: [] }; break; case 1: a = bb[a.T]; d = ab.get(b) || null; bb[b] = { D: 1, type: b, Na: c, parent: a, kb: d, Pa: a.Pa, Fa: [] }; break; case 2: bb[b] = { D: 2, type: b, Na: c, parent: bb[a.type], kb: null, Pa: Ta, Fa: [] }; break; case 3: a = a.Fa.map(function (e) { return bb[e] }), bb[b] = { D: 3, type: b, Na: c, parent: null, kb: null, Pa: Ua, Fa: a } }
+			}); function w(a, b) { if (!bb[b]) throw Error("Unknown type"); return { type: b, value: a } } var cb = w(!0, 0), db = w(!1, 0); function eb(a) { return Error("FORG0006: " + (void 0 === a ? "A wrong argument type was specified in a function call." : a)) }; function fb(a, b) { this.done = a; this.value = b } var x = new fb(!0, void 0); function y(a) { return new fb(!1, a) }; function gb(a, b) { if (3 === b.D) return !!b.Fa.find(function (c) { return gb(a, c) }); for (; a;) { if (a.type === b.type) return !0; if (3 === a.D) return !!a.Fa.find(function (c) { return B(c.type, b.type) }); a = a.parent } return !1 } function B(a, b) { return a === b ? !0 : gb(bb[a], bb[b]) }; function hb(a) { this.o = C; this.h = a; var b = -1; this.value = { next: function () { b++; return b >= a.length ? x : y(a[b]) } } } h = hb.prototype; h.sb = function () { return this }; h.filter = function (a) { var b = this, c = -1; return this.o.create({ next: function () { for (c++; c < b.h.length && !a(b.h[c], c, b);)c++; return c >= b.h.length ? x : y(b.h[c]) } }) }; h.first = function () { return this.h[0] }; h.O = function () { return this.h };
+			h.ha = function () { if (B(this.h[0].type, 53)) return !0; throw eb("Cannot determine the effective boolean value of a sequence with a length higher than one."); }; h.Qa = function () { return this.h.length }; h.G = function () { return !1 }; h.wa = function () { return !1 }; h.map = function (a) { var b = this, c = -1; return this.o.create({ next: function () { return ++c >= b.h.length ? x : y(a(b.h[c], c, b)) } }, this.h.length) }; h.M = function (a) { return a(this.h) }; h.Z = function (a) { return a.multiple ? a.multiple(this) : a.default(this) }; function ib() { this.value = { next: function () { return x } } } h = ib.prototype; h.sb = function () { return this }; h.filter = function () { return this }; h.first = function () { return null }; h.O = function () { return [] }; h.ha = function () { return !1 }; h.Qa = function () { return 0 }; h.G = function () { return !0 }; h.wa = function () { return !1 }; h.map = function () { return this }; h.M = function (a) { return a([]) }; h.Z = function (a) { return a.empty ? a.empty(this) : a.default(this) }; function jb(a, b) { this.type = a; this.value = b }
+			var E = {}, mb = (E[0] = "xs:boolean", E[1] = "xs:string", E[2] = "xs:numeric", E[3] = "xs:double", E[4] = "xs:decimal", E[5] = "xs:integer", E[6] = "xs:float", E[7] = "xs:date", E[8] = "xs:time", E[9] = "xs:dateTime", E[10] = "xs:dateTimeStamp", E[11] = "xs:gYearMonth", E[12] = "xs:gYear", E[13] = "xs:gMonthDay", E[14] = "xs:gMonth", E[15] = "xs:gDay", E[16] = "xs:yearMonthDuration", E[17] = "xs:dayTimeDuration", E[18] = "xs:duration", E[19] = "xs:untypedAtomic", E[20] = "xs:anyURI", E[21] = "xs:base64Binary", E[22] = "xs:hexBinary", E[23] = "xs:QName", E[24] = "xs:NCName",
+				E[25] = "xs:Name", E[26] = "xs:ENTITY", E[27] = "xs:nonPositiveInteger", E[28] = "xs:negativeInteger", E[29] = "xs:positiveInteger", E[30] = "xs:nonNegativeInteger", E[31] = "xs:long", E[32] = "xs:int", E[33] = "xs:short", E[34] = "xs:byte", E[35] = "xs:unsignedInt", E[36] = "xs:unsignedLong", E[37] = "xs:unsignedByte", E[38] = "xs:unsignedShort", E[39] = "xs:error", E[40] = "xs:ENTITIES", E[41] = "xs:IDREF", E[42] = "xs:ID", E[43] = "xs:IDREFS", E[44] = "xs:NOTATION", E[45] = "xs:anySimpleType", E[46] = "xs:anyAtomicType", E[47] = "attribute()", E[48] = "xs:normalizedString",
+				E[49] = "xs:NMTOKENS", E[50] = "xs:NMTOKEN", E[51] = "xs:language", E[52] = "xs:token", E[53] = "node()", E[54] = "element()", E[55] = "document-node()", E[56] = "text()", E[57] = "processing-instruction()", E[58] = "comment()", E[59] = "item()", E[60] = "function(*)", E[61] = "map(*)", E[62] = "array(*)", E[63] = "none", E), nb = {
+					"xs:boolean": 0, "xs:string": 1, "xs:numeric": 2, "xs:double": 3, "xs:decimal": 4, "xs:integer": 5, "xs:float": 6, "xs:date": 7, "xs:time": 8, "xs:dateTime": 9, "xs:dateTimeStamp": 10, "xs:gYearMonth": 11, "xs:gYear": 12, "xs:gMonthDay": 13, "xs:gMonth": 14,
+					"xs:gDay": 15, "xs:yearMonthDuration": 16, "xs:dayTimeDuration": 17, "xs:duration": 18, "xs:untypedAtomic": 19, "xs:anyURI": 20, "xs:base64Binary": 21, "xs:hexBinary": 22, "xs:QName": 23, "xs:NCName": 24, "xs:Name": 25, "xs:ENTITY": 26, "xs:nonPositiveInteger": 27, "xs:negativeInteger": 28, "xs:positiveInteger": 29, "xs:nonNegativeInteger": 30, "xs:long": 31, "xs:int": 32, "xs:short": 33, "xs:byte": 34, "xs:unsignedInt": 35, "xs:unsignedLong": 36, "xs:unsignedByte": 37, "xs:unsignedShort": 38, "xs:error": 39, "xs:ENTITIES": 40, "xs:IDREF": 41, "xs:ID": 42,
+					"xs:IDREFS": 43, "xs:NOTATION": 44, "xs:anySimpleType": 45, "xs:anyAtomicType": 46, "attribute()": 47, "xs:normalizedString": 48, "xs:NMTOKENS": 49, "xs:NMTOKEN": 50, "xs:language": 51, "xs:token": 52, "node()": 53, "element()": 54, "document-node()": 55, "text()": 56, "processing-instruction()": 57, "comment()": 58, "item()": 59, "function(*)": 60, "map(*)": 61, "array(*)": 62
+				}; function ob(a) { return 2 === a.g ? mb[a.type] + "*" : 1 === a.g ? mb[a.type] + "+" : 0 === a.g ? mb[a.type] + "?" : mb[a.type] }
+			function pb(a) { if ("none" === a) throw Error('XPST0051: The type "none" could not be found'); if (!a.startsWith("xs:") && 0 <= a.indexOf(":")) throw Error("XPST0081: Invalid prefix for input " + a); var b = nb[a]; if (void 0 === b) throw Error('XPST0051: The type "' + a + '" could not be found'); return b }
+			function qb(a) { switch (a[a.length - 1]) { case "*": return { type: pb(a.substr(0, a.length - 1)), g: 2 }; case "?": return { type: pb(a.substr(0, a.length - 1)), g: 0 }; case "+": return { type: pb(a.substr(0, a.length - 1)), g: 1 }; default: return { type: pb(a), g: 3 } } } function rb(a) { switch (a) { case "*": return 2; case "?": return 0; case "+": return 1; default: return 3 } }; function sb(a) { var b = a.value; if (B(a.type, 53)) return !0; if (B(a.type, 0)) return b; if (B(a.type, 1) || B(a.type, 20) || B(a.type, 19)) return 0 !== b.length; if (B(a.type, 2)) return !isNaN(b) && 0 !== b; throw eb("Cannot determine the effective boolean value of a value with the type " + mb[a.type]); }; function tb(a, b) { var c = this; this.B = C; this.value = { next: function (d) { if (null !== c.o && c.h >= c.o) return x; if (void 0 !== c.v[c.h]) return y(c.v[c.h++]); d = a.next(d); if (d.done) return c.o = c.h, d; if (c.l || 2 > c.h) c.v[c.h] = d.value; c.h++; return d } }; this.l = !1; this.v = []; this.h = 0; this.o = void 0 === b ? null : b } h = tb.prototype; h.sb = function () { return this.B.create(this.O()) }; h.filter = function (a) { var b = this, c = -1, d = this.value; return this.B.create({ next: function (e) { c++; for (e = d.next(e); !e.done && !a(e.value, c, b);)c++, e = d.next(0); return e } }) };
+			h.first = function () { if (void 0 !== this.v[0]) return this.v[0]; var a = this.value.next(0); ub(this); return a.done ? null : a.value }; h.O = function () { if (this.h > this.v.length && this.o !== this.v.length) throw Error("Implementation error: Sequence Iterator has progressed."); var a = this.value; this.l = !0; for (var b = a.next(0); !b.done;)b = a.next(0); return this.v };
+			h.ha = function () { var a = this.value, b = this.h; ub(this); var c = a.next(0); if (c.done) return ub(this, b), !1; c = c.value; if (B(c.type, 53)) return ub(this, b), !0; if (!a.next(0).done) throw eb("Cannot determine the effective boolean value of a sequence with a length higher than one."); ub(this, b); return sb(c) }; h.Qa = function (a) { if (null !== this.o) return this.o; if (void 0 === a ? 0 : a) return -1; a = this.h; var b = this.O().length; ub(this, a); return b }; h.G = function () { return 0 === this.o ? !0 : null === this.first() };
+			h.wa = function () { if (null !== this.o) return 1 === this.o; var a = this.value, b = this.h; ub(this); if (a.next(0).done) return ub(this, b), !1; a = a.next(0); ub(this, b); return a.done }; h.map = function (a) { var b = this, c = 0, d = this.value; return this.B.create({ next: function (e) { e = d.next(e); return e.done ? x : y(a(e.value, c++, b)) } }, this.o) }; h.M = function (a, b) { var c = this.value, d, e = [], f = !0; (function () { for (var g = c.next(f ? 0 : b); !g.done; g = c.next(b))f = !1, e.push(g.value); d = a(e).value })(); return this.B.create({ next: function () { return d.next(0) } }) };
+			h.Z = function (a) { function b(e) { d = e.value; e = e.Qa(!0); -1 !== e && (c.o = e) } var c = this, d = null; return this.B.create({ next: function (e) { if (d) return d.next(e); if (c.G()) return b(a.empty ? a.empty(c) : a.default(c)), d.next(e); if (c.wa()) return b(a.m ? a.m(c) : a.default(c)), d.next(e); b(a.multiple ? a.multiple(c) : a.default(c)); return d.next(e) } }) }; function ub(a, b) { a.h = void 0 === b ? 0 : b }; function vb(a) { this.v = C; this.h = a; var b = !1; this.value = { next: function () { if (b) return x; b = !0; return y(a) } }; this.o = null } h = vb.prototype; h.sb = function () { return this }; h.filter = function (a) { return a(this.h, 0, this) ? this : this.v.create() }; h.first = function () { return this.h }; h.O = function () { return [this.h] }; h.ha = function () { null === this.o && (this.o = sb(this.h)); return this.o }; h.Qa = function () { return 1 }; h.G = function () { return !1 }; h.wa = function () { return !0 }; h.map = function (a) { return this.v.create(a(this.h, 0, this)) }; h.M = function (a) { return a([this.h]) };
+			h.Z = function (a) { return a.m ? a.m(this) : a.default(this) }; var wb = new ib; function xb(a, b) { a = void 0 === a ? null : a; if (null === a) return wb; if (Array.isArray(a)) switch (a.length) { case 0: return wb; case 1: return new vb(a[0]); default: return new hb(a) }return a.next ? new tb(a, void 0 === b ? null : b) : new vb(a) } var C = { create: xb, m: function (a) { return new vb(a) }, empty: function () { return xb() }, ba: function () { return xb(cb) }, W: function () { return xb(db) } }; function yb(a) { var b = [], c = a.value; return function () { var d = 0; return C.create({ next: function () { if (void 0 !== b[d]) return b[d++]; var e = c.next(0); return e.done ? e : b[d++] = e } }) } }; function zb(a, b, c) { this.namespaceURI = b || null; this.prefix = a || ""; this.localName = c } zb.prototype.Ca = function () { return this.prefix ? this.prefix + ":" + this.localName : this.localName }; function Ab(a) { var b = a.j, c = a.arity, d = void 0 === a.Sa ? !1 : a.Sa, e = void 0 === a.I ? !1 : a.I, f = a.localName, g = a.namespaceURI, k = a.i; a = a.value; jb.call(this, 60, null); this.value = a; this.I = e; e = -1; for (a = 0; a < b.length; a++)4 === b[a] && (e = a); -1 < e && (a = Array(c - (b.length - 1)).fill(b[e - 1]), b = b.slice(0, e).concat(a)); this.o = b; this.v = c; this.da = d; this.B = f; this.l = g; this.s = k } v(Ab, jb);
+			function Cb(a, b) { var c = a.value, d = b.map(function (e) { return null === e ? null : yb(e) }); b = b.reduce(function (e, f, g) { null === f && e.push(a.o[g]); return e }, []); b = new Ab({ j: b, arity: b.length, Sa: !0, I: a.I, localName: "boundFunction", namespaceURI: a.l, i: a.s, value: function (e, f, g) { var k = Array.from(arguments).slice(3), l = d.map(function (m) { return null === m ? k.shift() : m() }); return c.apply(void 0, [e, f, g].concat(l)) } }); return C.m(b) } Ab.prototype.Sa = function () { return this.da }; function Db(a, b) { var c = []; 2 !== a && 1 !== a || c.push("type-1-or-type-2"); c.push("type-" + a); b && c.push("name-" + b); return c } function Eb(a) { var b = a.node.nodeType; if (2 === b || 1 === b) var c = a.node.localName; return Db(b, c) } function Fb(a) { var b = a.nodeType; if (2 === b || 1 === b) var c = a.localName; return Db(b, c) }; function Gb() { } Gb.prototype.getAllAttributes = function (a, b) { b = void 0 === b ? null : b; if (1 !== a.nodeType) return []; a = Array.from(a.attributes); return null === b ? a : a.filter(function (c) { return Fb(c).includes(b) }) }; Gb.prototype.getAttribute = function (a, b) { return 1 !== a.nodeType ? null : a.getAttribute(b) }; Gb.prototype.getChildNodes = function (a, b) { b = void 0 === b ? null : b; a = Array.from(a.childNodes); return null === b ? a : a.filter(function (c) { return Fb(c).includes(b) }) };
+			Gb.prototype.getData = function (a) { return 2 === a.nodeType ? a.value : a.data }; Gb.prototype.getFirstChild = function (a, b) { b = void 0 === b ? null : b; for (a = a.firstChild; a; a = a.nextSibling)if (null === b || Fb(a).includes(b)) return a; return null }; Gb.prototype.getLastChild = function (a, b) { b = void 0 === b ? null : b; for (a = a.lastChild; a; a = a.previousSibling)if (null === b || Fb(a).includes(b)) return a; return null };
+			Gb.prototype.getNextSibling = function (a, b) { b = void 0 === b ? null : b; for (a = a.nextSibling; a; a = a.nextSibling)if (null === b || Fb(a).includes(b)) return a; return null }; Gb.prototype.getParentNode = function (a, b) { b = void 0 === b ? null : b; return (a = 2 === a.nodeType ? a.ownerElement : a.parentNode) ? null === b || Fb(a).includes(b) ? a : null : null }; Gb.prototype.getPreviousSibling = function (a, b) { b = void 0 === b ? null : b; for (a = a.previousSibling; a; a = a.previousSibling)if (null === b || Fb(a).includes(b)) return a; return null }; function Hb() { } h = Hb.prototype; h.insertBefore = function (a, b, c) { return a.insertBefore(b, c) }; h.removeAttributeNS = function (a, b, c) { return a.removeAttributeNS(b, c) }; h.removeChild = function (a, b) { return a.removeChild(b) }; h.setAttributeNS = function (a, b, c, d) { a.setAttributeNS(b, c, d) }; h.setData = function (a, b) { a.data = b }; var Ib = new Hb; function Jb(a) { this.h = a } h = Jb.prototype; h.insertBefore = function (a, b, c) { return this.h.insertBefore(a, b, c) }; h.removeAttributeNS = function (a, b, c) { return this.h.removeAttributeNS(a, b, c) }; h.removeChild = function (a, b) { return this.h.removeChild(a, b) }; h.setAttributeNS = function (a, b, c, d) { this.h.setAttributeNS(a, b, c, d) }; h.setData = function (a, b) { this.h.setData(a, b) }; function Kb(a) { return void 0 !== a.Ta }; function Lb(a, b, c) { var d = null; b && (Kb(b.node) ? d = { F: b.F, offset: c, parent: b.node } : b.F && (d = b.F)); return { node: a, F: d } } function Mb(a) { this.h = a; this.o = [] } function Nb(a, b, c) { return a.getAllAttributes(b.node, void 0 === c ? null : c).map(function (d) { return Lb(d, b, d.nodeName) }) } Mb.prototype.getAllAttributes = function (a, b) { return Kb(a) ? a.attributes : this.h.getAllAttributes(a, void 0 === b ? null : b) };
+			function Ob(a, b, c) { b = b.node; return Kb(b) ? (a = b.attributes.find(function (d) { return c === d.name })) ? a.value : null : (a = a.h.getAttribute(b, c)) ? a : null } function Pb(a, b, c) { return a.getChildNodes(b.node, void 0 === c ? null : c).map(function (d, e) { return Lb(d, b, e) }) } Mb.prototype.getChildNodes = function (a, b) { b = Kb(a) ? a.childNodes : this.h.getChildNodes(a, void 0 === b ? null : b); return 9 === a.nodeType ? b.filter(function (c) { return 10 !== c.nodeType }) : b };
+			Mb.prototype.getData = function (a) { return Kb(a) ? 2 === a.nodeType ? a.value : a.data : this.h.getData(a) || "" }; function Qb(a, b) { return a.getData(b.node) } function Sb(a, b, c) { var d = b.node; Kb(d) ? a = d.childNodes[0] : ((c = a.h.getFirstChild(d, void 0 === c ? null : c)) && 10 === c.nodeType && (c = a.h.getNextSibling(c)), a = c); return a ? Lb(a, b, 0) : null }
+			function Tb(a, b, c) { c = void 0 === c ? null : c; var d = b.node; Kb(d) ? (a = d.childNodes.length - 1, d = d.childNodes[a]) : ((d = a.h.getLastChild(d, c)) && 10 === d.nodeType && (d = a.h.getPreviousSibling(d)), a = a.getChildNodes(b.node, c).length - 1); return d ? Lb(d, b, a) : null }
+			function Ub(a, b, c) { c = void 0 === c ? null : c; var d = b.node, e = b.F; if (Kb(d)) { if (e) { var f = e.offset + 1; var g = e.parent.childNodes[f] } } else if (e) { f = e.offset + 1; var k = Vb(a, b, null); g = a.getChildNodes(k.node, c)[f] } else { for (g = d; g && (!(g = a.h.getNextSibling(g, c)) || 10 === g.nodeType);); return g ? { node: g, F: null } : null } return g ? Lb(g, k || Vb(a, b, c), f) : null } Mb.prototype.getParentNode = function (a, b) { return this.h.getParentNode(a, void 0 === b ? null : b) };
+			function Vb(a, b, c) { c = void 0 === c ? null : c; var d = b.node, e = b.F; if (e) "number" === typeof e.offset && d === e.parent.childNodes[e.offset] || "string" === typeof e.offset && d === e.parent.attributes.find(function (f) { return e.offset === f.nodeName }) ? (a = e.parent, b = e.F) : (a = a.getParentNode(d, c), b = e); else { if (Kb(d)) return null; a = a.getParentNode(d, c); b = null } return a ? { node: a, F: b } : null }
+			function Wb(a, b, c) { c = void 0 === c ? null : c; var d = b.node, e = b.F; if (Kb(d)) { if (e) { var f = e.offset - 1; var g = e.parent.childNodes[f] } } else if (e) { f = e.offset - 1; var k = Vb(a, b, null); g = a.getChildNodes(k.node, c)[f] } else { for (g = d; g && (!(g = a.h.getPreviousSibling(g, c)) || 10 === g.nodeType);); return g ? { node: g, F: null } : null } return g ? Lb(g, k || Vb(a, b, c), f) : null }; function Xb(a, b, c, d, e) { return e.M(function (f) { var g = p(f).next().value; return d.M(function (k) { k = p(k).next().value; var l = g.value; if (0 >= l || l > k.P.length) throw Error("FOAY0001: array position out of bounds."); return k.P[l - 1]() }) }) }; function Yb(a) { Ab.call(this, { value: function (c, d, e, f) { return Xb(c, d, e, C.m(b), f) }, localName: "get", namespaceURI: "http://www.w3.org/2005/xpath-functions/array", j: [{ type: 5, g: 3 }], arity: 1, i: { type: 59, g: 2 } }); var b = this; this.type = 62; this.P = a } v(Yb, Ab); function Zb(a) { switch (a.node.nodeType) { case 2: return 47; case 1: return 54; case 3: case 4: return 56; case 7: return 57; case 8: return 58; case 9: return 55; default: return 53 } } function $b(a) { return { type: Zb(a), value: a } }; function ac(a, b) { a = a.map(function (c) { return c.first() }); return b(a) }; function bc(a, b) { var c = B(a.type, 1) || B(a.type, 20) || B(a.type, 19), d = B(b.type, 1) || B(b.type, 20) || B(b.type, 19); if (c && d) return a.value === b.value; c = B(a.type, 4) || B(a.type, 3) || B(a.type, 6); d = B(b.type, 4) || B(b.type, 3) || B(b.type, 6); if (c && d) return isNaN(a.value) && isNaN(b.value) ? !0 : a.value === b.value; c = B(a.type, 0) || B(a.type, 22) || B(a.type, 18) || B(a.type, 23) || B(a.type, 44); d = B(b.type, 0) || B(b.type, 22) || B(b.type, 18) || B(b.type, 23) || B(b.type, 44); return c && d ? a.value === b.value : !1 }; function cc(a, b, c, d, e) { return ac([d, e], function (f) { f = p(f); var g = f.next().value, k = f.next().value; return (f = g.h.find(function (l) { return bc(l.key, k) })) ? f.value() : C.empty() }) }; function dc(a) { Ab.call(this, { j: [{ type: 59, g: 3 }], arity: 1, localName: "get", namespaceURI: "http://www.w3.org/2005/xpath-functions/map", value: function (c, d, e, f) { return cc(c, d, e, C.m(b), f) }, i: { type: 59, g: 2 } }); var b = this; this.type = 61; this.h = a } v(dc, Ab); function ec() { } function fc(a, b) { return a.eb() === b.eb() && a.fb() === b.fb() } h = ec.prototype; h.bb = function () { return 0 }; h.getHours = function () { return 0 }; h.getMinutes = function () { return 0 }; h.cb = function () { return 0 }; h.eb = function () { return 0 }; h.fb = function () { return 0 }; h.getSeconds = function () { return 0 }; h.gb = function () { return 0 }; h.qa = function () { return !0 }; function gc(a) { if (a > Number.MAX_SAFE_INTEGER || a < Number.MIN_SAFE_INTEGER) throw Error("FODT0002: Number of seconds given to construct DayTimeDuration overflows MAX_SAFE_INTEGER or MIN_SAFE_INTEGER"); this.ea = a } v(gc, ec); h = gc.prototype; h.bb = function () { return Math.trunc(this.ea / 86400) }; h.getHours = function () { return Math.trunc(this.ea % 86400 / 3600) }; h.getMinutes = function () { return Math.trunc(this.ea % 3600 / 60) }; h.fb = function () { return this.ea }; h.getSeconds = function () { var a = this.ea % 60; return Object.is(-0, a) ? 0 : a };
+			h.qa = function () { return Object.is(-0, this.ea) ? !1 : 0 <= this.ea }; h.toString = function () { return (this.qa() ? "P" : "-P") + hc(this) }; function hc(a) { var b = Math.abs(a.bb()), c = Math.abs(a.getHours()), d = Math.abs(a.getMinutes()); a = Math.abs(a.getSeconds()); b = b ? b + "D" : ""; c = (c ? c + "H" : "") + (d ? d + "M" : "") + (a ? a + "S" : ""); return b && c ? b + "T" + c : b ? b : c ? "T" + c : "T0S" } function ic(a, b, c, d, e, f) { a = 86400 * a + 3600 * b + 60 * c + d + e; return new gc(f || 0 === a ? a : -a) }
+			function jc(a) { return (a = /^(-)?P(\d+Y)?(\d+M)?(\d+D)?(?:T(\d+H)?(\d+M)?(\d+(\.\d*)?S)?)?$/.exec(a)) ? ic(a[4] ? parseInt(a[4], 10) : 0, a[5] ? parseInt(a[5], 10) : 0, a[6] ? parseInt(a[6], 10) : 0, a[7] ? parseInt(a[7], 10) : 0, a[8] ? parseFloat(a[8]) : 0, !a[1]) : null } function kc(a) { a = /^(Z)|([+-])([01]\d):([0-5]\d)$/.exec(a); return "Z" === a[1] ? ic(0, 0, 0, 0, 0, !0) : ic(0, a[3] ? parseInt(a[3], 10) : 0, a[4] ? parseInt(a[4], 10) : 0, 0, 0, "+" === a[2]) }
+			function lc(a, b) { if (isNaN(b)) throw Error("FOCA0005: Cannot multiply xs:dayTimeDuration by NaN"); a = a.ea * b; if (a > Number.MAX_SAFE_INTEGER || !Number.isFinite(a)) throw Error("FODT0002: Value overflow while multiplying xs:dayTimeDuration"); return new gc(a < Number.MIN_SAFE_INTEGER || Object.is(-0, a) ? 0 : a) }; function mc(a) { return a ? parseInt(a, 10) : null } function nc(a) { a += ""; var b = a.startsWith("-"); b && (a = a.substring(1)); return (b ? "-" : "") + a.padStart(4, "0") } function oc(a) { return (a + "").padStart(2, "0") } function pc(a) { a += ""; 1 === a.split(".")[0].length && (a = a.padStart(a.length + 1, "0")); return a } function qc(a) { return 0 === a.getHours() && 0 === a.getMinutes() ? "Z" : (a.qa() ? "+" : "-") + oc(Math.abs(a.getHours())) + ":" + oc(Math.abs(a.getMinutes())) }
+			function rc(a, b, c, d, e, f, g, k, l) { this.v = a; this.h = b; this.o = c + (24 === d ? 1 : 0); this.l = 24 === d ? 0 : d; this.s = e; this.B = f; this.sa = g; this.Y = k; this.type = void 0 === l ? 9 : l }
+			function sc(a) {
+				var b = /^(?:(-?\d{4,}))?(?:--?(\d\d))?(?:-{1,3}(\d\d))?(T)?(?:(\d\d):(\d\d):(\d\d))?(\.\d+)?(Z|(?:[+-]\d\d:\d\d))?$/.exec(a); a = b[1] ? parseInt(b[1], 10) : null; var c = mc(b[2]), d = mc(b[3]), e = b[4], f = mc(b[5]), g = mc(b[6]), k = mc(b[7]), l = b[8] ? parseFloat(b[8]) : 0; b = b[9] ? kc(b[9]) : null; if (a && (-271821 > a || 273860 < a)) throw Error("FODT0001: Datetime year is out of bounds"); return e ? new rc(a, c, d, f, g, k, l, b, 9) : null !== f && null !== g && null !== k ? new rc(1972, 12, 31, f, g, k, l, b, 8) : null !== a && null !== c && null !== d ? new rc(a, c,
+					d, 0, 0, 0, 0, b, 7) : null !== a && null !== c ? new rc(a, c, 1, 0, 0, 0, 0, b, 11) : null !== c && null !== d ? new rc(1972, c, d, 0, 0, 0, 0, b, 13) : null !== a ? new rc(a, 1, 1, 0, 0, 0, 0, b, 12) : null !== c ? new rc(1972, c, 1, 0, 0, 0, 0, b, 14) : new rc(1972, 12, d, 0, 0, 0, 0, b, 15)
+			}
+			function tc(a, b) { switch (b) { case 15: return new rc(1972, 12, a.o, 0, 0, 0, 0, a.Y, 15); case 14: return new rc(1972, a.h, 1, 0, 0, 0, 0, a.Y, 14); case 12: return new rc(a.v, 1, 1, 0, 0, 0, 0, a.Y, 12); case 13: return new rc(1972, a.h, a.o, 0, 0, 0, 0, a.Y, 13); case 11: return new rc(a.v, a.h, 1, 0, 0, 0, 0, a.Y, 11); case 8: return new rc(1972, 12, 31, a.l, a.s, a.B, a.sa, a.Y, 8); case 7: return new rc(a.v, a.h, a.o, 0, 0, 0, 0, a.Y, 7); default: return new rc(a.v, a.h, a.o, a.l, a.s, a.B, a.sa, a.Y, 9) } } h = rc.prototype; h.getDay = function () { return this.o }; h.getHours = function () { return this.l };
+			h.getMinutes = function () { return this.s }; h.getMonth = function () { return this.h }; h.getSeconds = function () { return this.B }; h.getYear = function () { return this.v }; function uc(a, b) { b = a.Y || b || kc("Z"); return new Date(Date.UTC(a.v, a.h - 1, a.o, a.l - b.getHours(), a.s - b.getMinutes(), a.B, 1E3 * a.sa)) }
+			h.toString = function () {
+				switch (this.type) {
+					case 9: return nc(this.v) + "-" + oc(this.h) + "-" + oc(this.o) + "T" + oc(this.l) + ":" + oc(this.s) + ":" + pc(this.B + this.sa) + (this.Y ? qc(this.Y) : ""); case 7: return nc(this.v) + "-" + oc(this.h) + "-" + oc(this.o) + (this.Y ? qc(this.Y) : ""); case 8: return oc(this.l) + ":" + oc(this.s) + ":" + pc(this.B + this.sa) + (this.Y ? qc(this.Y) : ""); case 15: return "---" + oc(this.o) + (this.Y ? qc(this.Y) : ""); case 14: return "--" + oc(this.h) + (this.Y ? qc(this.Y) : ""); case 13: return "--" + oc(this.h) + "-" + oc(this.o) + (this.Y ? qc(this.Y) :
+						""); case 12: return nc(this.v) + (this.Y ? qc(this.Y) : ""); case 11: return nc(this.v) + "-" + oc(this.h) + (this.Y ? qc(this.Y) : "")
+				}throw Error("Unexpected subType");
+			}; function vc(a, b, c) { var d = uc(a, c).getTime(); c = uc(b, c).getTime(); return d === c ? a.sa === b.sa ? 0 : a.sa > b.sa ? 1 : -1 : d > c ? 1 : -1 } function wc(a, b, c) { return 0 === vc(a, b, c) } function xc(a, b, c) { a = (uc(a, c).getTime() - uc(b, c).getTime()) / 1E3; return new gc(a) } function yc(a) { throw Error("Not implemented: adding durations to " + mb[a.type]); }
+			function zc(a) { throw Error("Not implemented: subtracting durations from " + mb[a.type]); }; function Ac(a, b) {
+				if (null === a) return null; switch (typeof a) {
+					case "boolean": return a ? cb : db; case "number": return w(a, 3); case "string": return w(a, 1); case "object": if ("nodeType" in a) return $b({ node: a, F: null }); if (Array.isArray(a)) return new Yb(a.map(function (d) { if (void 0 === d) return function () { return C.empty() }; d = Ac(d, b); d = null === d ? C.empty() : C.m(d); return yb(d) })); if (a instanceof Date) { var c = sc(a.toISOString()); return w(c, c.type) } return new dc(Object.keys(a).filter(function (d) { return void 0 !== a[d] }).map(function (d) {
+						var e =
+							Ac(a[d], b); e = null === e ? C.empty() : C.m(e); return { key: w(d, 1), value: yb(e) }
+					}))
+				}throw Error("Value " + String(a) + ' of type "' + typeof a + '" is not adaptable to an XPath value.');
+			} function Bc(a, b) { if ("number" !== typeof a && ("string" !== typeof a || !ab.get(b)(a))) throw Error("Cannot convert JavaScript value '" + a + "' to the XPath type " + mb[b] + " since it is not valid."); }
+			function Cc(a, b, c) {
+				if (null === b) return null; switch (a) {
+					case 0: return b ? cb : db; case 1: return w(b + "", 1); case 3: case 2: return Bc(b, 3), w(+b, 3); case 4: return Bc(b, a), w(+b, 4); case 5: return Bc(b, a), w(b | 0, 5); case 6: return Bc(b, a), w(+b, 6); case 7: case 8: case 9: case 11: case 12: case 13: case 14: case 15: if (!(b instanceof Date)) throw Error("The JavaScript value " + b + " with type " + typeof b + " is not a valid type to be converted to an XPath " + mb[a] + "."); return w(tc(sc(b.toISOString()), a), a); case 53: case 47: case 55: case 54: case 56: case 57: case 58: if ("object" !==
+						typeof b || !("nodeType" in b)) throw Error("The JavaScript value " + b + " with type " + typeof b + " is not a valid type to be converted to an XPath " + mb[a] + "."); return $b({ node: b, F: null }); case 59: return Ac(b, c); case 61: return Ac(b, c); default: throw Error('Values of the type "' + mb[a] + '" can not be adapted from JavaScript to equivalent XPath values.');
+				}
+			}
+			function Dc(a, b, c) { if (0 === c.g) return b = Cc(c.type, b, a), null === b ? [] : [b]; if (2 === c.g || 1 === c.g) { if (!Array.isArray(b)) throw Error("The JavaScript value " + b + " should be an array if it is to be converted to " + ob(c) + "."); return b.map(function (e) { return Cc(c.type, e, a) }).filter(function (e) { return null !== e }) } var d = Cc(c.type, b, a); if (null === d) throw Error("The JavaScript value " + b + " should be a single entry if it is to be converted to " + ob(c) + "."); return [d] }
+			function Ec(a, b, c) { c = void 0 === c ? { type: 59, g: 0 } : c; return C.create(Dc(a, b, c)) }; function Fc() { var a = void 0 === a ? Math.floor(Math.random() * Gc) : a; this.h = Math.abs(a % Gc) } var Gc = Math.pow(2, 32); function Hc(a, b, c) { b = void 0 === b ? { yb: null, Db: null, tb: !1 } : b; c = void 0 === c ? new Fc : c; this.h = b; this.Ka = a.Ka; this.Da = a.Da; this.N = a.N; this.Aa = a.Aa || Object.create(null); this.o = c } function Ic(a, b) { var c = 0, d = b.value; return { next: function (e) { e = d.next(e); return e.done ? x : y(Jc(a, c++, e.value, b)) } } } function Kc(a) { a.h.tb || (a.h.tb = !0, a.h.yb = sc((new Date).toISOString()), a.h.Db = jc("PT0S")); return a.h.yb } function Lc(a) { a.h.tb || (a.h.tb = !0, a.h.yb = sc((new Date).toISOString()), a.h.Db = jc("PT0S")); return a.h.Db }
+			function Mc(a, b) { b = void 0 === b ? null : b; a = 29421 * (null !== b && void 0 !== b ? b : a.o.h) % Gc; return { zb: Math.floor(a), jc: a / Gc } } function Jc(a, b, c, d) { return new Hc({ N: c, Ka: b, Da: d || a.Da, Aa: a.Aa }, a.h, a.o) } function Nc(a, b) { return new Hc({ N: a.N, Ka: a.Ka, Da: a.Da, Aa: Object.assign(Object.create(null), a.Aa, b) }, a.h, a.o) }; function Oc(a, b, c, d, e, f, g, k, l) { this.debug = a; this.La = b; this.h = c; this.o = d; this.B = e; this.l = f; this.da = g; this.s = k; this.v = l }; function Pc(a) { var b = 0, c = null, d = !0; return C.create({ next: function (e) { for (; b < a.length;) { c || (c = a[b].value, d = !0); var f = c.next(d ? 0 : e); d = !1; if (f.done) b++, c = null; else return f } return x } }) }; function Qc(a, b, c) { return Error("FORG0001: Cannot cast " + a + " to " + mb[b] + (c ? ", " + c : "")) } function Rc(a) { return Error("XPDY0002: " + a) } function Sc(a) { return Error("XPTY0004: " + a) } function Tc(a) { return Error("FOTY0013: Atomization is not supported for " + mb[a] + ".") } function Uc(a) { return Error("XPST0081: The prefix " + a + " could not be resolved.") }; function Yc(a, b) {
+				if (B(a.type, 46) || B(a.type, 19) || B(a.type, 0) || B(a.type, 4) || B(a.type, 3) || B(a.type, 6) || B(a.type, 5) || B(a.type, 2) || B(a.type, 23) || B(a.type, 1)) return C.create(a); var c = b.h; if (B(a.type, 53)) {
+					var d = a.value; if (2 === d.node.nodeType || 3 === d.node.nodeType) return C.create(w(Qb(c, d), 19)); if (8 === d.node.nodeType || 7 === d.node.nodeType) return C.create(w(Qb(c, d), 1)); var e = []; (function k(g) { if (8 !== d.node.nodeType && 7 !== d.node.nodeType) { var l = g.nodeType; 3 === l || 4 === l ? e.push(c.getData(g)) : 1 !== l && 9 !== l || c.getChildNodes(g).forEach(function (m) { k(m) }) } })(d.node);
+					return C.create(w(e.join(""), 19))
+				} if (B(a.type, 60) && !B(a.type, 62)) throw Tc(a.type); if (B(a.type, 62)) return Pc(a.P.map(function (f) { return Zc(f(), b) })); throw Error("Atomizing " + a.type + " is not implemented.");
+			} function Zc(a, b) { var c = !1, d = a.value, e = null; return C.create({ next: function () { for (; !c;) { if (!e) { var f = d.next(0); if (f.done) { c = !0; break } e = Yc(f.value, b).value } f = e.next(0); if (f.done) e = null; else return f } return x } }) }; function $c(a) { for (a = bb[a]; a && 0 !== a.D;)a = a.parent; return a ? a.type : null } function ad(a, b) { b = bb[b]; var c = b.Na; if (!c || !c.whiteSpace) return b.parent ? ad(a, b.parent.type) : a; switch (b.Na.whiteSpace) { case "replace": return a.replace(/[\u0009\u000A\u000D]/g, " "); case "collapse": return a.replace(/[\u0009\u000A\u000D]/g, " ").replace(/ {2,}/g, " ").replace(/^ | $/g, "") }return a } function bd(a, b) { for (b = bb[b]; b && null === b.kb;) { if (2 === b.D || 3 === b.D) return !0; b = b.parent } return b ? b.kb(a) : !0 }
+			function cd(a, b) { for (; a;) { if (a.Pa && a.Pa[b]) return a.Pa[b]; a = a.parent } return function () { return !0 } } function dd(a, b) { for (var c = bb[b]; c;) { if (c.Na && !Object.keys(c.Na).every(function (d) { if ("whiteSpace" === d) return !0; var e = cd(c, d); return e ? e(a, c.Na[d]) : !0 })) return !1; c = c.parent } return !0 } function ed(a) { return a ? 2 === a.g || 0 === a.g : !0 }; function fd(a) { return a(1) || a(19) ? function (b) { return { u: !0, value: w(b, 20) } } : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:anyURI or any of its derived types.") } } }; function gd(a) { return a(22) ? function (b) { for (var c = "", d = 0; d < b.length; d += 2)c += String.fromCharCode(parseInt(b.substr(d, 2), 16)); return { u: !0, value: w(btoa(c), 21) } } : a(1) || a(19) ? function (b) { return { u: !0, value: w(b, 21) } } : function () { return { error: Error("XPTY0004: Casting not supported from given type to xs:base64Binary or any of its derived types."), u: !1 } } }; function hd(a) { return a(2) ? function (b) { return { u: !0, value: 0 === b || isNaN(b) ? db : cb } } : a(1) || a(19) ? function (b) { switch (b) { case "true": case "1": return { u: !0, value: cb }; case "false": case "0": return { u: !0, value: db }; default: return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:boolean or any of its derived types.") } } } : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:boolean or any of its derived types.") } } }; function id(a) { return a(9) ? function (b) { return { u: !0, value: w(tc(b, 7), 7) } } : a(19) || a(1) ? function (b) { return { u: !0, value: w(sc(b), 7) } } : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:date or any of its derived types.") } } }; function jd(a) { return a(7) ? function (b) { return { u: !0, value: w(tc(b, 9), 9) } } : a(19) || a(1) ? function (b) { return { u: !0, value: w(sc(b), 9) } } : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:dateTime or any of its derived types.") } } }; function kd(a) { return a(18) && !a(16) ? function (b) { return { u: !0, value: w(b.Ja, 17) } } : a(16) ? function () { return { u: !0, value: w(jc("PT0.0S"), 17) } } : a(19) || a(1) ? function (b) { var c = jc(b); return c ? { u: !0, value: w(c, 17) } : { u: !1, error: Error("FORG0001: Can not cast " + b + " to xs:dayTimeDuration") } } : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:dayTimeDuration or any of its derived types.") } } }; function ld(a) {
+				return a(5) ? function (b) { return { u: !0, value: w(b, 4) } } : a(6) || a(3) ? function (b) { return isNaN(b) || !isFinite(b) ? { u: !1, error: Error("FOCA0002: Can not cast " + b + " to xs:decimal") } : Math.abs(b) > Number.MAX_VALUE ? { u: !1, error: Error("FOAR0002: Can not cast " + b + " to xs:decimal, it is out of bounds for JavaScript numbers") } : { u: !0, value: w(b, 4) } } : a(0) ? function (b) { return { u: !0, value: w(b ? 1 : 0, 4) } } : a(1) || a(19) ? function (b) {
+					var c = parseFloat(b); return !isNaN(c) || isFinite(c) ? { u: !0, value: w(c, 4) } : {
+						u: !1, error: Error("FORG0001: Can not cast " +
+							b + " to xs:decimal")
+					}
+				} : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:decimal or any of its derived types.") } }
+			}; function md(a, b) {
+				return a(2) ? function (c) { return { u: !0, value: c } } : a(0) ? function (c) { return { u: !0, value: c ? 1 : 0 } } : a(1) || a(19) ? function (c) { switch (c) { case "NaN": return { u: !0, value: NaN }; case "INF": case "+INF": return { u: !0, value: Infinity }; case "-INF": return { u: !0, value: -Infinity }; case "0": case "+0": return { u: !0, value: 0 }; case "-0": return { u: !0, value: -0 } }var d = parseFloat(c); return isNaN(d) ? { u: !1, error: Qc(c, b) } : { u: !0, value: d } } : function () {
+					return {
+						u: !1, error: Error("XPTY0004: Casting not supported from given type to " + b +
+							" or any of its derived types.")
+					}
+				}
+			}; function nd(a) { var b = md(a, 3); return function (c) { c = b(c); return c.u ? { u: !0, value: w(c.value, 3) } : c } }; function od(a) { if (a > Number.MAX_SAFE_INTEGER || a < Number.MIN_SAFE_INTEGER) throw Error("FODT0002: Number of months given to construct YearMonthDuration overflows MAX_SAFE_INTEGER or MIN_SAFE_INTEGER"); this.ga = a } v(od, ec); h = od.prototype; h.cb = function () { var a = this.ga % 12; return 0 === a ? 0 : a }; h.eb = function () { return this.ga }; h.gb = function () { return Math.trunc(this.ga / 12) }; h.qa = function () { return Object.is(-0, this.ga) ? !1 : 0 <= this.ga }; h.toString = function () { return (this.qa() ? "P" : "-P") + pd(this) };
+			function pd(a) { var b = Math.abs(a.gb()); a = Math.abs(a.cb()); return (b ? b + "Y" : "") + (a ? a + "M" : "") || "0M" } function qd(a) { var b = /^(-)?P(\d+Y)?(\d+M)?(\d+D)?(?:T(\d+H)?(\d+M)?(\d+(\.\d*)?S)?)?$/.exec(a); if (b) { a = !b[1]; b = 12 * (b[2] ? parseInt(b[2], 10) : 0) + (b[3] ? parseInt(b[3], 10) : 0); if (b > Number.MAX_SAFE_INTEGER || !Number.isFinite(b)) throw Error("FODT0002: Value overflow while constructing xs:yearMonthDuration"); a = new od(a || 0 === b ? b : -b) } else a = null; return a }
+			function rd(a, b) { if (isNaN(b)) throw Error("FOCA0005: Cannot multiply xs:yearMonthDuration by NaN"); a = Math.round(a.ga * b); if (a > Number.MAX_SAFE_INTEGER || !Number.isFinite(a)) throw Error("FODT0002: Value overflow while constructing xs:yearMonthDuration"); return new od(a < Number.MIN_SAFE_INTEGER || 0 === a ? 0 : a) }; function sd(a, b) { this.Wa = a; this.Ja = b } v(sd, ec); h = sd.prototype; h.bb = function () { return this.Ja.bb() }; h.getHours = function () { return this.Ja.getHours() }; h.getMinutes = function () { return this.Ja.getMinutes() }; h.cb = function () { return this.Wa.cb() }; h.eb = function () { return this.Wa.eb() }; h.fb = function () { return this.Ja.fb() }; h.getSeconds = function () { return this.Ja.getSeconds() }; h.gb = function () { return this.Wa.gb() }; h.qa = function () { return this.Wa.qa() && this.Ja.qa() };
+			h.toString = function () { var a = this.qa() ? "P" : "-P", b = pd(this.Wa), c = hc(this.Ja); return "0M" === b ? a + c : "T0S" === c ? a + b : a + b + c }; function td(a) { return a(16) ? function (b) { return { u: !0, value: w(new sd(b, new gc(b.qa() ? 0 : -0)), 18) } } : a(17) ? function (b) { b = new sd(new od(b.qa() ? 0 : -0), b); return { u: !0, value: w(b, 18) } } : a(18) ? function (b) { return { u: !0, value: w(b, 18) } } : a(19) || a(1) ? function (b) { var c; return c = new sd(qd(b), jc(b)), { u: !0, value: w(c, 18) } } : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:duration or any of its derived types.") } } }; function ud(a) { var b = md(a, 6); return function (c) { c = b(c); return c.u ? { u: !0, value: w(c.value, 6) } : c } }; function vd(a) { return a(7) || a(9) ? function (b) { return { u: !0, value: w(tc(b, 15), 15) } } : a(19) || a(1) ? function (b) { return { u: !0, value: w(sc(b), 15) } } : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:gDay or any of its derived types.") } } }; function wd(a) { return a(7) || a(9) ? function (b) { return { u: !0, value: w(tc(b, 14), 14) } } : a(19) || a(1) ? function (b) { return { u: !0, value: w(sc(b), 14) } } : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:gMonth or any of its derived types.") } } }; function xd(a) { return a(7) || a(9) ? function (b) { return { u: !0, value: w(tc(b, 13), 13) } } : a(19) || a(1) ? function (b) { return { u: !0, value: w(sc(b), 13) } } : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:gMonthDay or any of its derived types.") } } }; function yd(a) { return a(7) || a(9) ? function (b) { return { u: !0, value: w(tc(b, 12), 12) } } : a(19) || a(1) ? function (b) { return { u: !0, value: w(sc(b), 12) } } : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:gYear or any of its derived types.") } } }; function zd(a) { return a(7) || a(9) ? function (b) { return { u: !0, value: w(tc(b, 11), 11) } } : a(19) || a(1) ? function (b) { return { u: !0, value: w(sc(b), 11) } } : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:gYearMonth or any of its derived types.") } } }; function Ad(a) { return a(21) ? function (b) { b = atob(b); for (var c = "", d = 0, e = b.length; d < e; d++)c += Number(b.charCodeAt(d)).toString(16); return { u: !0, value: w(c.toUpperCase(), 22) } } : a(1) || a(19) ? function (b) { return { u: !0, value: w(b, 22) } } : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:hexBinary or any of its derived types.") } } }; function Bd(a) {
+				return a(0) ? function (b) { return { u: !0, value: w(b ? 1 : 0, 5) } } : a(2) ? function (b) { var c = Math.trunc(b); return !isFinite(c) || isNaN(c) ? { u: !1, error: Error("FOCA0002: can not cast " + b + " to xs:integer") } : Number.isSafeInteger(c) ? { u: !0, value: w(c, 5) } : { u: !1, error: Error("FOAR0002: can not cast " + b + " to xs:integer, it is out of bounds for JavaScript numbers.") } } : a(1) || a(19) ? function (b) {
+					var c = parseInt(b, 10); return isNaN(c) ? { u: !1, error: Qc(b, 5) } : Number.isSafeInteger(c) ? { u: !0, value: w(c, 5) } : {
+						u: !1, error: Error("FOCA0003: can not cast " +
+							b + " to xs:integer, it is out of bounds for JavaScript numbers.")
+					}
+				} : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:integer or any of its derived types.") } }
+			}; var Cd = [3, 6, 4, 5]; function Dd(a) { var b = Ed; return function (c) { for (var d = p(Cd), e = d.next(); !e.done; e = d.next())if (e = b(a, e.value)(c), e.u) return e; return { u: !1, error: Error('XPTY0004: Casting not supported from "' + c + '" given type to xs:numeric or any of its derived types.') } } }; function Fd(a) {
+				if (a(1) || a(19)) return function (b) { return { u: !0, value: b + "" } }; if (a(20)) return function (b) { return { u: !0, value: b } }; if (a(23)) return function (b) { return { u: !0, value: b.prefix ? b.prefix + ":" + b.localName : b.localName } }; if (a(44)) return function (b) { return { u: !0, value: b.toString() } }; if (a(2)) {
+					if (a(5) || a(4)) return function (b) { return { u: !0, value: (b + "").replace("e", "E") } }; if (a(6) || a(3)) return function (b) {
+						return isNaN(b) ? { u: !0, value: "NaN" } : isFinite(b) ? Object.is(b, -0) ? { u: !0, value: "-0" } : {
+							u: !0, value: (b + "").replace("e",
+								"E").replace("E+", "E")
+						} : { u: !0, value: (0 > b ? "-" : "") + "INF" }
+					}
+				} return a(9) || a(7) || a(8) || a(15) || a(14) || a(13) || a(12) || a(11) ? function (b) { return { u: !0, value: b.toString() } } : a(16) ? function (b) { return { u: !0, value: b.toString() } } : a(17) ? function (b) { return { u: !0, value: b.toString() } } : a(18) ? function (b) { return { u: !0, value: b.toString() } } : a(22) ? function (b) { return { u: !0, value: b.toUpperCase() } } : function (b) { return { u: !0, value: b + "" } }
+			}; function Hd(a) { var b = Fd(a); return function (c) { c = b(c); return c.u ? { u: !0, value: w(c.value, 1) } : c } }; function Id(a) { return a(9) ? function (b) { return { u: !0, value: w(tc(b, 8), 8) } } : a(19) || a(1) ? function (b) { return { u: !0, value: w(sc(b), 8) } } : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:time or any of its derived types.") } } }; function Jd(a) { var b = Fd(a); return function (c) { c = b(c); return c.u ? { u: !0, value: w(c.value, 19) } : c } }; function Kd(a) { return a(18) && !a(17) ? function (b) { return { u: !0, value: w(b.Wa, 16) } } : a(17) ? function () { return { u: !0, value: w(qd("P0M"), 16) } } : a(19) || a(1) ? function (b) { var c = qd(b); return c ? { u: !0, value: w(c, 16) } : { u: !1, error: Qc(b, 16) } } : function () { return { u: !1, error: Error("XPTY0004: Casting not supported from given type to xs:yearMonthDuration or any of its derived types.") } } }; var Ld = [2, 5, 17, 16];
+			function Ed(a, b) {
+				function c(d) { return B(a, d) } if (39 === b) return function () { return { u: !1, error: Error("FORG0001: Casting to xs:error is always invalid.") } }; switch (b) {
+					case 19: return Jd(c); case 1: return Hd(c); case 6: return ud(c); case 3: return nd(c); case 4: return ld(c); case 5: return Bd(c); case 2: return Dd(a); case 18: return td(c); case 16: return Kd(c); case 17: return kd(c); case 9: return jd(c); case 8: return Id(c); case 7: return id(c); case 11: return zd(c); case 12: return yd(c); case 13: return xd(c); case 15: return vd(c);
+					case 14: return wd(c); case 0: return hd(c); case 21: return gd(c); case 22: return Ad(c); case 20: return fd(c); case 23: throw Error("Casting to xs:QName is not implemented.");
+				}return function () { return { u: !1, error: Error("XPTY0004: Casting not supported from " + a + " to " + b + ".") } }
+			} var Md = Object.create(null);
+			function Nd(a, b) {
+				if (19 === a && 1 === b) return function (f) { return { u: !0, value: w(f, 1) } }; if (44 === b) return function () { return { u: !1, error: Error("XPST0080: Casting to xs:NOTATION is not permitted.") } }; if (39 === b) return function () { return { u: !1, error: Error("FORG0001: Casting to xs:error is not permitted.") } }; if (45 === a || 45 === b) return function () { return { u: !1, error: Error("XPST0080: Casting from or to xs:anySimpleType is not permitted.") } }; if (46 === a || 46 === b) return function () { return { u: !1, error: Error("XPST0080: Casting from or to xs:anyAtomicType is not permitted.") } };
+				if (B(a, 60) && 1 === b) return function () { return { u: !1, error: Error("FOTY0014: Casting from function item to xs:string is not permitted.") } }; if (a === b) return function (f) { return { u: !0, value: { type: b, value: f } } }; var c = Ld.includes(a) ? a : $c(a), d = Ld.includes(b) ? b : $c(b); if (null === d || null === c) return function () { return { u: !1, error: Error("XPST0081: Can not cast: type " + (d ? mb[a] : mb[b]) + " is unknown.") } }; var e = []; 1 !== c && 19 !== c || e.push(function (f) { var g = ad(f, b); return bd(g, b) ? { u: !0, value: g } : { u: !1, error: Qc(f, b, "pattern validation failed.") } });
+				c !== d && (e.push(Ed(c, d)), e.push(function (f) { return { u: !0, value: f.value } })); 19 !== d && 1 !== d || e.push(function (f) { return bd(f, b) ? { u: !0, value: f } : { u: !1, error: Qc(f, b, "pattern validation failed.") } }); e.push(function (f) { return dd(f, b) ? { u: !0, value: f } : { u: !1, error: Qc(f, b, "pattern validation failed.") } }); e.push(function (f) { return { u: !0, value: { type: b, value: f } } }); return function (f) { f = { u: !0, value: f }; for (var g = 0, k = e.length; g < k && (f = e[g](f.value), !1 !== f.u); ++g); return f }
+			}
+			function Od(a, b) { var c = a.type + 1E4 * b, d = Md[c]; d || (d = Md[c] = Nd(a.type, b)); return d.call(void 0, a.value, b) }; function Pd(a, b) { a = Od(a, b); if (!0 === a.u) return a.value; throw a.error; }; function Qd(a) { var b = !1; return { next: function () { if (b) return x; b = !0; return y(a) } } }; function Rd(a, b) { return a === b ? !0 : a && b && a.offset === b.offset && a.parent === b.parent ? Rd(a.F, b.F) : !1 } function Sd(a, b) { return a === b || a.node === b.node && Rd(a.F, b.F) ? !0 : !1 }; function Td(a, b, c) { var d = Vb(a, b, null); a = Pb(a, d, null); d = 0; for (var e = a.length; d < e; ++d) { var f = a[d]; if (Sd(f, b)) return -1; if (Sd(f, c)) return 1 } } function Ud(a, b) { for (var c = []; b; b = Vb(a, b, null))c.unshift(b); return c } function Vd(a, b) { for (var c = []; b; b = a.getParentNode(b, null))c.unshift(b); return c }
+			function Wd(a, b, c, d) {
+				if (c.F || d.F || Kb(c.node) || Kb(d.node)) { if (Sd(c, d)) return 0; c = Ud(b, c); d = Ud(b, d); var e = c[0], f = d[0]; if (!Sd(e, f)) return b = a.findIndex(function (q) { return Sd(q, e) }), c = a.findIndex(function (q) { return Sd(q, f) }), -1 === b && (b = a.push(e)), -1 === c && (c = a.push(f)), b - c; a = 1; for (var g = Math.min(c.length, d.length); a < g && Sd(c[a], d[a]); ++a); return c[a] ? d[a] ? Td(b, c[a], d[a]) : 1 : -1 } c = c.node; d = d.node; if (c === d) return 0; c = Vd(b, c); d = Vd(b, d); if (c[0] !== d[0]) {
+					var k = { node: c[0], F: null }, l = { node: d[0], F: null }; b = a.findIndex(function (q) {
+						return Sd(q,
+							k)
+					}); c = a.findIndex(function (q) { return Sd(q, l) }); -1 === b && (b = a.push(k)); -1 === c && (c = a.push(l)); return b - c
+				} g = 1; for (a = Math.min(c.length, d.length); g < a && c[g] === d[g]; ++g); a = c[g]; c = d[g]; if (!a) return -1; if (!c) return 1; b = b.getChildNodes(d[g - 1], null); d = 0; for (g = b.length; d < g; ++d) { var m = b[d]; if (m === a) return -1; if (m === c) return 1 }
+			}
+			function Xd(a, b, c, d) { var e = B(c.type, 47), f = B(d.type, 47); if (e && !f) { if (c = Vb(b, c.value), d = d.value, Sd(c, d)) return 1 } else if (f && !e) { if (c = c.value, d = Vb(b, d.value), Sd(c, d)) return -1 } else if (e && f) { if (Sd(Vb(b, d.value), Vb(b, c.value))) return c.value.node.localName > d.value.node.localName ? 1 : -1; c = Vb(b, c.value); d = Vb(b, d.value) } else c = c.value, d = d.value; return Wd(a, b, c, d) } function Yd(a, b, c) { return Xd(a.o, a, b, c) }
+			function Zd(a, b) { return $d(b, function (c, d) { return Xd(a.o, a, c, d) }).filter(function (c, d, e) { return 0 === d ? !0 : !Sd(c.value, e[d - 1].value) }) } function ae(a, b) { return a < b ? -1 : 0 } function $d(a, b) { b = void 0 === b ? ae : b; if (1 >= a.length) return a; var c = Math.floor(a.length / 2), d = $d(a.slice(0, c), b); a = $d(a.slice(c), b); for (c = []; d.length && a.length;)0 > b(d[0], a[0]) ? c.push(d.shift()) : c.push(a.shift()); return c.concat(d.concat(a)) }; var be = xspattern; function ce(a, b) { if (B(a.type, 2)) { if (B(a.type, 6)) return 3 === b ? w(a.value, 3) : null; if (B(a.type, 4)) { if (6 === b) return w(a.value, 6); if (3 === b) return w(a.value, 3) } return null } return B(a.type, 20) && 1 === b ? w(a.value, 1) : null }; function de(a, b, c, d, e) { if (B(a.type, b.type)) return a; B(b.type, 46) && B(a.type, 53) && (a = Yc(a, c).first()); if (B(a.type, b.type) || 46 === b.type) return a; if (B(a.type, 19)) { c = Pd(a, b.type); if (!c) throw Error("XPTY0004 Unable to convert " + (e ? "return" : "argument") + " of type " + mb[a.type] + " to type " + ob(b) + " while calling " + d); return c } c = ce(a, b.type); if (!c) throw Error("XPTY0004 Unable to cast " + (e ? "return" : "argument") + " of type " + mb[a.type] + " to type " + ob(b) + " while calling " + d); return c }
+			function ee(a) { switch (a) { case 2: return "*"; case 1: return "+"; case 0: return "?"; case 3: return "" } }
+			function fe(a, b, c, d, e) {
+				return 0 === a.g ? b.Z({ default: function () { return b.map(function (f) { return de(f, a, c, d, e) }) }, multiple: function () { throw Error("XPTY0004: Multiplicity of " + (e ? "function return value" : "function argument") + " of type " + mb[a.type] + ee(a.g) + " for " + d + ' is incorrect. Expected "?", but got "+".'); } }) : 1 === a.g ? b.Z({
+					empty: function () {
+						throw Error("XPTY0004: Multiplicity of " + (e ? "function return value" : "function argument") + " of type " + mb[a.type] + ee(a.g) + " for " + d + ' is incorrect. Expected "+", but got "empty-sequence()"');
+					}, default: function () { return b.map(function (f) { return de(f, a, c, d, e) }) }
+				}) : 2 === a.g ? b.map(function (f) { return de(f, a, c, d, e) }) : b.Z({ m: function () { return b.map(function (f) { return de(f, a, c, d, e) }) }, default: function () { throw Error("XPTY0004: Multiplicity of " + (e ? "function return value" : "function argument") + " of type " + mb[a.type] + ee(a.g) + " for " + d + " is incorrect. Expected exactly one"); } })
+			}; function ge(a, b) { return B(a, 5) ? w(b, 5) : B(a, 6) ? w(b, 6) : B(a, 3) ? w(b, 3) : w(b, 4) } var he = [{ oa: "M", ma: 1E3 }, { oa: "CM", ma: 900 }, { oa: "D", ma: 500 }, { oa: "CD", ma: 400 }, { oa: "C", ma: 100 }, { oa: "XC", ma: 90 }, { oa: "L", ma: 50 }, { oa: "XL", ma: 40 }, { oa: "X", ma: 10 }, { oa: "IX", ma: 9 }, { oa: "V", ma: 5 }, { oa: "IV", ma: 4 }, { oa: "I", ma: 1 }]; function ie(a, b) { var c = parseInt(a, 10); a = 0 > c; c = Math.abs(c); if (!c) return "-"; var d = he.reduce(function (e, f) { var g = Math.floor(c / f.ma); c -= g * f.ma; return e + f.oa.repeat(g) }, ""); b && (d = d.toLowerCase()); a && (d = "-" + d); return d }
+			var je = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split(""); function ke(a, b) { a = parseInt(a, 10); var c = 0 > a; a = Math.abs(a); if (!a) return "-"; for (var d = "", e; 0 < a;)e = (a - 1) % je.length, d = je[e] + d, a = (a - e) / je.length | 0; b && (d = d.toLowerCase()); c && (d = "-" + d); return d } function le(a) { if (Math.floor(a) === a || isNaN(a)) return 0; a = /\d+(?:\.(\d*))?(?:[Ee](-)?(\d+))*/.exec("" + a); var b = a[1] ? a[1].length : 0; if (a[3]) { if (a[2]) return b + parseInt(a[3], 10); a = b - parseInt(a[3], 10); return 0 > a ? 0 : a } return b }
+			function me(a, b, c) { return b && 0 === a * c % 1 % .5 ? 0 === Math.floor(a * c) % 2 ? Math.floor(a * c) / c : Math.ceil(a * c) / c : Math.round(a * c) / c }
+			function ne(a, b, c, d, e, f) { var g = !1; return C.create({ next: function () { if (g) return x; var k = e.first(); if (!k) return g = !0, x; if ((B(k.type, 6) || B(k.type, 3)) && (0 === k.value || isNaN(k.value) || Infinity === k.value || -Infinity === k.value)) return g = !0, y(k); var l; f ? l = f.first().value : l = 0; g = !0; if (le(k.value) < l) return y(k); var m = [5, 4, 3, 6].find(function (u) { return B(k.type, u) }), q = Pd(k, 4); l = me(q.value, a, Math.pow(10, l)); switch (m) { case 4: return y(w(l, 4)); case 3: return y(w(l, 3)); case 6: return y(w(l, 6)); case 5: return y(w(l, 5)) } } }) }
+			function oe(a, b, c, d) { return Zc(d, b).Z({ empty: function () { return C.m(w(NaN, 3)) }, m: function () { var e = Od(d.first(), 3); return e.u ? C.m(e.value) : C.m(w(NaN, 3)) }, multiple: function () { throw Error("fn:number may only be called with zero or one values"); } }) } function pe(a) { for (var b = 5381, c = 0; c < a.length; ++c)b = 33 * b + a.charCodeAt(c), b %= Number.MAX_SAFE_INTEGER; return b }
+			function qe(a, b, c, d) {
+				function e(f) {
+					function g(k, l, m, q) { if (q.G() || q.wa()) return q; k = q.O(); l = f; for (m = k.length - 1; 1 < m; m--) { l = Mc(a, l).zb; q = l % m; var u = k[q]; k[q] = k[m]; k[m] = u } return C.create(k) } return C.m(new dc([{ key: w("number", 1), value: function () { return C.m(w(Mc(a, f).jc, 3)) } }, { key: w("next", 1), value: function () { return C.m(new Ab({ value: function () { return e(Mc(a, f).zb) }, Sa: !0, localName: "", namespaceURI: "", j: [], arity: 0, i: { type: 61, g: 3 } })) } }, {
+						key: w("permute", 1), value: function () {
+							return C.m(new Ab({
+								value: g, Sa: !0,
+								localName: "", namespaceURI: "", j: [{ type: 59, g: 2 }], arity: 1, i: { type: 59, g: 2 }
+							}))
+						}
+					}]))
+				} d = void 0 === d ? C.empty() : d; b = d.G() ? Mc(a) : Mc(a, pe(Pd(d.first(), 1).value)); return e(b.zb)
+			}
+			var re = [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "abs", j: [{ type: 2, g: 0 }], i: { type: 2, g: 0 }, callFunction: function (a, b, c, d) { return d.map(function (e) { return ge(e.type, Math.abs(e.value)) }) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "format-integer", j: [{ type: 5, g: 0 }, { type: 1, g: 3 }], i: { type: 1, g: 3 }, callFunction: function (a, b, c, d, e) {
+					a = d.first(); e = e.first(); if (d.G()) return C.m(w("", 1)); switch (e.value) {
+						case "I": return d = ie(a.value), C.m(w(d, 1)); case "i": return d = ie(a.value,
+							!0), C.m(w(d, 1)); case "A": return C.m(w(ke(a.value), 1)); case "a": return C.m(w(ke(a.value, !0), 1)); default: throw Error("Picture: " + e.value + ' is not implemented yet. The supported picture strings are "A", "a", "I", and "i"');
+					}
+				}
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "ceiling", j: [{ type: 2, g: 0 }], i: { type: 2, g: 0 }, callFunction: function (a, b, c, d) { return d.map(function (e) { return ge(e.type, Math.ceil(e.value)) }) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "floor",
+				j: [{ type: 2, g: 0 }], i: { type: 2, g: 0 }, callFunction: function (a, b, c, d) { return d.map(function (e) { return ge(e.type, Math.floor(e.value)) }) }
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "round", j: [{ type: 2, g: 0 }], i: { type: 2, g: 0 }, callFunction: ne.bind(null, !1) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "round", j: [{ type: 2, g: 0 }, { type: 5, g: 3 }], i: { type: 2, g: 0 }, callFunction: ne.bind(null, !1) }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "round-half-to-even",
+				j: [{ type: 2, g: 0 }], i: { type: 2, g: 0 }, callFunction: ne.bind(null, !0)
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "round-half-to-even", j: [{ type: 2, g: 0 }, { type: 5, g: 3 }], i: { type: 2, g: 0 }, callFunction: ne.bind(null, !0) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "number", j: [{ type: 46, g: 0 }], i: { type: 3, g: 3 }, callFunction: oe }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "number", j: [], i: { type: 3, g: 3 }, callFunction: function (a, b, c) {
+					var d = a.N && fe({ type: 46, g: 0 }, C.m(a.N),
+						b, "fn:number", !1); if (!d) throw Rc("fn:number needs an atomizable context item."); return oe(a, b, c, d)
+				}
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "random-number-generator", j: [], i: { type: 61, g: 3 }, callFunction: qe }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "random-number-generator", j: [{ type: 46, g: 0 }], i: { type: 61, g: 3 }, callFunction: qe }]; function se() { throw Error("FOCH0002: No collations are supported"); } function te(a, b, c, d) { if (null === b.N) throw Rc("The function which was called depends on dynamic context, which is absent."); return a(b, c, d, C.m(b.N)) } function ue(a, b, c, d) { return d.Z({ empty: function () { return C.m(w("", 1)) }, default: function () { return d.map(function (e) { if (B(e.type, 53)) { var f = Yc(e, b).first(); return B(e.type, 47) ? Pd(f, 1) : f } return Pd(e, 1) }) } }) }
+			function ve(a, b, c, d, e) { return ac([e], function (f) { var g = p(f).next().value; return Zc(d, b).M(function (k) { k = k.map(function (l) { return Pd(l, 1).value }).join(g.value); return C.m(w(k, 1)) }) }) } function we(a, b, c, d) { if (d.G()) return C.m(w(0, 5)); a = d.first().value; return C.m(w(Array.from(a).length, 5)) }
+			function xe(a, b, c, d, e, f) { var g = ne(!1, a, b, c, e, null), k = null !== f ? ne(!1, a, b, c, f, null) : null, l = !1, m = null, q = null, u = null; return C.create({ next: function () { if (l) return x; if (!m && (m = d.first(), null === m)) return l = !0, y(w("", 1)); q || (q = g.first()); !u && f && (u = null, u = k.first()); l = !0; return y(w(Array.from(m.value).slice(Math.max(q.value - 1, 0), f ? q.value + u.value - 1 : void 0).join(""), 1)) } }) }
+			function ye(a, b, c, d, e) { if (d.G() || 0 === d.first().value.length) return C.empty(); a = d.first().value; e = e.first().value; e = ze(e); return C.create(a.split(e).map(function (f) { return w(f, 1) })) } function Ae(a, b, c, d) { if (d.G()) return C.m(w("", 1)); a = d.first().value.trim(); return C.m(w(a.replace(/\s+/g, " "), 1)) } var Be = new Map, Ce = new Map;
+			function ze(a) { if (Ce.has(a)) return Ce.get(a); try { var b = new RegExp(a, "g") } catch (c) { throw Error("FORX0002: " + c); } if (b.test("")) throw Error("FORX0003: the pattern " + a + " matches the zero length string"); Ce.set(a, b); return b }
+			var De = [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "compare", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }], i: { type: 5, g: 0 }, callFunction: function (a, b, c, d, e) { if (d.G() || e.G()) return C.empty(); a = d.first().value; e = e.first().value; return a > e ? C.m(w(1, 5)) : a < e ? C.m(w(-1, 5)) : C.m(w(0, 5)) } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "compare", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }, { type: 1, g: 3 }], i: { type: 5, g: 0 }, callFunction: se }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "concat",
+				j: [{ type: 46, g: 0 }, { type: 46, g: 0 }, 4], i: { type: 1, g: 3 }, callFunction: function (a, b, c) { var d = Aa.apply(3, arguments); d = d.map(function (e) { return Zc(e, b).M(function (f) { return C.m(w(f.map(function (g) { return null === g ? "" : Pd(g, 1).value }).join(""), 1)) }) }); return ac(d, function (e) { return C.m(w(e.map(function (f) { return f.value }).join(""), 1)) }) }
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "contains", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }, { type: 1, g: 0 }], i: { type: 0, g: 3 }, callFunction: se }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				localName: "contains", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }], i: { type: 0, g: 3 }, callFunction: function (a, b, c, d, e) { a = d.G() ? "" : d.first().value; e = e.G() ? "" : e.first().value; return 0 === e.length ? C.ba() : 0 === a.length ? C.W() : a.includes(e) ? C.ba() : C.W() }
+			}, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "ends-with", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }], i: { type: 0, g: 3 }, callFunction: function (a, b, c, d, e) {
+					a = e.G() ? "" : e.first().value; if (0 === a.length) return C.ba(); d = d.G() ? "" : d.first().value; return 0 === d.length ? C.W() : d.endsWith(a) ?
+						C.ba() : C.W()
+				}
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "ends-with", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }, { type: 1, g: 3 }], i: { type: 0, g: 3 }, callFunction: se }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "normalize-space", j: [{ type: 1, g: 0 }], i: { type: 1, g: 3 }, callFunction: Ae }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "normalize-space", j: [], i: { type: 1, g: 3 }, callFunction: te.bind(null, function (a, b, c, d) { return Ae(a, b, c, ue(a, b, c, d)) }) }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				localName: "starts-with", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }], i: { type: 0, g: 3 }, callFunction: function (a, b, c, d, e) { a = e.G() ? "" : e.first().value; if (0 === a.length) return C.ba(); d = d.G() ? "" : d.first().value; return 0 === d.length ? C.W() : d.startsWith(a) ? C.ba() : C.W() }
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "starts-with", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }, { type: 1, g: 3 }], i: { type: 0, g: 3 }, callFunction: se }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "string", j: [{ type: 59, g: 0 }], i: { type: 1, g: 3 },
+				callFunction: ue
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "string", j: [], i: { type: 1, g: 3 }, callFunction: te.bind(null, ue) }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "substring-before", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }], i: { type: 1, g: 3 }, callFunction: function (a, b, c, d, e) { a = d.G() ? "" : d.first().value; e = e.G() ? "" : e.first().value; if ("" === e) return C.m(w("", 1)); e = a.indexOf(e); return -1 === e ? C.m(w("", 1)) : C.m(w(a.substring(0, e), 1)) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				localName: "substring-after", j: [{ type: 1, g: 0 }, { type: 1, g: 0 }], i: { type: 1, g: 3 }, callFunction: function (a, b, c, d, e) { a = d.G() ? "" : d.first().value; e = e.G() ? "" : e.first().value; if ("" === e) return C.m(w(a, 1)); b = a.indexOf(e); return -1 === b ? C.m(w("", 1)) : C.m(w(a.substring(b + e.length), 1)) }
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "substring", j: [{ type: 1, g: 0 }, { type: 3, g: 3 }], i: { type: 1, g: 3 }, callFunction: xe }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "substring", j: [{ type: 1, g: 0 }, {
+					type: 3,
+					g: 3
+				}, { type: 3, g: 3 }], i: { type: 1, g: 3 }, callFunction: xe
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "upper-case", j: [{ type: 1, g: 0 }], i: { type: 1, g: 3 }, callFunction: function (a, b, c, d) { return d.G() ? C.m(w("", 1)) : d.map(function (e) { return w(e.value.toUpperCase(), 1) }) } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "lower-case", j: [{ type: 1, g: 0 }], i: { type: 1, g: 3 }, callFunction: function (a, b, c, d) { return d.G() ? C.m(w("", 1)) : d.map(function (e) { return w(e.value.toLowerCase(), 1) }) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				localName: "string-join", j: [{ type: 46, g: 2 }, { type: 1, g: 3 }], i: { type: 1, g: 3 }, callFunction: ve
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "string-join", j: [{ type: 46, g: 2 }], i: { type: 1, g: 3 }, callFunction: function (a, b, c, d) { return ve(a, b, c, d, C.m(w("", 1))) } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "string-length", j: [{ type: 1, g: 0 }], i: { type: 5, g: 3 }, callFunction: we }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "string-length", j: [], i: { type: 5, g: 3 }, callFunction: te.bind(null,
+					function (a, b, c, d) { return we(a, b, c, ue(a, b, c, d)) })
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "tokenize", j: [{ type: 1, g: 0 }, { type: 1, g: 3 }, { type: 1, g: 3 }], i: { type: 1, g: 2 }, callFunction: function () { throw Error("Not implemented: Using flags in tokenize is not supported"); } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "tokenize", j: [{ type: 1, g: 0 }, { type: 1, g: 3 }], i: { type: 1, g: 2 }, callFunction: ye }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "tokenize", j: [{
+					type: 1,
+					g: 0
+				}], i: { type: 1, g: 2 }, callFunction: function (a, b, c, d) { return ye(a, b, c, Ae(a, b, c, d), C.m(w(" ", 1))) }
+			}, {
+				j: [{ type: 1, g: 0 }, { type: 1, g: 3 }, { type: 1, g: 3 }], callFunction: function (a, b, c, d, e, f) { return ac([d, e, f], function (g) { var k = p(g), l = k.next().value; g = k.next().value; k = k.next().value; l = Array.from(l ? l.value : ""); var m = Array.from(g.value), q = Array.from(k.value); g = l.map(function (u) { if (m.includes(u)) { if (u = m.indexOf(u), u <= q.length) return q[u] } else return u }); return C.m(w(g.join(""), 1)) }) }, localName: "translate", namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				i: { type: 1, g: 3 }
+			}, { j: [{ type: 5, g: 2 }], callFunction: function (a, b, c, d) { return d.M(function (e) { e = e.map(function (f) { f = f.value; if (9 === f || 10 === f || 13 === f || 32 <= f && 55295 >= f || 57344 <= f && 65533 >= f || 65536 <= f && 1114111 >= f) return String.fromCodePoint(f); throw Error("FOCH0001"); }).join(""); return C.m(w(e, 1)) }) }, localName: "codepoints-to-string", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 } }, {
+				j: [{ type: 1, g: 0 }], callFunction: function (a, b, c, d) {
+					return ac([d], function (e) {
+						e = (e = p(e).next().value) ? e.value.split("") :
+							[]; return 0 === e.length ? C.empty() : C.create(e.map(function (f) { return w(f.codePointAt(0), 5) }))
+					})
+				}, localName: "string-to-codepoints", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 5, g: 2 }
+			}, {
+				j: [{ type: 1, g: 0 }], callFunction: function (a, b, c, d) { return ac([d], function (e) { e = p(e).next().value; return null === e || 0 === e.value.length ? C.create(w("", 1)) : C.create(w(encodeURIComponent(e.value).replace(/[!'()*]/g, function (f) { return "%" + f.charCodeAt(0).toString(16).toUpperCase() }), 1)) }) }, localName: "encode-for-uri",
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 }
+			}, { j: [{ type: 1, g: 0 }], callFunction: function (a, b, c, d) { return ac([d], function (e) { e = p(e).next().value; return null === e || 0 === e.value.length ? C.create(w("", 1)) : C.create(w(e.value.replace(/([\u00A0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFEF "<>{}|\\^`/\n\u007f\u0080-\u009f]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g, function (f) { return encodeURI(f) }), 1)) }) }, localName: "iri-to-uri", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 } }, {
+				j: [{
+					type: 1,
+					g: 0
+				}, { type: 1, g: 0 }], callFunction: function (a, b, c, d, e) { return ac([d, e], function (f) { var g = p(f); f = g.next().value; g = g.next().value; if (null === f || null === g) return C.empty(); f = f.value; g = g.value; if (f.length !== g.length) return C.W(); f = f.split(""); g = g.split(""); for (var k = 0; k < f.length; k++)if (f[k].codePointAt(0) !== g[k].codePointAt(0)) return C.W(); return C.ba() }) }, localName: "codepoint-equal", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 0, g: 0 }
+			}, {
+				j: [{ type: 1, g: 0 }, { type: 1, g: 3 }], callFunction: function (a,
+					b, c, d, e) { return ac([d, e], function (f) { var g = p(f); f = g.next().value; g = g.next().value; f = f ? f.value : ""; g = g.value; var k = Be.get(g); if (!k) { try { k = be.compile(g, { language: "xpath" }) } catch (l) { throw Error("FORX0002: " + l); } Be.set(g, k) } return k(f) ? C.ba() : C.W() }) }, localName: "matches", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 0, g: 3 }
+			}, {
+				j: [{ type: 1, g: 0 }, { type: 1, g: 3 }, { type: 1, g: 3 }], callFunction: function (a, b, c, d, e, f) {
+					return ac([d, e, f], function (g) {
+						var k = p(g); g = k.next().value; var l = k.next().value; k = k.next().value;
+						g = g ? g.value : ""; l = l.value; k = k.value; if (k.includes("$0")) throw Error("Using $0 in fn:replace to replace substrings with full matches is not supported."); k = k.split(/((?:\$\$)|(?:\\\$)|(?:\\\\))/).map(function (m) { switch (m) { case "\\$": return "$$"; case "\\\\": return "\\"; case "$$": throw Error('FORX0004: invalid replacement: "$$"'); default: return m } }).join(""); l = ze(l); g = g.replace(l, k); return C.m(w(g, 1))
+					})
+				}, localName: "replace", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 }
+			}, {
+				j: [{
+					type: 1,
+					g: 0
+				}, { type: 1, g: 3 }, { type: 1, g: 3 }, { type: 1, g: 3 }], localName: "replace", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 }, callFunction: function () { throw Error("Not implemented: Using flags in replace is not supported"); }
+			}]; function Ee(a, b, c, d, e) { if (null === c.N) throw Rc("The function " + a + " depends on dynamic context, which is absent."); return b(c, d, e, C.m(c.N)) } function Fe(a, b, c, d) { return ac([d], function (e) { e = p(e).next().value; if (null === e) return C.empty(); e = e.value; switch (e.node.nodeType) { case 1: case 2: return C.m(w(new zb(e.node.prefix, e.node.namespaceURI, e.node.localName), 23)); case 7: return C.m(w(new zb("", "", e.node.target), 23)); default: return C.empty() } }) }
+			function Ge(a, b, c, d) { return d.Z({ default: function () { return ue(a, b, c, Fe(a, b, c, d)) }, empty: function () { return C.m(w("", 1)) } }) } function He(a, b, c, d) { return Zc(d, b) } function Ie(a, b, c, d) { return ac([d], function (e) { e = (e = p(e).next().value) ? e.value : null; return null !== e && Sb(b.h, e, null) ? C.ba() : C.W() }) }
+			function Je(a, b, c, d) {
+				return ac([d], function (e) {
+					function f(m) { for (var q = 0, u = m; null !== u;)(m.node.nodeType !== u.node.nodeType ? 0 : 1 === u.node.nodeType ? u.node.localName === m.node.localName && u.node.namespaceURI === m.node.namespaceURI : 7 === u.node.nodeType ? u.node.target === m.node.target : 1) && q++, u = Wb(k, u, null); return q } var g = p(e).next().value; if (null === g) return C.empty(); var k = b.h; e = ""; for (g = g.value; null !== Vb(b.h, g, null); g = Vb(b.h, g, null))switch (g.node.nodeType) {
+						case 1: var l = g; e = "/Q{" + (l.node.namespaceURI || "") + "}" +
+							l.node.localName + "[" + f(l) + "]" + e; break; case 2: l = g; e = "/@" + (l.node.namespaceURI ? "Q{" + l.node.namespaceURI + "}" : "") + l.node.localName + e; break; case 3: e = "/text()[" + f(g) + "]" + e; break; case 7: l = g; e = "/processing-instruction(" + l.node.target + ")[" + f(l) + "]" + e; break; case 8: e = "/comment()[" + f(g) + "]" + e
+					}return 9 === g.node.nodeType ? C.create(w(e || "/", 1)) : C.create(w("Q{http://www.w3.org/2005/xpath-functions}root()" + e, 1))
+				})
+			} function Ke(a, b, c, d) { return d.map(function (e) { return w(e.value.node.namespaceURI || "", 20) }) }
+			function Le(a, b, c, d) { return d.Z({ default: function () { return d.map(function (e) { return 7 === e.value.node.nodeType ? w(e.value.node.target, 1) : w(e.value.node.localName || "", 1) }) }, empty: function () { return C.m(w("", 1)) } }) } function Me(a, b, c) { if (2 === b.node.nodeType) return Sd(b, c); for (; c;) { if (Sd(b, c)) return !0; if (9 === c.node.nodeType) break; c = Vb(a, c, null) } return !1 }
+			function Ne(a, b, c, d) { return d.map(function (e) { if (!B(e.type, 53)) throw Error("XPTY0004 Argument passed to fn:root() should be of the type node()"); for (e = e.value; e;) { var f = e; e = Vb(b.h, f, null) } return $b(f) }) }
+			var Oe = [{ j: [{ type: 53, g: 0 }], callFunction: Ge, localName: "name", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 } }, { j: [], callFunction: Ee.bind(null, "name", Ge), localName: "name", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 } }, { j: [{ type: 53, g: 3 }], callFunction: Ke, localName: "namespace-uri", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 20, g: 3 } }, {
+				j: [], callFunction: Ee.bind(null, "namespace-uri", Ke), localName: "namespace-uri", namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				i: { type: 20, g: 3 }
+			}, { j: [{ type: 53, g: 2 }], callFunction: function (a, b, c, d) { return d.M(function (e) { if (!e.length) return C.empty(); e = Zd(b.h, e).reduceRight(function (f, g, k, l) { if (k === l.length - 1) return f.push(g), f; if (Me(b.h, g.value, f[0].value)) return f; f.unshift(g); return f }, []); return C.create(e) }) }, localName: "innermost", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 53, g: 2 } }, {
+				j: [{ type: 53, g: 2 }], callFunction: function (a, b, c, d) {
+					return d.M(function (e) {
+						if (!e.length) return C.empty(); e = Zd(b.h, e).reduce(function (f,
+							g, k) { if (0 === k) return f.push(g), f; if (Me(b.h, f[f.length - 1].value, g.value)) return f; f.push(g); return f }, []); return C.create(e)
+					}, 1)
+				}, localName: "outermost", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 53, g: 2 }
+			}, { j: [{ type: 53, g: 0 }], callFunction: Ie, localName: "has-children", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 0, g: 3 } }, { j: [], callFunction: Ee.bind(null, "has-children", Ie), localName: "has-children", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 0, g: 3 } }, {
+				j: [{
+					type: 53,
+					g: 0
+				}], callFunction: Je, localName: "path", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 0 }
+			}, { j: [], callFunction: Ee.bind(null, "path", Je), localName: "path", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 0 } }, { j: [{ type: 53, g: 0 }], callFunction: Fe, localName: "node-name", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 23, g: 0 } }, {
+				j: [], callFunction: Ee.bind(null, "node-name", Fe), localName: "node-name", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: {
+					type: 23,
+					g: 0
+				}
+			}, { j: [{ type: 53, g: 0 }], callFunction: Le, localName: "local-name", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 } }, { j: [], callFunction: Ee.bind(null, "local-name", Le), localName: "local-name", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 } }, { j: [{ type: 53, g: 0 }], callFunction: Ne, localName: "root", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 53, g: 0 } }, {
+				j: [], callFunction: Ee.bind(null, "root", Ne), localName: "root", namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				i: { type: 53, g: 0 }
+			}, { j: [], callFunction: Ee.bind(null, "data", He), localName: "data", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 2 } }, { j: [{ type: 59, g: 2 }], callFunction: He, localName: "data", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 2 } }]; function Pe(a, b) { var c = 0, d = a.length, e = !1, f = null; return { next: function () { if (!e) { for (; c < d;) { f || (f = b(a[c], c, a)); var g = f.next(0); f = null; if (g.value) c++; else return y(!1) } e = !0; return y(!0) } return x } } } function Qe(a) { a = a.node.nodeType; return 1 === a || 3 === a }
+			function Re(a, b) {
+				if ((B(a.type, 4) || B(a.type, 6)) && (B(b.type, 4) || B(b.type, 6))) { var c = Pd(a, 6), d = Pd(b, 6); return c.value === d.value || isNaN(a.value) && isNaN(b.value) } return (B(a.type, 4) || B(a.type, 6) || B(a.type, 3)) && (B(b.type, 4) || B(b.type, 6) || B(b.type, 3)) ? (c = Pd(a, 3), d = Pd(b, 3), c.value === d.value || isNaN(a.value) && isNaN(b.value)) : B(a.type, 23) && B(b.type, 23) ? a.value.namespaceURI === b.value.namespaceURI && a.value.localName === b.value.localName : (B(a.type, 9) || B(a.type, 7) || B(a.type, 8) || B(a.type, 11) || B(a.type, 12) || B(a.type,
+					13) || B(a.type, 14) || B(a.type, 15)) && (B(b.type, 9) || B(b.type, 7) || B(b.type, 8) || B(b.type, 11) || B(b.type, 12) || B(b.type, 13) || B(b.type, 14) || B(b.type, 15)) ? wc(a.value, b.value) : (B(a.type, 16) || B(a.type, 17) || B(a.type, 18)) && (B(b.type, 16) || B(b.type, 17) || B(b.type, 17)) ? fc(a.value, b.value) : a.value === b.value
+			} function Se(a, b, c) { c = p([b, c].map(function (d) { return { type: 1, value: d.reduce(function (e, f) { return e += Yc(f, a).first().value }, "") } })); b = c.next().value; c = c.next().value; return y(Re(b, c)) }
+			function Te(a, b, c, d) { for (; a.value && B(a.value.type, 56);) { b.push(a.value); var e = Ub(d, a.value.value); a = c.next(0); if (e && 3 !== e.node.nodeType) break } return a }
+			function Ue(a, b, c, d, e) { var f = b.h, g = d.value, k = e.value, l = null, m = null, q = null, u, z = [], A = []; return { next: function () { for (; !u;)if (l || (l = g.next(0)), l = Te(l, z, g, f), m || (m = k.next(0)), m = Te(m, A, k, f), z.length || A.length) { var D = Se(b, z, A); z.length = 0; A.length = 0; if (!1 === D.value) return u = !0, D } else { if (l.done || m.done) return u = !0, y(l.done === m.done); q || (q = Ve(a, b, c, l.value, m.value)); D = q.next(0); q = null; if (!1 === D.value) return u = !0, D; m = l = null } return x } } }
+			function We(a, b, c, d, e) { return d.h.length !== e.h.length ? Qd(!1) : Pe(d.h, function (f) { var g = e.h.find(function (k) { return Re(k.key, f.key) }); return g ? Ue(a, b, c, f.value(), g.value()) : Qd(!1) }) } function Xe(a, b, c, d, e) { return d.P.length !== e.P.length ? Qd(!1) : Pe(d.P, function (f, g) { g = e.P[g]; return Ue(a, b, c, f(), g()) }) }
+			function Ye(a, b, c, d, e) { d = Pb(b.h, d.value); e = Pb(b.h, e.value); d = d.filter(function (f) { return Qe(f) }); e = e.filter(function (f) { return Qe(f) }); d = C.create(d.map(function (f) { return $b(f) })); e = C.create(e.map(function (f) { return $b(f) })); return Ue(a, b, c, d, e) }
+			function Ze(a, b, c, d, e) {
+				var f = Ue(a, b, c, Fe(a, b, c, C.m(d)), Fe(a, b, c, C.m(e))), g = Ye(a, b, c, d, e); d = Nb(b.h, d.value).filter(function (m) { return "http://www.w3.org/2000/xmlns/" !== m.node.namespaceURI }).sort(function (m, q) { return m.node.nodeName > q.node.nodeName ? 1 : -1 }).map(function (m) { return $b(m) }); e = Nb(b.h, e.value).filter(function (m) { return "http://www.w3.org/2000/xmlns/" !== m.node.namespaceURI }).sort(function (m, q) { return m.node.nodeName > q.node.nodeName ? 1 : -1 }).map(function (m) { return $b(m) }); var k = Ue(a, b, c, C.create(d),
+					C.create(e)), l = !1; return { next: function () { if (l) return x; var m = f.next(0); if (!m.done && !1 === m.value) return l = !0, m; m = k.next(0); if (!m.done && !1 === m.value) return l = !0, m; m = g.next(0); l = !0; return m } }
+			} function $e(a, b, c, d, e) { var f = Ue(a, b, c, Fe(a, b, c, C.m(d)), Fe(a, b, c, C.m(e))), g = !1; return { next: function () { if (g) return x; var k = f.next(0); return k.done || !1 !== k.value ? y(Re(Yc(d, b).first(), Yc(e, b).first())) : (g = !0, k) } } }
+			function Ve(a, b, c, d, e) { if (B(d.type, 46) && B(e.type, 46)) return Qd(Re(d, e)); if (B(d.type, 61) && B(e.type, 61)) return We(a, b, c, d, e); if (B(d.type, 62) && B(e.type, 62)) return Xe(a, b, c, d, e); if (B(d.type, 53) && B(e.type, 53)) { if (B(d.type, 55) && B(e.type, 55)) return Ye(a, b, c, d, e); if (B(d.type, 54) && B(e.type, 54)) return Ze(a, b, c, d, e); if (B(d.type, 47) && B(e.type, 47) || B(d.type, 57) && B(e.type, 57) || B(d.type, 58) && B(e.type, 58)) return $e(a, b, c, d, e) } return Qd(!1) }; function af(a) { return Error("XUST0001: " + (void 0 === a ? "Can not execute an updating expression in a non-updating context." : a)) } function bf(a) { return Error("XUTY0004: The attribute " + a.name + '="' + a.value + '" follows a node that is not an attribute node.') } function cf() { return Error("XUTY0005: The target of a insert expression with into must be a single element or document node.") }
+			function df() { return Error("XUTY0006: The target of a insert expression with before or after must be a single element, text, comment, or processing instruction node.") } function ff() { return Error("XUTY0008: The target of a replace expression must be a single element, attribute, text, comment, or processing instruction node.") } function gf() { return Error("XUTY0012: The target of a rename expression must be a single element, attribute, or processing instruction node.") }
+			function hf(a) { return Error("XUDY0017: The target " + a.outerHTML + " is used in more than one replace value of expression.") } function jf(a) { return Error("XUDY0021: Applying the updates will result in the XDM instance violating constraint: '" + a + "'") } function kf(a) { return Error("XUDY0023: The namespace binding " + a + " is conflicting.") } function lf(a) { return Error("XUDY0024: The namespace binding " + a + " is conflicting.") }
+			function mf() { return Error("XUDY0027: The target for an insert, replace, or rename expression expression should not be empty.") }; function H(a, b, c, d, e) { c = void 0 === c ? { C: !1, X: !1, R: "unsorted", subtree: !1 } : c; this.o = a; this.da = c.R || "unsorted"; this.subtree = !!c.subtree; this.X = !!c.X; this.C = !!c.C; this.ta = b; this.I = !1; this.ab = null; this.Yb = void 0 === d ? !1 : d; this.type = e } function I(a, b, c) { b && null !== b.N ? a.C ? (null === a.ab && (a.ab = yb(a.h(null, c).sb())), a = a.ab()) : a = a.h(b, c) : a = a.h(b, c); return a } H.prototype.B = function () { return null };
+			H.prototype.v = function (a) { this.ta.forEach(function (b) { return b.v(a) }); if (!this.Yb && this.ta.some(function (b) { return b.I })) throw af(); }; function nf(a, b) { this.J = a; this.fa = b }; function of(a) { a && "object" === typeof a && "nodeType" in a && (a = a.ownerDocument || a, "function" === typeof a.createElementNS && "function" === typeof a.createProcessingInstruction && "function" === typeof a.createTextNode && "function" === typeof a.createComment && (this.h = a)); this.h || (this.h = null) } h = of.prototype; h.createAttributeNS = function (a, b) { if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors"); return this.h.createAttributeNS(a, b) };
+			h.createCDATASection = function (a) { if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors"); return this.h.createCDATASection(a) }; h.createComment = function (a) { if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors"); return this.h.createComment(a) }; h.createDocument = function () { if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors"); return this.h.implementation.createDocument(null, null, null) };
+			h.createElementNS = function (a, b) { if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors"); return this.h.createElementNS(a, b) }; h.createProcessingInstruction = function (a, b) { if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors"); return this.h.createProcessingInstruction(a, b) }; h.createTextNode = function (a) { if (!this.h) throw Error("Please pass a node factory if an XQuery script uses node constructors"); return this.h.createTextNode(a) }; function pf(a, b, c, d) { var e = Vb(c, a).node, f = (a = Ub(c, a)) ? a.node : null; b.forEach(function (g) { d.insertBefore(e, g.node, f) }) } function qf(a, b, c, d) { var e = Vb(c, a).node; b.forEach(function (f) { d.insertBefore(e, f.node, a.node) }) } function rf(a, b, c, d) { var e = (c = Sb(c, a)) ? c.node : null; b.forEach(function (f) { d.insertBefore(a.node, f.node, e) }) } function sf(a, b, c) { b.forEach(function (d) { c.insertBefore(a.node, d.node, null) }) }
+			function tf(a, b, c, d) { b.forEach(function (e) { var f = e.node.nodeName; if (Ob(c, a, f)) throw jf("An attribute " + f + " already exists."); d.setAttributeNS(a.node, e.node.namespaceURI, f, Qb(c, e)) }) }
+			function uf(a, b, c, d, e) {
+				d || (d = new of(a ? a.node : null)); switch (a.node.nodeType) { case 1: var f = c.getAllAttributes(a.node), g = c.getChildNodes(a.node), k = d.createElementNS(b.namespaceURI, b.Ca()); var l = { node: k, F: null }; f.forEach(function (m) { e.setAttributeNS(k, m.namespaceURI, m.nodeName, m.value) }); g.forEach(function (m) { e.insertBefore(k, m, null) }); break; case 2: b = d.createAttributeNS(b.namespaceURI, b.Ca()); b.value = Qb(c, a); l = { node: b, F: null }; break; case 7: l = { node: d.createProcessingInstruction(b.Ca(), Qb(c, a)), F: null } }if (!Vb(c,
+					a)) throw Error("Not supported: renaming detached nodes."); vf(a, [l], c, e)
+			} function wf(a, b, c, d) { c.getChildNodes(a.node).forEach(function (e) { return d.removeChild(a.node, e) }); b && d.insertBefore(a.node, b.node, null) }
+			function vf(a, b, c, d) {
+				var e = Vb(c, a), f = a.node.nodeType; if (2 === f) { if (b.some(function (l) { return 2 !== l.node.nodeType })) throw Error('Constraint "If $target is an attribute node, $replacement must consist of zero or more attribute nodes." failed.'); var g = e ? e.node : null; d.removeAttributeNS(g, a.node.namespaceURI, a.node.nodeName); b.forEach(function (l) { var m = l.node.nodeName; if (Ob(c, e, m)) throw jf("An attribute " + m + " already exists."); d.setAttributeNS(g, l.node.namespaceURI, m, Qb(c, l)) }) } if (1 === f || 3 === f || 8 === f ||
+					7 === f) { var k = (f = Ub(c, a)) ? f.node : null; d.removeChild(e.node, a.node); b.forEach(function (l) { d.insertBefore(e.node, l.node, k) }) }
+			}; function xf(a, b, c, d) {
+				yf(a, b); a.filter(function (e) { return -1 !== ["insertInto", "insertAttributes", "replaceValue", "rename"].indexOf(e.type) }).forEach(function (e) {
+					switch (e.type) {
+						case "insertInto": sf(e.target, e.content, d); break; case "insertAttributes": tf(e.target, e.content, b, d); break; case "rename": uf(e.target, e.o, b, c, d); break; case "replaceValue": var f = e.target; e = e.o; if (2 === f.node.nodeType) { var g = Vb(b, f); g ? d.setAttributeNS(g.node, f.node.namespaceURI, f.node.nodeName, e) : f.node.value = e } else d.setData(f.node,
+							e)
+					}
+				}); a.filter(function (e) { return -1 !== ["insertBefore", "insertAfter", "insertIntoAsFirst", "insertIntoAsLast"].indexOf(e.type) }).forEach(function (e) { switch (e.type) { case "insertAfter": pf(e.target, e.content, b, d); break; case "insertBefore": qf(e.target, e.content, b, d); break; case "insertIntoAsFirst": rf(e.target, e.content, b, d); break; case "insertIntoAsLast": sf(e.target, e.content, d) } }); a.filter(function (e) { return "replaceNode" === e.type }).forEach(function (e) { vf(e.target, e.o, b, d) }); a.filter(function (e) {
+					return "replaceElementContent" ===
+						e.type
+				}).forEach(function (e) { wf(e.target, e.text, b, d) }); a.filter(function (e) { return "delete" === e.type }).forEach(function (e) { e = e.target; var f = Vb(b, e); (f = f ? f.node : null) && (2 === e.node.nodeType ? d.removeAttributeNS(f, e.node.namespaceURI, e.node.nodeName) : d.removeChild(f, e.node)) }); if (a.some(function (e) { return "put" === e.type })) throw Error('Not implemented: the execution for pendingUpdate "put" is not yet implemented.');
+			}
+			function yf(a, b) {
+				function c(f) { return new zb(f.node.prefix, f.node.namespaceURI, f.node.localName) } function d(f, g) { var k = new Set; a.filter(function (l) { return l.type === f }).map(function (l) { return l.target }).forEach(function (l) { l = l ? l.node : null; k.has(l) && g(l); k.add(l) }) } d("rename", function (f) { throw Error("XUDY0015: The target " + f.outerHTML + " is used in more than one rename expression."); }); d("replaceNode", function (f) {
+					throw Error("XUDY0016: The target " + f.outerHTML + " is used in more than one replace expression.");
+				}); d("replaceValue", function (f) { throw hf(f); }); d("replaceElementContent", function (f) { throw hf(f); }); var e = new Map; a.filter(function (f) { return "replaceNode" === f.type && 2 === f.target.node.nodeType }).forEach(function (f) { var g = Vb(b, f.target); g = g ? g.node : null; var k = e.get(g); k ? k.push.apply(k, t(f.o.map(c))) : e.set(g, f.o.map(c)) }); a.filter(function (f) { return "rename" === f.type && 2 === f.target.node.nodeType }).forEach(function (f) { var g = Vb(b, f.target); if (g) { g = g.node; var k = e.get(g); k ? k.push(f.o) : e.set(g, [f.o]) } }); e.forEach(function (f) {
+					var g =
+						{}; f.forEach(function (k) { g[k.prefix] || (g[k.prefix] = k.namespaceURI); if (g[k.prefix] !== k.namespaceURI) throw lf(k.namespaceURI); })
+				})
+			} function zf(a) { return a.concat.apply(a, t(Aa.apply(1, arguments).filter(Boolean))) }; function Af(a, b, c, d) { H.call(this, a, b, c, !0, d); this.I = !0 } v(Af, H); Af.prototype.h = function () { throw af(); }; function Bf(a) { return a.I ? function (b, c) { return a.s(b, c) } : function (b, c) { var d = a.h(b, c); return { next: function () { var e = d.O(); return y({ fa: [], J: e }) } } } }; function Cf(a, b) { a = a.next(0); b(a.value.fa); return C.create(a.value.J) } function Df(a, b, c, d) { Af.call(this, a, b, c, d); this.I = this.ta.some(function (e) { return e.I }) } v(Df, Af); Df.prototype.h = function (a, b) { return this.A(a, b, this.ta.map(function (c) { return function (d) { return c.h(d, b) } })) };
+			Df.prototype.s = function (a, b) { var c = [], d = this.A(a, b, this.ta.map(function (f) { return f.I ? function (g) { g = f.s(g, b); return Cf(g, function (k) { return c = zf(c, k) }) } : function (g) { return f.h(g, b) } })), e = !1; return { next: function () { if (e) return x; var f = d.O(); e = !0; return y(new nf(f, c)) } } }; Df.prototype.v = function (a) { Af.prototype.v.call(this, a); Ef(this) }; function Ef(a) { a.ta.some(function (b) { return b.I }) && (a.I = !0) }; var Ff = ["external", "attribute", "nodeName", "nodeType", "universal"], Gf = Ff.length; function Hf(a) { this.h = Ff.map(function (b) { return a[b] || 0 }); if (Object.keys(a).some(function (b) { return !Ff.includes(b) })) throw Error("Invalid specificity kind passed"); } Hf.prototype.add = function (a) { var b = this, c = Ff.reduce(function (d, e, f) { d[e] = b.h[f] + a.h[f]; return d }, Object.create(null)); return new Hf(c) }; function If(a, b) { for (var c = 0; c < Gf; ++c) { if (b.h[c] < a.h[c]) return 1; if (b.h[c] > a.h[c]) return -1 } return 0 }; function Jf() { return Sc("Expected base expression of a function call to evaluate to a sequence of single function item") } function Kf(a, b, c, d) { for (var e = [], f = 0; f < b.length; ++f)if (null === b[f]) e.push(null); else { var g = fe(a[f], b[f], c, d, !1); e.push(g) } return e } function Lf(a, b) { if (!B(a.type, 60)) throw Sc("Expected base expression to evaluate to a function item"); if (a.v !== b) throw Jf(); return a }
+			function Mf(a, b, c, d, e, f, g) { var k = 0; e = e.map(function (l) { return l ? null : f[k++](c) }); e = Kf(a.o, e, d, a.B); if (0 <= e.indexOf(null)) return Cb(a, e); b = b.apply(void 0, [c, d, g].concat(t(e))); return fe(a.s, b, d, a.B, !0) } function Nf(a, b, c) { var d = {}; Df.call(this, new Hf((d.external = 1, d)), [a].concat(b.filter(function (e) { return !!e })), { R: "unsorted", X: !1, subtree: !1, C: !1 }, c); this.la = b.length; this.S = b.map(function (e) { return null === e }); this.K = null; this.pa = a; this.Ba = b } v(Nf, Df);
+			Nf.prototype.s = function (a, b) { var c = this; if (!this.l || !this.l.I) return Df.prototype.s.call(this, a, b); var d = [], e = Mf(this.l, function (g, k, l) { return Cf(c.l.value.apply(c.l, [g, k, l].concat(t(Aa.apply(3, arguments)))), function (m) { d = zf(d, m) }) }, a, b, this.S, this.Ba.map(function (g) { return function () { return g.I ? Cf(g.s(a, b), function (k) { d = zf(d, k) }) : I(g, a, b) } }), this.K), f = !1; return { next: function () { if (f) return x; var g = e.O(); f = !0; return y({ fa: d, J: g }) } } };
+			Nf.prototype.A = function (a, b, c) {
+				var d = this; c = p(c); var e = c.next().value, f = ja(c); if (this.l) return Mf(this.l, function (k, l, m) { return d.l.value.apply(d.l, [k, l, m].concat(t(Aa.apply(3, arguments)))) }, a, b, this.S, f, this.K); var g = e(a); return g.Z({
+					default: function () { throw Jf(); }, m: function () {
+						return g.M(function (k) {
+							k = p(k).next().value; k = Lf(k, d.la); if (k.I) throw Error("XUDY0038: The function returned by the PrimaryExpr of a dynamic function invocation can not be an updating function"); return Mf(k, k.value, a, b, d.S,
+								f, d.K)
+						})
+					}
+				})
+			}; Nf.prototype.v = function (a) { this.K = Of(a); Df.prototype.v.call(this, a); if (this.pa.C) { a = I(this.pa, null, null); if (!a.wa()) throw Jf(); this.l = Lf(a.first(), this.la); this.l.I && (this.I = !0) } }; function Pf(a, b, c, d, e, f) { return ac([d, e, f], function (g) { var k = p(g); g = k.next().value; var l = k.next().value; k = k.next().value; l = l.value; k = k.value; if (l > g.P.length || 0 >= l) throw Error("FOAY0001: subarray start out of bounds."); if (0 > k) throw Error("FOAY0002: subarray length out of bounds."); if (l + k > g.P.length + 1) throw Error("FOAY0001: subarray start + length out of bounds."); return C.m(new Yb(g.P.slice(l - 1, k + l - 1))) }) }
+			function Qf(a, b, c, d, e) { return ac([d], function (f) { var g = p(f).next().value; return e.M(function (k) { k = k.map(function (z) { return z.value }).sort(function (z, A) { return A - z }).filter(function (z, A, D) { return D[A - 1] !== z }); for (var l = g.P.concat(), m = 0, q = k.length; m < q; ++m) { var u = k[m]; if (u > g.P.length || 0 >= u) throw Error("FOAY0001: subarray position out of bounds."); l.splice(u - 1, 1) } return C.m(new Yb(l)) }) }) } function Rf(a) { return B(a, 1) || B(a, 20) || B(a, 19) }
+			function Sf(a, b, c, d, e) { return 0 === d.length ? 0 !== e.length : 0 !== e.length && Ve(a, b, c, d[0], e[0]).next(0).value ? Sf(a, b, c, d.slice(1), e.slice(1)) : d[0].value !== d[0].value ? !0 : Rf(d[0].type) && 0 !== e.length && Rf(e[0].type) ? d[0].value < e[0].value : 0 === e.length ? !1 : d[0].value < e[0].value } function Tf(a, b, c, d) { d.sort(function (e, f) { return Ue(a, b, c, C.create(e), C.create(f)).next(0).value ? 0 : Sf(a, b, c, e, f) ? -1 : 1 }); return C.m(new Yb(d.map(function (e) { return function () { return C.create(e) } }))) }
+			function Uf(a, b) { return B(b.type, 62) ? b.P.reduce(function (c, d) { return d().M(function (e) { return e.reduce(Uf, c) }) }, a) : Pc([a, C.m(b)]) }
+			var Vf = [{ namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "size", j: [{ type: 62, g: 3 }], i: { type: 5, g: 3 }, callFunction: function (a, b, c, d) { return ac([d], function (e) { e = p(e).next().value; return C.m(w(e.P.length, 5)) }) } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "get", j: [{ type: 62, g: 3 }, { type: 5, g: 3 }], i: { type: 59, g: 2 }, callFunction: Xb }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "put", j: [{ type: 62, g: 3 }, { type: 5, g: 3 }, { type: 59, g: 2 }], i: {
+					type: 62,
+					g: 3
+				}, callFunction: function (a, b, c, d, e, f) { return ac([e, d], function (g) { var k = p(g); g = k.next().value; k = k.next().value; g = g.value; if (0 >= g || g > k.P.length) throw Error("FOAY0001: array position out of bounds."); k = k.P.concat(); k.splice(g - 1, 1, yb(f)); return C.m(new Yb(k)) }) }
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "append", j: [{ type: 62, g: 3 }, { type: 59, g: 2 }], i: { type: 62, g: 3 }, callFunction: function (a, b, c, d, e) { return ac([d], function (f) { f = p(f).next().value.P.concat([yb(e)]); return C.m(new Yb(f)) }) } },
+			{ namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "subarray", j: [{ type: 62, g: 3 }, { type: 5, g: 3 }, { type: 5, g: 3 }], i: { type: 62, g: 3 }, callFunction: Pf }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "subarray", j: [{ type: 62, g: 3 }, { type: 5, g: 3 }], i: { type: 62, g: 3 }, callFunction: function (a, b, c, d, e) { var f = C.m(w(d.first().value.length - e.first().value + 1, 5)); return Pf(a, b, c, d, e, f) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "remove", j: [{ type: 62, g: 3 }, {
+					type: 5,
+					g: 2
+				}], i: { type: 62, g: 3 }, callFunction: Qf
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "insert-before", j: [{ type: 62, g: 3 }, { type: 5, g: 3 }, { type: 59, g: 2 }], i: { type: 62, g: 3 }, callFunction: function (a, b, c, d, e, f) { return ac([d, e], function (g) { var k = p(g); g = k.next().value; k = k.next().value.value; if (k > g.P.length + 1 || 0 >= k) throw Error("FOAY0001: subarray position out of bounds."); g = g.P.concat(); g.splice(k - 1, 0, yb(f)); return C.m(new Yb(g)) }) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/array",
+				localName: "head", j: [{ type: 62, g: 3 }], i: { type: 59, g: 2 }, callFunction: function (a, b, c, d) { return Xb(a, b, c, d, C.m(w(1, 5))) }
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "tail", j: [{ type: 62, g: 3 }], i: { type: 59, g: 2 }, callFunction: function (a, b, c, d) { return Qf(a, b, c, d, C.m(w(1, 5))) } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "reverse", j: [{ type: 62, g: 3 }], i: { type: 62, g: 3 }, callFunction: function (a, b, c, d) { return ac([d], function (e) { e = p(e).next().value; return C.m(new Yb(e.P.concat().reverse())) }) } },
+			{ namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "join", j: [{ type: 62, g: 2 }], i: { type: 62, g: 3 }, callFunction: function (a, b, c, d) { return d.M(function (e) { e = e.reduce(function (f, g) { return f.concat(g.P) }, []); return C.m(new Yb(e)) }) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "for-each", j: [{ type: 62, g: 3 }, { type: 60, g: 3 }], i: { type: 62, g: 3 }, callFunction: function (a, b, c, d, e) {
+					return ac([d, e], function (f) {
+						f = p(f); var g = f.next().value, k = f.next().value; if (1 !== k.v) throw Sc("The callback passed into array:for-each has a wrong arity.");
+						f = g.P.map(function (l) { return yb(k.value.call(void 0, a, b, c, Kf(k.o, [l()], b, "array:for-each")[0])) }); return C.m(new Yb(f))
+					})
+				}
+			}, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "filter", j: [{ type: 62, g: 3 }, { type: 60, g: 3 }], i: { type: 62, g: 3 }, callFunction: function (a, b, c, d, e) {
+					return ac([d, e], function (f) {
+						f = p(f); var g = f.next().value, k = f.next().value; if (1 !== k.v) throw Sc("The callback passed into array:filter has a wrong arity."); var l = g.P.map(function (u) {
+							u = Kf(k.o, [u()], b, "array:filter")[0]; var z =
+								k.value; return z(a, b, c, u)
+						}), m = [], q = !1; return C.create({ next: function () { if (q) return x; for (var u = 0, z = g.P.length; u < z; ++u) { var A = l[u].ha(); m[u] = A } u = g.P.filter(function (D, F) { return m[F] }); q = !0; return y(new Yb(u)) } })
+					})
+				}
+			}, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "fold-left", j: [{ type: 62, g: 3 }, { type: 59, g: 2 }, { type: 60, g: 3 }], i: { type: 59, g: 2 }, callFunction: function (a, b, c, d, e, f) {
+					return ac([d, f], function (g) {
+						g = p(g); var k = g.next().value, l = g.next().value; if (2 !== l.v) throw Sc("The callback passed into array:fold-left has a wrong arity.");
+						return k.P.reduce(function (m, q) { q = Kf(l.o, [q()], b, "array:fold-left")[0]; return l.value.call(void 0, a, b, c, m, q) }, e)
+					})
+				}
+			}, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "fold-right", j: [{ type: 62, g: 3 }, { type: 59, g: 2 }, { type: 60, g: 3 }], i: { type: 59, g: 2 }, callFunction: function (a, b, c, d, e, f) {
+					return ac([d, f], function (g) {
+						g = p(g); var k = g.next().value, l = g.next().value; if (2 !== l.v) throw Sc("The callback passed into array:fold-right has a wrong arity."); return k.P.reduceRight(function (m, q) {
+							q = Kf(l.o,
+								[q()], b, "array:fold-right")[0]; return l.value.call(void 0, a, b, c, m, q)
+						}, e)
+					})
+				}
+			}, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "for-each-pair", j: [{ type: 62, g: 3 }, { type: 62, g: 3 }, { type: 60, g: 3 }], i: { type: 62, g: 3 }, callFunction: function (a, b, c, d, e, f) {
+					return ac([d, e, f], function (g) {
+						var k = p(g); g = k.next().value; var l = k.next().value; k = k.next().value; if (2 !== k.v) throw Sc("The callback passed into array:for-each-pair has a wrong arity."); for (var m = [], q = 0, u = Math.min(g.P.length, l.P.length); q < u; ++q) {
+							var z =
+								p(Kf(k.o, [g.P[q](), l.P[q]()], b, "array:for-each-pair")), A = z.next().value; z = z.next().value; m[q] = yb(k.value.call(void 0, a, b, c, A, z))
+						} return C.m(new Yb(m))
+					})
+				}
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "sort", j: [{ type: 62, g: 3 }], i: { type: 62, g: 3 }, callFunction: function (a, b, c, d) { return ac([d], function (e) { e = p(e).next().value.P.map(function (f) { return f().O() }); return Tf(a, b, c, e) }) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/array", localName: "flatten", j: [{ type: 59, g: 2 }],
+				i: { type: 59, g: 2 }, callFunction: function (a, b, c, d) { return d.M(function (e) { return e.reduce(Uf, C.empty()) }) }
+			}]; function K(a, b, c, d, e) { return e.G() ? e : C.m(Pd(e.first(), a)) }
+			var Wf = [{ namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "untypedAtomic", j: [{ type: 46, g: 0 }], i: { type: 19, g: 0 }, callFunction: K.bind(null, 19) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "error", j: [{ type: 46, g: 0 }], i: { type: 39, g: 0 }, callFunction: K.bind(null, 39) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "string", j: [{ type: 46, g: 0 }], i: { type: 1, g: 0 }, callFunction: K.bind(null, 1) }, {
+				namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "boolean", j: [{ type: 46, g: 0 }], i: {
+					type: 0,
+					g: 0
+				}, callFunction: K.bind(null, 0)
+			}, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "decimal", j: [{ type: 46, g: 0 }], i: { type: 4, g: 0 }, callFunction: K.bind(null, 4) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "float", j: [{ type: 46, g: 0 }], i: { type: 6, g: 0 }, callFunction: K.bind(null, 6) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "double", j: [{ type: 46, g: 0 }], i: { type: 3, g: 0 }, callFunction: K.bind(null, 3) }, {
+				namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "duration", j: [{
+					type: 46,
+					g: 0
+				}], i: { type: 18, g: 0 }, callFunction: K.bind(null, 18)
+			}, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "dateTime", j: [{ type: 46, g: 0 }], i: { type: 9, g: 0 }, callFunction: K.bind(null, 9) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "dateTimeStamp", j: [{ type: 46, g: 0 }], i: { type: 10, g: 0 }, callFunction: K.bind(null, 10) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "time", j: [{ type: 46, g: 0 }], i: { type: 8, g: 0 }, callFunction: K.bind(null, 8) }, {
+				namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "date",
+				j: [{ type: 46, g: 0 }], i: { type: 7, g: 0 }, callFunction: K.bind(null, 7)
+			}, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "gYearMonth", j: [{ type: 46, g: 0 }], i: { type: 11, g: 0 }, callFunction: K.bind(null, 11) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "gYear", j: [{ type: 46, g: 0 }], i: { type: 12, g: 0 }, callFunction: K.bind(null, 12) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "gMonthDay", j: [{ type: 46, g: 0 }], i: { type: 13, g: 0 }, callFunction: K.bind(null, 13) }, {
+				namespaceURI: "http://www.w3.org/2001/XMLSchema",
+				localName: "gDay", j: [{ type: 46, g: 0 }], i: { type: 15, g: 0 }, callFunction: K.bind(null, 15)
+			}, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "gMonth", j: [{ type: 46, g: 0 }], i: { type: 14, g: 0 }, callFunction: K.bind(null, 14) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "hexBinary", j: [{ type: 46, g: 0 }], i: { type: 22, g: 0 }, callFunction: K.bind(null, 22) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "base64Binary", j: [{ type: 46, g: 0 }], i: { type: 21, g: 0 }, callFunction: K.bind(null, 21) }, {
+				namespaceURI: "http://www.w3.org/2001/XMLSchema",
+				localName: "QName", j: [{ type: 46, g: 0 }], i: { type: 23, g: 0 }, callFunction: function (a, b, c, d) {
+					if (d.G()) return d; a = d.first(); if (B(a.type, 2)) throw Error("XPTY0004: The provided QName is not a string-like value."); a = Pd(a, 1).value; a = ad(a, 23); if (!bd(a, 23)) throw Error("FORG0001: The provided QName is invalid."); if (!a.includes(":")) return c = c.aa(""), C.m(w(new zb("", c, a), 23)); d = p(a.split(":")); b = d.next().value; d = d.next().value; c = c.aa(b); if (!c) throw Error("FONS0004: The value " + a + " can not be cast to a QName. Did you mean to use fn:QName?");
+					return C.m(w(new zb(b, c, d), 23))
+				}
+			}, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "anyURI", j: [{ type: 46, g: 0 }], i: { type: 20, g: 0 }, callFunction: K.bind(null, 20) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "normalizedString", j: [{ type: 46, g: 0 }], i: { type: 48, g: 0 }, callFunction: K.bind(null, 48) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "token", j: [{ type: 46, g: 0 }], i: { type: 52, g: 0 }, callFunction: K.bind(null, 52) }, {
+				namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "language",
+				j: [{ type: 46, g: 0 }], i: { type: 51, g: 0 }, callFunction: K.bind(null, 51)
+			}, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "NMTOKEN", j: [{ type: 46, g: 0 }], i: { type: 50, g: 0 }, callFunction: K.bind(null, 50) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "NMTOKENS", j: [{ type: 46, g: 0 }], i: { type: 49, g: 2 }, callFunction: K.bind(null, 49) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "Name", j: [{ type: 46, g: 0 }], i: { type: 25, g: 0 }, callFunction: K.bind(null, 25) }, {
+				namespaceURI: "http://www.w3.org/2001/XMLSchema",
+				localName: "NCName", j: [{ type: 46, g: 0 }], i: { type: 24, g: 0 }, callFunction: K.bind(null, 24)
+			}, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "ID", j: [{ type: 46, g: 0 }], i: { type: 42, g: 0 }, callFunction: K.bind(null, 42) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "IDREF", j: [{ type: 46, g: 0 }], i: { type: 41, g: 0 }, callFunction: K.bind(null, 41) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "IDREFS", j: [{ type: 46, g: 0 }], i: { type: 43, g: 2 }, callFunction: K.bind(null, 43) }, {
+				namespaceURI: "http://www.w3.org/2001/XMLSchema",
+				localName: "ENTITY", j: [{ type: 46, g: 0 }], i: { type: 26, g: 0 }, callFunction: K.bind(null, 26)
+			}, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "ENTITIES", j: [{ type: 46, g: 0 }], i: { type: 40, g: 2 }, callFunction: K.bind(null, 40) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "integer", j: [{ type: 46, g: 0 }], i: { type: 5, g: 0 }, callFunction: K.bind(null, 5) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "nonPositiveInteger", j: [{ type: 46, g: 0 }], i: { type: 27, g: 0 }, callFunction: K.bind(null, 27) }, {
+				namespaceURI: "http://www.w3.org/2001/XMLSchema",
+				localName: "negativeInteger", j: [{ type: 46, g: 0 }], i: { type: 28, g: 0 }, callFunction: K.bind(null, 28)
+			}, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "long", j: [{ type: 46, g: 0 }], i: { type: 31, g: 0 }, callFunction: K.bind(null, 31) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "int", j: [{ type: 46, g: 0 }], i: { type: 32, g: 0 }, callFunction: K.bind(null, 32) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "short", j: [{ type: 46, g: 0 }], i: { type: 33, g: 0 }, callFunction: K.bind(null, 33) }, {
+				namespaceURI: "http://www.w3.org/2001/XMLSchema",
+				localName: "byte", j: [{ type: 46, g: 0 }], i: { type: 34, g: 0 }, callFunction: K.bind(null, 34)
+			}, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "nonNegativeInteger", j: [{ type: 46, g: 0 }], i: { type: 30, g: 0 }, callFunction: K.bind(null, 30) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "unsignedLong", j: [{ type: 46, g: 0 }], i: { type: 36, g: 0 }, callFunction: K.bind(null, 36) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "unsignedInt", j: [{ type: 46, g: 0 }], i: { type: 35, g: 0 }, callFunction: K.bind(null, 35) }, {
+				namespaceURI: "http://www.w3.org/2001/XMLSchema",
+				localName: "unsignedShort", j: [{ type: 46, g: 0 }], i: { type: 38, g: 0 }, callFunction: K.bind(null, 38)
+			}, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "unsignedByte", j: [{ type: 46, g: 0 }], i: { type: 37, g: 0 }, callFunction: K.bind(null, 37) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "positiveInteger", j: [{ type: 46, g: 0 }], i: { type: 29, g: 0 }, callFunction: K.bind(null, 29) }, {
+				namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "yearMonthDuration", j: [{ type: 46, g: 0 }], i: { type: 16, g: 0 }, callFunction: K.bind(null,
+					16)
+			}, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "dayTimeDuration", j: [{ type: 46, g: 0 }], i: { type: 17, g: 0 }, callFunction: K.bind(null, 17) }, { namespaceURI: "http://www.w3.org/2001/XMLSchema", localName: "dateTimeStamp", j: [{ type: 46, g: 0 }], i: { type: 10, g: 0 }, callFunction: K.bind(null, 10) }]; function Xf(a, b, c, d) { return d.G() ? d : C.m(w(d.first().value.getYear(), 5)) } function Yf(a, b, c, d) { return d.G() ? d : C.m(w(d.first().value.getMonth(), 5)) } function Zf(a, b, c, d) { return d.G() ? d : C.m(w(d.first().value.getDay(), 5)) } function $f(a, b, c, d) { return d.G() ? d : C.m(w(d.first().value.getHours(), 5)) } function ag(a, b, c, d) { return d.G() ? d : C.m(w(d.first().value.getMinutes(), 5)) } function bg(a, b, c, d) { d.G() || (a = C, b = a.m, d = d.first().value, d = b.call(a, w(d.B + d.sa, 4))); return d }
+			function cg(a, b, c, d) { return d.G() ? d : (a = d.first().value.Y) ? C.m(w(a, 17)) : C.empty() }
+			var dg = [{
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "dateTime", j: [{ type: 7, g: 0 }, { type: 8, g: 0 }], i: { type: 9, g: 0 }, callFunction: function (a, b, c, d, e) {
+					if (d.G()) return d; if (e.G()) return e; a = d.first().value; e = e.first().value; b = a.Y; c = e.Y; if (b || c) { if (!b || c) if (!b && c) b = c; else if (!fc(b, c)) throw Error("FORG0008: fn:dateTime: got a date and time value with different timezones."); } else b = null; return C.m(w(new rc(a.getYear(), a.getMonth(), a.getDay(), e.getHours(), e.getMinutes(), e.getSeconds(), e.sa,
+						b), 9))
+				}
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "year-from-dateTime", j: [{ type: 9, g: 0 }], i: { type: 5, g: 0 }, callFunction: Xf }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "month-from-dateTime", j: [{ type: 9, g: 0 }], i: { type: 5, g: 0 }, callFunction: Yf }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "day-from-dateTime", j: [{ type: 9, g: 0 }], i: { type: 5, g: 0 }, callFunction: Zf }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "hours-from-dateTime",
+				j: [{ type: 9, g: 0 }], i: { type: 5, g: 0 }, callFunction: $f
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "minutes-from-dateTime", j: [{ type: 9, g: 0 }], i: { type: 5, g: 0 }, callFunction: ag }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "seconds-from-dateTime", j: [{ type: 9, g: 0 }], i: { type: 4, g: 0 }, callFunction: bg }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "timezone-from-dateTime", j: [{ type: 9, g: 0 }], i: { type: 17, g: 0 }, callFunction: cg }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				localName: "year-from-date", j: [{ type: 7, g: 0 }], i: { type: 5, g: 0 }, callFunction: Xf
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "month-from-date", j: [{ type: 7, g: 0 }], i: { type: 5, g: 0 }, callFunction: Yf }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "day-from-date", j: [{ type: 7, g: 0 }], i: { type: 5, g: 0 }, callFunction: Zf }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "timezone-from-date", j: [{ type: 7, g: 0 }], i: { type: 17, g: 0 }, callFunction: cg }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				localName: "hours-from-time", j: [{ type: 8, g: 0 }], i: { type: 5, g: 0 }, callFunction: $f
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "minutes-from-time", j: [{ type: 8, g: 0 }], i: { type: 5, g: 0 }, callFunction: ag }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "seconds-from-time", j: [{ type: 8, g: 0 }], i: { type: 4, g: 0 }, callFunction: bg }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "timezone-from-time", j: [{ type: 8, g: 0 }], i: { type: 17, g: 0 }, callFunction: cg }]; function eg(a, b) {
+				var c = b.h, d = b.o, e = b.B; switch (a.node.nodeType) {
+					case 1: var f = d.createElementNS(a.node.namespaceURI, a.node.nodeName); c.getAllAttributes(a.node).forEach(function (g) { return e.setAttributeNS(f, g.namespaceURI, g.nodeName, g.value) }); d = p(Pb(c, a)); for (a = d.next(); !a.done; a = d.next())a = eg(a.value, b), e.insertBefore(f, a.node, null); return { node: f, F: null }; case 2: return b = d.createAttributeNS(a.node.namespaceURI, a.node.nodeName), b.value = Qb(c, a), { node: b, F: null }; case 4: return {
+						node: d.createCDATASection(Qb(c,
+							a)), F: null
+					}; case 8: return { node: d.createComment(Qb(c, a)), F: null }; case 9: d = d.createDocument(); c = p(Pb(c, a)); for (a = c.next(); !a.done; a = c.next())a = eg(a.value, b), e.insertBefore(d, a.node, null); return { node: d, F: null }; case 7: return { node: d.createProcessingInstruction(a.node.target, Qb(c, a)), F: null }; case 3: return { node: d.createTextNode(Qb(c, a)), F: null }
+				}
+			}; function fg(a, b) {
+				var c = b.B, d = b.o, e = b.h; if (Kb(a.node)) switch (a.node.nodeType) {
+					case 2: return d = d.createAttributeNS(a.node.namespaceURI, a.node.nodeName), d.value = Qb(e, a), d; case 8: return d.createComment(Qb(e, a)); case 1: var f = a.node.prefix, g = a.node.localName, k = d.createElementNS(a.node.namespaceURI, f ? f + ":" + g : g); Pb(e, a).forEach(function (l) { l = fg(l, b); c.insertBefore(k, l, null) }); Nb(e, a).forEach(function (l) { c.setAttributeNS(k, l.node.namespaceURI, l.node.nodeName, Qb(e, l)) }); k.normalize(); return k; case 7: return d.createProcessingInstruction(a.node.target,
+						Qb(e, a)); case 3: return d.createTextNode(Qb(e, a))
+				} else return eg(a, b).node
+			} function gg(a, b, c) { var d = a; for (a = Vb(c, d); null !== a;) { if (2 === d.node.nodeType) b.push(d.node.nodeName); else { var e = Pb(c, a); b.push(e.findIndex(function (f) { return Sd(f, d) })) } d = a; a = Vb(c, d) } return d } function hg(a, b, c) { for (var d = {}; 0 < b.length;)d.$a = b.pop(), "string" === typeof d.$a ? a = Nb(c, a).find(function (e) { return function (f) { return f.node.nodeName === e.$a } }(d)) : a = Pb(c, a)[d.$a], d = { $a: d.$a }; return a.node }
+			function ig(a, b, c) { var d = a.node; if (!(Kb(d) || c || a.F)) return d; d = b.da; var e = []; if (c) return fg(a, b); a = gg(a, e, b.h); c = d.get(a.node); c || (c = { node: fg(a, b), F: null }, d.set(a.node, c)); return hg(c, e, b.h) }; function jg(a, b, c, d, e) { return d.M(function (f) { for (var g = "", k = 0; k < f.length; k++) { var l = f[k], m = b.v && B(l.type, 53) ? b.v.serializeToString(ig(l.value, b, !1)) : Zc(C.m(l), b).map(function (q) { return Pd(q, 1) }).first().value; g += "{type: " + mb[l.type] + ", value: " + m + "}\n" } void 0 !== e && (g += e.first().value); b.s.trace(g); return C.create(f) }) }
+			var kg = [{ j: [{ type: 59, g: 2 }], callFunction: jg, localName: "trace", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } }, { j: [{ type: 59, g: 2 }, { type: 1, g: 3 }], callFunction: jg, localName: "trace", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } }]; function lg(a, b, c, d, e) { a = void 0 === d || d.G() ? new zb("err", "http://www.w3.org/2005/xqt-errors", "FOER0000") : d.first().value; b = ""; void 0 === e || e.G() || (b = ": " + e.first().value); throw Error("" + a.localName + b); }
+			var mg = [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "error", j: [], i: { type: 63, g: 3 }, callFunction: lg }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "error", j: [{ type: 23, g: 0 }], i: { type: 63, g: 3 }, callFunction: lg }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "error", j: [{ type: 23, g: 0 }, { type: 1, g: 3 }], i: { type: 63, g: 3 }, callFunction: lg }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "error", j: [{ type: 23, g: 0 }, { type: 1, g: 3 }, { type: 59, g: 2 }], i: {
+					type: 63,
+					g: 3
+				}, callFunction: function () { throw Error("Not implemented: Using an error object in error is not supported"); }
+			}]; function ng(a) { return "string" === typeof a ? a : (a = (new Gb).getChildNodes(a).find(function (b) { return 8 === b.nodeType })) ? a.data : "some expression" }; function og(a, b) { a = Error.call(this, a); this.message = a.message; "stack" in a && (this.stack = a.stack); this.position = { end: { ja: b.end.ja, line: b.end.line, offset: b.end.offset }, start: { ja: b.start.ja, line: b.start.line, offset: b.start.offset } } } v(og, Error); function pg(a, b) {
+				if (b instanceof Error) throw b; "string" !== typeof a && (a = ng(a)); var c = qg(b); a = a.replace("\r", "").split("\n"); var d = Math.floor(Math.log10(Math.min(c.end.line + 2, a.length))) + 1; a = a.reduce(function (e, f, g) {
+					var k = g + 1; if (2 < c.start.line - k || 2 < k - c.end.line) return e; g = Array(d).fill(" ", 0, Math.floor(Math.log10(k)) + 1 - d).join("") + k + ": "; e.push(g + f); if (k >= c.start.line && k <= c.end.line) {
+						var l = k < c.end.line ? f.length + g.length : c.end.ja - 1 + g.length; k = k > c.start.line ? g.length : c.start.ja - 1 + g.length; f = " ".repeat(g.length) +
+							Array.from(f.substring(0, k - g.length), function (m) { return "\t" === m ? "\t" : " " }).join("") + "^".repeat(l - k); e.push(f)
+					} return e
+				}, []); b = rg(b).join("\n"); throw new og(a.join("\n") + "\n\n" + b, c);
+			}; var sg = Object.create(null); function tg(a, b) { for (var c = [], d = 0; d < a.length + 1; ++d)c[d] = []; return function k(f, g) { if (0 === f) return g; if (0 === g) return f; if (void 0 !== c[f][g]) return c[f][g]; var l = 0; a[f - 1] !== b[g - 1] && (l = 1); l = Math.min(k(f - 1, g) + 1, k(f, g - 1) + 1, k(f - 1, g - 1) + l); return c[f][g] = l }(a.length, b.length) }
+			function ug(a) {
+				var b = sg[a] ? sg[a] : Object.keys(sg).map(function (c) { return { name: c, Ab: tg(a, c.slice(c.lastIndexOf(":") + 1)) } }).sort(function (c, d) { return c.Ab - d.Ab }).slice(0, 5).filter(function (c) { return c.Ab < a.length / 2 }).reduce(function (c, d) { return c.concat(sg[d.name]) }, []).slice(0, 5); return b.length ? b.map(function (c) { return '"Q{' + c.namespaceURI + "}" + c.localName + " (" + c.j.map(function (d) { return 4 === d ? "..." : ob(d) }).join(", ") + ')"' }).reduce(function (c, d, e, f) { return 0 === e ? c + d : c + ((e !== f.length - 1 ? ", " : " or ") + d) },
+					"Did you mean ") + "?" : "No similar functions found."
+			} function vg(a, b, c) { var d = sg[a + ":" + b]; return d ? (d = d.find(function (e) { return e.j.some(function (f) { return 4 === f }) ? e.j.length - 1 <= c : e.j.length === c })) ? { j: d.j, arity: c, callFunction: d.callFunction, I: d.I, localName: b, namespaceURI: a, i: d.i } : null : null } function wg(a, b, c, d, e) { sg[a + ":" + b] || (sg[a + ":" + b] = []); sg[a + ":" + b].push({ j: c, arity: c.length, callFunction: e, I: !1, localName: b, namespaceURI: a, i: d }) }; var xg = {}, yg = (xg.xml = "http://www.w3.org/XML/1998/namespace", xg.xs = "http://www.w3.org/2001/XMLSchema", xg.fn = "http://www.w3.org/2005/xpath-functions", xg.map = "http://www.w3.org/2005/xpath-functions/map", xg.array = "http://www.w3.org/2005/xpath-functions/array", xg.math = "http://www.w3.org/2005/xpath-functions/math", xg.fontoxpath = "http://fontoxml.com/fontoxpath", xg.local = "http://www.w3.org/2005/xquery-local-functions", xg); function zg(a, b, c, d) { this.Ha = [Object.create(null)]; this.Ia = Object.create(null); this.s = a; this.da = Object.keys(b).reduce(function (e, f) { if (void 0 === b[f]) return e; e[f] = "Q{}" + f + "[0]"; return e }, Object.create(null)); this.o = Object.create(null); this.h = Object.create(null); this.v = c; this.l = d; this.B = [] } zg.prototype.xa = function (a, b, c) { return vg(a, b, c) }; zg.prototype.ib = function (a, b) { if (a) return null; a = this.da[b]; this.o[b] || (this.o[b] = { name: b }); return a };
+			zg.prototype.Ua = function (a, b) { var c = this.l(a, b); if (c) this.B.push({ nc: a, arity: b, Lb: c }); else if ("" === a.prefix) { if (this.v) return { namespaceURI: this.v, localName: a.localName } } else if (b = this.aa(a.prefix, !0)) return { namespaceURI: b, localName: a.localName }; return c }; zg.prototype.aa = function (a, b) { if (void 0 !== b && !b) return null; if (yg[a]) return yg[a]; b = this.s(a); this.h[a] || (this.h[a] = { namespaceURI: b, prefix: a }); return void 0 !== b || a ? b : null }; function Ag(a) { return Error("XPTY0004: " + a) } function Bg(a, b) { a = 2 === a.node.nodeType ? a.node.nodeName + '="' + Qb(b, a) + '"' : a.node.outerHTML; return Error("XQTY0024: The node " + a + " follows a node that is not an attribute node or a namespace node.") } function Cg(a) { return Error('XQDY0044: The node name "' + a.Ca() + '" is invalid for a computed attribute constructor.') } function Dg() { return Error("XQST0045: Functions and variables may not be declared in one of the reserved namespace URIs.") }
+			function Eg() { return Error("XQST0060: Functions declared in a module or as an external function must reside in a namespace.") } function Fg() { return Error("XQST0066: A Prolog may contain at most one default function namespace declaration.") } function Gg() { return Error("XQST0070: The prefixes xml and xmlns may not be used in a namespace declaration or be bound to another namespaceURI.") }
+			function Hg(a) { return Error('XQDY0074: The value "' + a + '" of a name expressions cannot be converted to an expanded QName.') } function Ig(a) { return Error('XPST0081: The prefix "' + a + '" could not be resolved') }; function Jg(a, b) { return "Q{" + (a || "") + "}" + b } function Kg(a, b) { for (var c = a.length - 1; 0 <= c; --c)if (b in a[c]) return a[c][b] } function Lg(a) { this.o = a; this.s = this.h = 0; this.B = [Object.create(null)]; this.l = Object.create(null); this.v = null; this.Ia = a && a.Ia; this.Ha = a && a.Ha } function Of(a) { for (var b = new Lg(a.o), c = 0; c < a.h + 1; ++c)b.B = [Object.assign(Object.create(null), b.B[0], a.B[c])], b.Ha = [Object.assign(Object.create(null), b.Ha[0], a.Ha[c])], b.l = Object.assign(Object.create(null), a.l), b.Ia = a.Ia, b.v = a.v; return b }
+			function Mg(a) { a.s++; a.h++; a.B[a.h] = Object.create(null); a.Ha[a.h] = Object.create(null) } Lg.prototype.xa = function (a, b, c, d) { d = void 0 === d ? !1 : d; var e = this.l[Jg(a, b) + "~" + c]; return !e || d && e.Eb ? null === this.o ? null : this.o.xa(a, b, c, d) : e }; Lg.prototype.ib = function (a, b) { var c = Kg(this.Ha, Jg(a, b)); return c ? c : null === this.o ? null : this.o.ib(a, b) }; function Ng(a, b, c) { return (a = a.Ia[Jg(b, c)]) ? a : null }
+			function Og(a, b, c, d, e) { d = Jg(b, c) + "~" + d; if (a.l[d]) throw Error('XQST0049: The function or variable "Q{' + b + "}" + c + '" is declared more than once.'); a.l[d] = e } function Pg(a, b, c) { a.B[a.h][b] = c } function Qg(a, b, c) { b = Jg(b || "", c); return a.Ha[a.h][b] = b + "[" + a.s + "]" } function Rg(a, b, c, d) { a.Ia[Jg(b || "", c) + "[" + a.s + "]"] = d } function Sg(a) { a.B.length = a.h; a.Ha.length = a.h; a.h-- }
+			Lg.prototype.Ua = function (a, b) { var c = a.prefix, d = a.localName; return "" === c && this.v ? { localName: d, namespaceURI: this.v } : c && (c = this.aa(c, !1)) ? { localName: d, namespaceURI: c } : null === this.o ? null : this.o.Ua(a, b) }; Lg.prototype.aa = function (a, b) { var c = Kg(this.B, a || ""); return void 0 === c ? null === this.o ? void 0 : this.o.aa(a || "", void 0 === b ? !0 : b) : c }; function L(a, b) { "*" === b || Array.isArray(b) || (b = [b]); for (var c = 1; c < a.length; ++c)if (Array.isArray(a[c])) { var d = a[c]; if ("*" === b || b.includes(d[0])) return d } return null } function Tg(a) { return 2 > a.length ? "" : "object" === typeof a[1] ? a[2] || "" : a[1] || "" } function M(a, b) { if (!Array.isArray(a)) return null; a = a[1]; return "object" !== typeof a || Array.isArray(a) ? null : b in a ? a[b] : null } function N(a, b) { return b.reduce(L, a) }
+			function O(a, b) { for (var c = [], d = 1; d < a.length; ++d)if (Array.isArray(a[d])) { var e = a[d]; "*" !== b && e[0] !== b || c.push(e) } return c } function Ug(a) { return { localName: Tg(a), namespaceURI: M(a, "URI"), prefix: M(a, "prefix") } }
+			function Vg(a) {
+				function b(f) {
+					switch (f[0]) {
+						case "documentTest": return 55; case "elementTest": return 54; case "attributeTest": return 47; case "piTest": return 57; case "commentTest": return 58; case "textTest": return 56; case "anyKindTest": return 53; case "anyItemType": return 59; case "anyFunctionTest": case "functionTest": case "typedFunctionTest": return 60; case "anyMapTest": case "typedMapTest": return 61; case "anyArrayTest": case "typedArrayTest": return 62; case "atomicType": return pb([M(f, "prefix"), Tg(f)].join(":"));
+						case "parenthesizedItemType": return b(L(f, "*")); default: throw Error('Type declaration "' + L(c, "*")[0] + '" is not supported.');
+					}
+				} var c = L(a, "typeDeclaration"); if (!c || L(c, "voidSequenceType")) return { type: 59, g: 2 }; a = { type: b(L(c, "*")), g: 3 }; var d = null, e = L(c, "occurrenceIndicator"); e && (d = Tg(e)); switch (d) { case "*": return a.g = 2, a; case "?": return a.g = 0, a; case "+": return a.g = 1, a; case "": case null: return a }
+			}
+			function P(a, b, c) { if ("object" !== typeof a[1] || Array.isArray(a[1])) { var d = {}; d[b] = c; a.splice(1, 0, d) } else a[1][b] = c }; function Wg(a) { var b = { type: 62, g: 3 }; P(a, "type", b); return b }; function Xg(a, b) { if (!b || !b.ia) return { type: 59, g: 2 }; var c = L(a, "EQName"); if (!c) return { type: 59, g: 2 }; var d = Ug(c); c = d.localName; var e = d.prefix; d = O(L(a, "arguments"), "*"); c = b.ia.Ua({ localName: c, prefix: e }, d.length); if (!c) return { type: 59, g: 2 }; b = b.ia.xa(c.namespaceURI, c.localName, d.length + 1); if (!b) return { type: 59, g: 2 }; 59 !== b.i.type && P(a, "type", b.i); return b.i }; function Q(a, b, c) { return (a << 20) + (b << 12) + (c.charCodeAt(0) << 8) + c.charCodeAt(1) }
+			var Yg = {}, Zg = (Yg[Q(2, 2, "idivOp")] = 5, Yg[Q(16, 16, "addOp")] = 16, Yg[Q(16, 16, "subtractOp")] = 16, Yg[Q(16, 16, "divOp")] = 4, Yg[Q(16, 2, "multiplyOp")] = 16, Yg[Q(16, 2, "divOp")] = 16, Yg[Q(2, 16, "multiplyOp")] = 16, Yg[Q(17, 17, "addOp")] = 17, Yg[Q(17, 17, "subtractOp")] = 17, Yg[Q(17, 17, "divOp")] = 4, Yg[Q(17, 2, "multiplyOp")] = 17, Yg[Q(17, 2, "divOp")] = 17, Yg[Q(2, 17, "multiplyOp")] = 17, Yg[Q(9, 9, "subtractOp")] = 17, Yg[Q(7, 7, "subtractOp")] = 17, Yg[Q(8, 8, "subtractOp")] = 17, Yg[Q(9, 16, "addOp")] = 9, Yg[Q(9, 16, "subtractOp")] = 9, Yg[Q(9, 17, "addOp")] = 9, Yg[Q(9,
+				17, "subtractOp")] = 9, Yg[Q(7, 16, "addOp")] = 7, Yg[Q(7, 16, "subtractOp")] = 7, Yg[Q(7, 17, "addOp")] = 7, Yg[Q(7, 17, "subtractOp")] = 7, Yg[Q(8, 17, "addOp")] = 8, Yg[Q(8, 17, "subtractOp")] = 8, Yg[Q(9, 16, "addOp")] = 9, Yg[Q(9, 16, "subtractOp")] = 9, Yg[Q(9, 17, "addOp")] = 9, Yg[Q(9, 17, "subtractOp")] = 9, Yg[Q(7, 17, "addOp")] = 7, Yg[Q(7, 17, "subtractOp")] = 7, Yg[Q(7, 16, "addOp")] = 7, Yg[Q(7, 16, "subtractOp")] = 7, Yg[Q(8, 17, "addOp")] = 8, Yg[Q(8, 17, "subtractOp")] = 8, Yg), $g = {}, ah = ($g[Q(2, 2, "addOp")] = function (a, b) { return a + b }, $g[Q(2, 2, "subtractOp")] = function (a,
+					b) { return a - b }, $g[Q(2, 2, "multiplyOp")] = function (a, b) { return a * b }, $g[Q(2, 2, "divOp")] = function (a, b) { return a / b }, $g[Q(2, 2, "modOp")] = function (a, b) { return a % b }, $g[Q(2, 2, "idivOp")] = function (a, b) { return Math.trunc(a / b) }, $g[Q(16, 16, "addOp")] = function (a, b) { return new od(a.ga + b.ga) }, $g[Q(16, 16, "subtractOp")] = function (a, b) { return new od(a.ga - b.ga) }, $g[Q(16, 16, "divOp")] = function (a, b) { return a.ga / b.ga }, $g[Q(16, 2, "multiplyOp")] = rd, $g[Q(16, 2, "divOp")] = function (a, b) {
+						if (isNaN(b)) throw Error("FOCA0005: Cannot divide xs:yearMonthDuration by NaN");
+						a = Math.round(a.ga / b); if (a > Number.MAX_SAFE_INTEGER || !Number.isFinite(a)) throw Error("FODT0002: Value overflow while dividing xs:yearMonthDuration"); return new od(a < Number.MIN_SAFE_INTEGER || 0 === a ? 0 : a)
+					}, $g[Q(2, 16, "multiplyOp")] = function (a, b) { return rd(b, a) }, $g[Q(17, 17, "addOp")] = function (a, b) { return new gc(a.ea + b.ea) }, $g[Q(17, 17, "subtractOp")] = function (a, b) { return new gc(a.ea - b.ea) }, $g[Q(17, 17, "divOp")] = function (a, b) { if (0 === b.ea) throw Error("FOAR0001: Division by 0"); return a.ea / b.ea }, $g[Q(17, 2, "multiplyOp")] =
+					lc, $g[Q(17, 2, "divOp")] = function (a, b) { if (isNaN(b)) throw Error("FOCA0005: Cannot divide xs:dayTimeDuration by NaN"); a = a.ea / b; if (a > Number.MAX_SAFE_INTEGER || !Number.isFinite(a)) throw Error("FODT0002: Value overflow while dividing xs:dayTimeDuration"); return new gc(a < Number.MIN_SAFE_INTEGER || Object.is(-0, a) ? 0 : a) }, $g[Q(2, 17, "multiplyOp")] = function (a, b) { return lc(b, a) }, $g[Q(9, 9, "subtractOp")] = xc, $g[Q(7, 7, "subtractOp")] = xc, $g[Q(8, 8, "subtractOp")] = xc, $g[Q(9, 16, "addOp")] = yc, $g[Q(9, 16, "subtractOp")] = zc, $g[Q(9,
+						17, "addOp")] = yc, $g[Q(9, 17, "subtractOp")] = zc, $g[Q(7, 16, "addOp")] = yc, $g[Q(7, 16, "subtractOp")] = zc, $g[Q(7, 17, "addOp")] = yc, $g[Q(7, 17, "subtractOp")] = zc, $g[Q(8, 17, "addOp")] = yc, $g[Q(8, 17, "subtractOp")] = zc, $g[Q(9, 16, "addOp")] = yc, $g[Q(9, 16, "subtractOp")] = zc, $g[Q(9, 17, "addOp")] = yc, $g[Q(9, 17, "subtractOp")] = zc, $g[Q(7, 17, "addOp")] = yc, $g[Q(7, 17, "subtractOp")] = zc, $g[Q(7, 16, "addOp")] = yc, $g[Q(7, 16, "subtractOp")] = zc, $g[Q(8, 17, "addOp")] = yc, $g[Q(8, 17, "subtractOp")] = zc, $g); function bh(a, b) { return B(a, 5) && B(b, 5) ? 5 : B(a, 4) && B(b, 4) ? 4 : B(a, 6) && B(b, 6) ? 6 : 3 } var ch = [2, 16, 17, 9, 7, 8];
+			function dh(a, b, c) {
+				function d(D, F) { return { U: e ? e(D) : D, V: f ? f(F) : F } } var e = null, f = null; B(b, 19) && (e = function (D) { return Pd(D, 3) }, b = 3); B(c, 19) && (f = function (D) { return Pd(D, 3) }, c = 3); var g = ch.filter(function (D) { return B(b, D) }), k = ch.filter(function (D) { return B(c, D) }); if (g.includes(2) && k.includes(2)) { var l = ah[Q(2, 2, a)], m = Zg[Q(2, 2, a)]; m || (m = bh(b, c)); "divOp" === a && 5 === m && (m = 4); return "idivOp" === a ? eh(d, l)[0] : function (D, F) { D = d(D, F); return w(l(D.U.value, D.V.value), m) } } g = p(g); for (var q = g.next(); !q.done; q = g.next()) {
+					q =
+					q.value; for (var u = {}, z = p(k), A = z.next(); !A.done; u = { nb: u.nb, qb: u.qb }, A = z.next())if (A = A.value, u.nb = ah[Q(q, A, a)], u.qb = Zg[Q(q, A, a)], u.nb && void 0 !== u.qb) return function (D) { return function (F, J) { F = d(F, J); return w(D.nb(F.U.value, F.V.value), D.qb) } }(u)
+				}
+			}
+			function fh(a, b, c) {
+				function d(u, z) { return { U: f ? f(u) : u, V: g ? g(z) : z } } var e = [2, 53, 59, 46, 47]; if (e.includes(b) || e.includes(c)) return 2; var f = null, g = null; B(b, 19) && (f = function (u) { return Pd(u, 3) }, b = 3); B(c, 19) && (g = function (u) { return Pd(u, 3) }, c = 3); var k = ch.filter(function (u) { return B(b, u) }); e = ch.filter(function (u) { return B(c, u) }); if (k.includes(2) && e.includes(2)) return e = Zg[Q(2, 2, a)], void 0 === e && (e = bh(b, c)), "divOp" === a && 5 === e && (e = 4), "idivOp" === a ? eh(d, function (u, z) { return Math.trunc(u / z) })[1] : e; k = p(k); for (var l =
+					k.next(); !l.done; l = k.next()) { l = l.value; for (var m = p(e), q = m.next(); !q.done; q = m.next())if (q = Zg[Q(l, q.value, a)], void 0 !== q) return q }
+			}
+			function eh(a, b) { return [function (c, d) { d = a(c, d); c = d.U; d = d.V; if (0 === d.value) throw Error("FOAR0001: Divisor of idiv operator cannot be (-)0"); if (Number.isNaN(c.value) || Number.isNaN(d.value) || !Number.isFinite(c.value)) throw Error("FOAR0002: One of the operands of idiv is NaN or the first operand is (-)INF"); return Number.isFinite(c.value) && !Number.isFinite(d.value) ? w(0, 5) : w(b(c.value, d.value), 5) }, 5] } var gh = Object.create(null);
+			function mh(a, b, c, d, e) { H.call(this, b.o.add(c.o), [b, c], { C: !1 }, !1, d); this.A = b; this.K = c; this.l = a; this.s = e } v(mh, H);
+			mh.prototype.h = function (a, b) {
+				var c = this; return Zc(I(this.A, a, b), b).M(function (d) {
+					return 0 === d.length ? C.empty() : Zc(I(c.K, a, b), b).M(function (e) {
+						if (0 === e.length) return C.empty(); if (1 < d.length || 1 < e.length) throw Error('XPTY0004: the operands of the "' + c.l + '" operator should be empty or singleton.'); var f = d[0]; e = e[0]; if (c.s && c.type) return C.m(c.s(f, e)); var g = f.type; var k = e.type, l = c.l, m = g + "~" + k + "~" + l, q = gh[m]; q || (q = gh[m] = dh(l, g, k)); g = q; if (!g) throw Error("XPTY0004: " + c.l + " not available for types " + mb[f.type] +
+							" and " + mb[e.type]); return C.m(g(f, e))
+					})
+				})
+			}; function nh(a, b) {
+				for (var c = oh, d = !1, e = 1; e < a.length; e++)switch (a[e][0]) {
+					case "letClause": ph(b); var f = a[e], g = b, k = c, l = N(f, ["letClauseItem", "typedVariableBinding", "varName"]); l = Ug(l); f = N(f, ["letClauseItem", "letExpr"]); k = k(f[1], g); qh(g, l.localName, k); break; case "forClause": d = !0; ph(b); rh(a[e], b, c); break; case "whereClause": ph(b); g = a[e]; c(g, b); P(g, "type", { type: 0, g: 3 }); break; case "orderByClause": ph(b); break; case "returnClause": e = a[e]; g = c; c = N(e, ["*"]); b = g(c, b); P(c, "type", b); P(e, "type", b); c = b; if (!c) return {
+						type: 59,
+						g: 2
+					}; d && (c = { type: c.type, g: 2 }); 59 !== c.type && P(a, "type", c); return c; default: c = c(a[e], b); if (!c) return { type: 59, g: 2 }; d && (c = { type: c.type, g: 2 }); 59 !== c.type && P(a, "type", c); return c
+				}if (0 < b.h) b.h--, b.o.pop(), b.v.pop(); else throw Error("Variable scope out of bound");
+			}
+			function rh(a, b, c) { var d = Ug(N(a, ["forClauseItem", "typedVariableBinding", "varName"])); if (a = N(a, ["forClauseItem", "forExpr", "sequenceExpr"])) a = O(a, "*").map(function (e) { return c(e, b) }), a.includes(void 0) || a.includes(null) || (a = sh(a), 1 === a.length && qh(b, d.localName, a[0])) } function sh(a) { return a.filter(function (b, c, d) { return d.findIndex(function (e) { return e.type === b.type && e.g === b.g }) === c }) }; function th(a, b) { if (!b || !b.ia) return { type: 59, g: 2 }; var c = L(a, "functionName"), d = Ug(c), e = d.localName, f = d.prefix, g = d.namespaceURI; d = O(L(a, "arguments"), "*"); if (null === g) { f = b.ia.Ua({ localName: e, prefix: f }, d.length); if (!f) return { type: 59, g: 2 }; e = f.localName; g = f.namespaceURI; P(c, "URI", g); c[2] = e } b = b.ia.xa(g, e, d.length); if (!b || 63 === b.i.type) return { type: 59, g: 2 }; 59 !== b.i.type && P(a, "type", b.i); return b.i }; function uh(a) { var b = { type: 61, g: 3 }; P(a, "type", b); return b }; function vh(a, b) { if (!b || !b.ia) return { type: 59, g: 2 }; var c = L(a, "functionName"), d = Ug(c), e = d.localName, f = d.namespaceURI, g = d.prefix; d = Number(N(a, ["integerConstantExpr", "value"])[1]); if (!f) { f = b.ia.Ua({ localName: e, prefix: g }, d); if (!f) return { type: 59, g: 2 }; e = f.localName; f = f.namespaceURI; P(c, "URI", f) } b = b.ia.xa(f, e, d) || null; if (!b) return { type: 59, g: 2 }; 59 !== b.i.type && 63 !== b.i.type && P(a, "type", b.i); return b.i }; function wh(a, b) {
+				var c = O(a, "stepExpr"); if (!c) return { type: 59, g: 2 }; c = p(c); for (var d = c.next(); !d.done; d = c.next()) {
+					var e = d.value; d = b; var f = null; if (e) {
+						var g = O(e, "*"), k = ""; g = p(g); for (var l = g.next(); !l.done; l = g.next())switch (l = l.value, l[0]) {
+							case "filterExpr": f = M(N(l, ["*"]), "type"); break; case "xpathAxis": k = l[1]; b: {
+								switch (k) {
+									case "attribute": f = { type: 47, g: 2 }; break b; case "child": case "decendant": case "self": case "descendant-or-self": case "following-sibling": case "following": case "namespace": case "parent": case "ancestor": case "preceding-sibling": case "preceding": case "ancestor-or-self": f =
+										{ type: 53, g: 2 }; break b
+								}f = void 0
+							} break; case "nameTest": var m = Ug(l); if (null !== m.namespaceURI) break; if ("attribute" === k && !m.prefix) break; m = d.aa(m.prefix || ""); void 0 !== m && P(l, "URI", m); break; case "lookup": f = { type: 59, g: 2 }
+						}f && 59 !== f.type && P(e, "type", f)
+					} e = M(e, "type")
+				} e && 59 !== e.type && P(a, "type", e); return e
+			}; function xh(a) { var b = { type: 0, g: 3 }; P(a, "type", b); return b }; function yh(a, b, c) { 0 === b ? b = { type: 53, g: 2 } : 1 === b ? b = c[0] : c.includes(void 0) || c.includes(null) ? b = { type: 59, g: 2 } : (b = sh(c), b = 1 < b.length ? { type: 59, g: 2 } : { type: b[0].type, g: 2 }); b && 59 !== b.type && P(a, "type", b); return b }; function zh(a, b, c, d) { if (!b || c.includes(void 0)) return { type: 59, g: 2 }; for (var e = O(a, "typeswitchExprCaseClause"), f = 0; f < c.length; f++) { var g = L(e[f], "*"); switch (g[0]) { case "sequenceType": if (g = Ah(g, b, c[f])) return 59 !== g.type && P(a, "type", g), g; continue; case "sequenceTypeUnion": for (d = O(g, "*"), e = 0; 2 > e; e++)if (g = Ah(d[e], b, c[f])) return 59 !== g.type && P(a, "type", g), g; default: return { type: 59, g: 2 } } } 59 !== d.type && P(a, "type", d); return d }
+			function Ah(a, b, c) { var d = O(a, "*"), e = L(a, "atomicType"); if (!e) return { type: 59, g: 2 }; if (pb(M(e, "prefix") + ":" + e[2]) === b.type) if (1 === d.length) { if (3 === b.g) return c } else if (a = L(a, "occurrenceIndicator")[1], b.g === rb(a)) return c }; function Bh(a, b) { oh(a, b) } function oh(a, b) { var c = Ch.get(a[0]); if (c) return c(a, b); for (c = 1; c < a.length; c++)a[c] && oh(a[c], b) } function Dh(a, b) { var c = oh(L(a, "firstOperand")[1], b), d = oh(L(a, "secondOperand")[1], b); var e = a[0]; if (c && d) if (b = fh(e, c.type, d.type)) c = { type: b, g: c.g }, 2 !== b && 59 !== b && P(a, "type", c), a = c; else throw Error("XPTY0004: " + e + " not available for types " + ob(c) + " and " + ob(d)); else a = { type: 2, g: 3 }; return a }
+			function Eh(a, b) { oh(L(a, "firstOperand")[1], b); oh(L(a, "secondOperand")[1], b); a: { switch (a[0]) { case "orOp": b = { type: 0, g: 3 }; P(a, "type", b); a = b; break a; case "andOp": b = { type: 0, g: 3 }; P(a, "type", b); a = b; break a }a = void 0 } return a }
+			function Fh(a, b) { oh(L(a, "firstOperand")[1], b); oh(L(a, "secondOperand")[1], b); a: { switch (a[0]) { case "unionOp": b = { type: 53, g: 2 }; P(a, "type", b); a = b; break a; case "intersectOp": b = { type: 53, g: 2 }; P(a, "type", b); a = b; break a; case "exceptOp": b = { type: 53, g: 2 }; P(a, "type", b); a = b; break a }a = void 0 } return a } function Gh(a, b) { oh(L(a, "firstOperand")[1], b); oh(L(a, "secondOperand")[1], b); b = { type: 0, g: 3 }; P(a, "type", b); return b }
+			function Hh(a, b) { oh(L(a, "firstOperand")[1], b); oh(L(a, "secondOperand")[1], b); b = M(N(a, ["firstOperand", "*"]), "type"); var c = M(N(a, ["secondOperand", "*"]), "type"); b = { type: 0, g: ed(b) || ed(c) ? 0 : 3 }; P(a, "type", b); return b } function Ih(a, b) { oh(L(a, "firstOperand")[1], b); oh(L(a, "secondOperand")[1], b); b = M(N(a, ["firstOperand", "*"]), "type"); var c = M(N(a, ["secondOperand", "*"]), "type"); b = { type: 0, g: ed(b) || ed(c) ? 0 : 3 }; P(a, "type", b); return b }
+			var Ch = new Map([["unaryMinusOp", function (a, b) { b = oh(L(a, "operand")[1], b); b ? B(b.type, 2) ? (b = { type: b.type, g: b.g }, P(a, "type", b), a = b) : (b = { type: 3, g: 3 }, P(a, "type", b), a = b) : (b = { type: 2, g: 2 }, P(a, "type", b), a = b); return a }], ["unaryPlusOp", function (a, b) { b = oh(L(a, "operand")[1], b); b ? B(b.type, 2) ? (b = { type: b.type, g: b.g }, P(a, "type", b), a = b) : (b = { type: 3, g: 3 }, P(a, "type", b), a = b) : (b = { type: 2, g: 2 }, P(a, "type", b), a = b); return a }], ["addOp", Dh], ["subtractOp", Dh], ["divOp", Dh], ["idivOp", Dh], ["modOp", Dh], ["multiplyOp", Dh], ["andOp", Eh],
+			["orOp", Eh], ["sequenceExpr", function (a, b) { var c = O(a, "*"), d = c.map(function (e) { return oh(e, b) }); return yh(a, c.length, d) }], ["unionOp", Fh], ["intersectOp", Fh], ["exceptOp", Fh], ["stringConcatenateOp", function (a, b) { oh(L(a, "firstOperand")[1], b); oh(L(a, "secondOperand")[1], b); b = { type: 1, g: 3 }; P(a, "type", b); return b }], ["rangeSequenceExpr", function (a, b) { oh(L(a, "startExpr")[1], b); oh(L(a, "endExpr")[1], b); b = { type: 5, g: 1 }; P(a, "type", b); return b }], ["equalOp", Gh], ["notEqualOp", Gh], ["lessThanOrEqualOp", Gh], ["lessThanOp",
+				Gh], ["greaterThanOrEqualOp", Gh], ["greaterThanOp", Gh], ["eqOp", Hh], ["neOp", Hh], ["ltOp", Hh], ["leOp", Hh], ["gtOp", Hh], ["geOp", Hh], ["isOp", Ih], ["nodeBeforeOp", Ih], ["nodeAfterOp", Ih], ["pathExpr", function (a, b) { var c = L(a, "rootExpr"); c && c[1] && oh(c[1], b); O(a, "stepExpr").map(function (d) { return oh(d, b) }); return wh(a, b) }], ["contextItemExpr", function () { return { type: 59, g: 2 } }], ["ifThenElseExpr", function (a, b) {
+					oh(L(L(a, "ifClause"), "*"), b); var c = oh(L(L(a, "thenClause"), "*"), b); b = oh(L(L(a, "elseClause"), "*"), b); c && b ? c.type ===
+						b.type && c.g === b.g ? (59 !== c.type && P(a, "type", c), a = c) : a = { type: 59, g: 2 } : a = { type: 59, g: 2 }; return a
+				}], ["instanceOfExpr", function (a, b) { oh(L(a, "argExpr"), b); oh(L(a, "sequenceType"), b); b = { type: 0, g: 3 }; P(a, "type", b); return b }], ["integerConstantExpr", function (a) { var b = { type: 5, g: 3 }; P(a, "type", b); return b }], ["doubleConstantExpr", function (a) { var b = { type: 3, g: 3 }; P(a, "type", b); return b }], ["decimalConstantExpr", function (a) { var b = { type: 4, g: 3 }; P(a, "type", b); return b }], ["stringConstantExpr", function (a) {
+					var b = { type: 1, g: 3 };
+					P(a, "type", b); return b
+				}], ["functionCallExpr", function (a, b) { var c = L(a, "arguments"); O(c, "*").map(function (d) { return oh(d, b) }); return th(a, b) }], ["arrowExpr", function (a, b) { oh(L(a, "argExpr")[1], b); return Xg(a, b) }], ["dynamicFunctionInvocationExpr", function (a, b) { oh(N(a, ["functionItem", "*"]), b); (a = L(a, "arguments")) && oh(a, b); return { type: 59, g: 2 } }], ["namedFunctionRef", function (a, b) { return vh(a, b) }], ["inlineFunctionExpr", function (a, b) { oh(L(a, "functionBody")[1], b); b = { type: 60, g: 3 }; P(a, "type", b); return b }], ["castExpr",
+				function (a) { var b = N(a, ["singleType", "atomicType"]); b = { type: pb(M(b, "prefix") + ":" + b[2]), g: 3 }; 59 !== b.type && P(a, "type", b); return b }], ["castableExpr", function (a) { var b = { type: 0, g: 3 }; P(a, "type", b); return b }], ["simpleMapExpr", function (a, b) { for (var c = O(a, "pathExpr"), d, e = 0; e < c.length; e++)d = oh(c[e], b); void 0 !== d && null !== d ? ((b = { type: d.type, g: 2 }, 59 !== b.type) && P(a, "type", b), a = b) : a = { type: 59, g: 2 }; return a }], ["mapConstructor", function (a, b) {
+					O(a, "mapConstructorEntry").map(function (c) {
+						return {
+							key: oh(N(c, ["mapKeyExpr",
+								"*"]), b), value: oh(N(c, ["mapValueExpr", "*"]), b)
+						}
+					}); return uh(a)
+				}], ["arrayConstructor", function (a, b) { O(L(a, "*"), "arrayElem").map(function (c) { return oh(c, b) }); return Wg(a) }], ["unaryLookup", function (a) { L(a, "NCName"); return { type: 59, g: 2 } }], ["typeswitchExpr", function (a, b) { var c = oh(L(a, "argExpr")[1], b), d = O(a, "typeswitchExprCaseClause").map(function (f) { return oh(N(f, ["resultExpr"])[1], b) }), e = oh(N(a, ["typeswitchExprDefaultClause", "resultExpr"])[1], b); return zh(a, c, d, e) }], ["quantifiedExpr", function (a, b) {
+					O(a,
+						"*").map(function (c) { return oh(c, b) }); return xh(a)
+				}], ["x:stackTrace", function (a, b) { a = O(a, "*"); return oh(a[0], b) }], ["queryBody", function (a, b) { return oh(a[1], b) }], ["flworExpr", function (a, b) { return nh(a, b) }], ["varRef", function (a, b) { var c = Ug(L(a, "name")), d; a: { for (d = b.h; 0 <= d; d--) { var e = b.o[d][c.localName]; if (e) { d = e; break a } } d = void 0 } d && 59 !== d.type && P(a, "type", d); null === c.namespaceURI && (b = b.aa(c.prefix), void 0 !== b && P(a, "URI", b)); return d }]]); function Jh(a) { this.h = 0; this.ia = a; this.o = [{}]; this.v = [{}] } function qh(a, b, c) { if (a.o[a.h][b]) throw Error("Another variable of in the scope " + a.h + " with the same name " + b + " already exists"); a.o[a.h][b] = c } function ph(a) { a.h++; a.o.push({}); a.v.push({}) } Jh.prototype.aa = function (a) { for (var b = this.h; 0 <= b; b--) { var c = this.v[b][a]; if (void 0 !== c) return c } return this.ia ? this.ia.aa(a) : void 0 }; function Kh(a, b) { var c = {}; H.call(this, new Hf((c.external = 1, c)), a, { C: a.every(function (d) { return d.C }) }, !1, b); this.l = a } v(Kh, H); Kh.prototype.h = function (a, b) { return 0 === this.l.length ? C.m(new Yb([])) : I(this.l[0], a, b).M(function (c) { return C.m(new Yb(c.map(function (d) { return yb(C.m(d)) }))) }) }; function Lh(a, b) { var c = {}; H.call(this, new Hf((c.external = 1, c)), a, { C: a.every(function (d) { return d.C }) }, !1, b); this.l = a } v(Lh, H); Lh.prototype.h = function (a, b) { return C.m(new Yb(this.l.map(function (c) { return yb(I(c, a, b)) }))) }; function Mh(a) { if (null === a) throw Rc("context is absent, it needs to be present to use axes."); if (!B(a.type, 53)) throw Error("XPTY0020: Axes can only be applied to nodes."); return a.value }; function Nh(a, b, c) { var d = b; return { next: function () { if (!d) return x; var e = d; d = Vb(a, e, c); return y($b(e)) } } } function Oh(a, b) { b = b || { Ra: !1 }; H.call(this, a.o, [a], { R: "reverse-sorted", X: !1, subtree: !1, C: !1 }); this.l = a; this.s = !!b.Ra } v(Oh, H); Oh.prototype.h = function (a, b) { var c = this; b = b.h; a = Mh(a.N); var d = this.l.B(); d = d && (d.startsWith("name-") || "type-1" === d) ? "type-1" : null; return C.create(Nh(b, this.s ? a : Vb(b, a, d), d)).filter(function (e) { return c.l.l(e) }) }; var Ph = new Map([["type-1-or-type-2", ["name", "type-1", "type-2"]], ["type-1", ["name"]], ["type-2", ["name"]]]); function Qh(a, b) { if (null === a) return b; if (null === b || a === b) return a; var c = a.startsWith("name-") ? "name" : a, d = b.startsWith("name-") ? "name" : b, e = Ph.get(c); if (void 0 !== e && e.includes(d)) return b; b = Ph.get(d); return void 0 !== b && b.includes(c) ? a : "empty" }; function Rh(a, b) { var c = {}; H.call(this, new Hf((c.attribute = 1, c)), [a], { R: "unsorted", subtree: !0, X: !0, C: !1 }); this.l = a; this.s = Qh(this.l.B(), b) } v(Rh, H); Rh.prototype.h = function (a, b) { var c = this; b = b.h; a = Mh(a.N); if (1 !== a.node.nodeType) return C.empty(); a = Nb(b, a, this.s).filter(function (d) { return "http://www.w3.org/2000/xmlns/" !== d.node.namespaceURI }).map(function (d) { return $b(d) }).filter(function (d) { return c.l.l(d) }); return C.create(a) }; Rh.prototype.B = function () { return "type-1" }; function Sh(a, b) { H.call(this, a.o, [a], { R: "sorted", subtree: !0, X: !0, C: !1 }); this.s = a; this.l = Qh(b, a.B()) } v(Sh, H); Sh.prototype.h = function (a, b) { var c = this, d = b.h, e = Mh(a.N); a = e.node.nodeType; if (1 !== a && 9 !== a) return C.empty(); var f = null, g = !1; return C.create({ next: function () { for (; !g;) { if (!f) { f = Sb(d, e, c.l); if (!f) { g = !0; continue } return y($b(f)) } if (f = Ub(d, f, c.l)) return y($b(f)); g = !0 } return x } }).filter(function (k) { return c.s.l(k) }) }; function Th(a, b, c) { var d = b.node.nodeType; if (1 !== d && 9 !== d) return { next: function () { return x } }; var e = Sb(a, b, c); return { next: function () { if (!e) return x; var f = e; e = Ub(a, e, c); return y(f) } } }; function Uh(a, b, c) { var d = [Qd(b)]; return { next: function (e) { 0 < d.length && 0 !== (e & 1) && d.shift(); if (!d.length) return x; for (e = d[0].next(0); e.done;) { d.shift(); if (!d.length) return x; e = d[0].next(0) } d.unshift(Th(a, e.value, c)); return y($b(e.value)) } } } function Vh(a, b) { b = b || { Ra: !1 }; H.call(this, a.o, [a], { C: !1, X: !1, R: "sorted", subtree: !0 }); this.l = a; this.s = !!b.Ra; this.A = (a = this.l.B()) && (a.startsWith("name-") || "type-1" === a) || "type-1-or-type-2" === a ? "type-1" : null } v(Vh, H);
+			Vh.prototype.h = function (a, b) { var c = this; b = b.h; a = Mh(a.N); a = Uh(b, a, this.A); this.s || a.next(0); return C.create(a).filter(function (d) { return c.l.l(d) }) }; function Wh(a, b, c) { var d = a.node.nodeType; if (1 !== d && 9 !== d) return a; for (d = Tb(b, a, c); null !== d;) { if (1 !== d.node.nodeType) return d; a = d; d = Tb(b, a, c) } return a }
+			function Xh(a, b, c, d) { if (void 0 === c ? 0 : c) { var e = b, f = !1; return { next: function () { if (f) return x; if (Sd(e, b)) return e = Wh(b, a, d), Sd(e, b) ? (f = !0, x) : y($b(e)); var k = e.node.nodeType, l = 9 === k || 2 === k ? null : Wb(a, e, d); if (null !== l) return e = Wh(l, a, d), y($b(e)); e = 9 === k ? null : Vb(a, e, d); return Sd(e, b) ? (f = !0, x) : y($b(e)) } } } var g = [Th(a, b, d)]; return { next: function () { if (!g.length) return x; for (var k = g[0].next(0); k.done;) { g.shift(); if (!g.length) return x; k = g[0].next(0) } g.unshift(Th(a, k.value, d)); return y($b(k.value)) } } }; function Yh(a, b, c) { for (var d = []; b && 9 !== b.node.nodeType; b = Vb(a, b, null)) { var e = Ub(a, b, c); e && d.push(e) } var f = null; return { next: function () { for (; f || d.length;) { if (!f) { f = Xh(a, d[0], !1, c); var g = y($b(d[0])), k = Ub(a, d[0], c); k ? d[0] = k : d.shift(); return g } g = f.next(0); if (g.done) f = null; else return g } return x } } } function Zh(a) { H.call(this, a.o, [a], { R: "sorted", X: !0, subtree: !1, C: !1 }); this.l = a; this.s = (a = this.l.B()) && (a.startsWith("name-") || "type-1" === a) ? "type-1" : null } v(Zh, H);
+			Zh.prototype.h = function (a, b) { var c = this; b = b.h; a = Mh(a.N); return C.create(Yh(b, a, this.s)).filter(function (d) { return c.l.l(d) }) }; function $h(a, b, c) { return { next: function () { return (b = b && Ub(a, b, c)) ? y($b(b)) : x } } } function ai(a, b) { H.call(this, a.o, [a], { R: "sorted", X: !0, subtree: !1, C: !1 }); this.l = a; this.s = Qh(this.l.B(), b) } v(ai, H); ai.prototype.h = function (a, b) { var c = this; b = b.h; a = Mh(a.N); return C.create($h(b, a, this.s)).filter(function (d) { return c.l.l(d) }) }; function bi(a, b) { H.call(this, a.o, [a], { R: "reverse-sorted", X: !0, subtree: !0, C: !1 }); this.l = a; this.s = Qh(b, this.l.B()) } v(bi, H); bi.prototype.h = function (a, b) { b = b.h; a = Mh(a.N); a = Vb(b, a, this.s); if (!a) return C.empty(); a = $b(a); return this.l.l(a) ? C.m(a) : C.empty() }; function ci(a, b, c) { for (var d = []; b && 9 !== b.node.nodeType; b = Vb(a, b, null)) { var e = Wb(a, b, c); null !== e && d.push(e) } var f = null; return { next: function () { for (; f || d.length;) { f || (f = Xh(a, d[0], !0, c)); var g = f.next(0); if (g.done) { f = null; g = Wb(a, d[0], c); var k = y($b(d[0])); null === g ? d.shift() : d[0] = g; return k } return g } return x } } } function di(a) { H.call(this, a.o, [a], { C: !1, X: !0, R: "reverse-sorted", subtree: !1 }); this.l = a; this.s = (a = this.l.B()) && (a.startsWith("name-") || "type-1" === a) ? "type-1" : null } v(di, H);
+			di.prototype.h = function (a, b) { var c = this; b = b.h; a = Mh(a.N); return C.create(ci(b, a, this.s)).filter(function (d) { return c.l.l(d) }) }; function ei(a, b, c) { return { next: function () { return (b = b && Wb(a, b, c)) ? y($b(b)) : x } } } function fi(a, b) { H.call(this, a.o, [a], { C: !1, X: !0, R: "reverse-sorted", subtree: !1 }); this.l = a; this.s = Qh(this.l.B(), b) } v(fi, H); fi.prototype.h = function (a, b) { var c = this; b = b.h; a = Mh(a.N); return C.create(ei(b, a, this.s)).filter(function (d) { return c.l.l(d) }) }; function gi(a, b) { H.call(this, a.o, [a], { R: "sorted", subtree: !0, X: !0, C: !1 }); this.l = a; this.s = Qh(this.l.B(), b) } v(gi, H); gi.prototype.h = function (a) { Mh(a.N); return this.l.l(a.N) ? C.m(a.N) : C.empty() }; gi.prototype.B = function () { return this.s }; function hi(a, b, c, d) { var e = a.o.add(b.o).add(c.o); Df.call(this, e, [a, b, c], { C: a.C && b.C && c.C, X: b.X === c.X && b.X, R: b.da === c.da ? b.da : "unsorted", subtree: b.subtree === c.subtree && b.subtree }, d); this.l = a } v(hi, Df); hi.prototype.A = function (a, b, c) { var d = null, e = c[0](a); return C.create({ next: function (f) { d || (d = (e.ha() ? c[1](a) : c[2](a)).value); return d.next(f) } }) }; hi.prototype.v = function (a) { Df.prototype.v.call(this, a); if (this.l.I) throw af(); }; function ii(a, b, c) { this.location = a; this.o = b; this.h = c } function qg(a) { return a.h instanceof Error ? a.location : qg(a.h) } function rg(a) { var b = a.h instanceof og ? ["Inner error:", a.h.message] : a.h instanceof Error ? [a.h.toString()] : rg(a.h); b.push("  at <" + a.o + ">:" + a.location.start.line + ":" + a.location.start.ja + " - " + a.location.end.line + ":" + a.location.end.ja); return b }; function ji(a, b, c) { Df.call(this, c.o, [c], { C: c.C, X: c.X, R: c.da, subtree: c.subtree }); this.l = b; this.K = { end: { ja: a.end.ja, line: a.end.line, offset: a.end.offset }, start: { ja: a.start.ja, line: a.start.line, offset: a.start.offset } } } v(ji, Df); ji.prototype.A = function (a, b, c) { var d = this; b = p(c).next().value; try { var e = b(a) } catch (f) { throw new ii(this.K, this.l, f); } return C.create({ next: function (f) { try { return e.value.next(f) } catch (g) { throw new ii(d.K, d.l, g); } } }) };
+			ji.prototype.v = function (a) { try { Df.prototype.v.call(this, a) } catch (b) { throw new ii(this.K, this.l, b); } }; function ki(a, b, c, d) { H.call(this, a, b, c, !0); this.l = d; this.I = this.l.I } v(ki, H); function li(a, b, c, d) { var e = [], f = a.K(b, c, d, function (k) { if (a.l instanceof ki) { var l = li(a.l, b, k, d); return Cf(l, function (q) { return e = q }) } var m = null; return C.create({ next: function () { for (; ;) { if (!m) { var q = k.next(0); if (q.done) return x; q = a.l.s(q.value, d); m = Cf(q, function (u) { return e = zf(e, u) }).value } q = m.next(0); if (q.done) m = null; else return q } } }) }), g = !1; return { next: function () { if (g) return x; var k = f.O(); g = !0; return y(new nf(k, e)) } } }
+			ki.prototype.h = function (a, b) { var c = this; return this.K(a, Qd(a), b, function (d) { if (c.l instanceof ki) return mi(c.l, a, d, b); var e = null; return C.create({ next: function (f) { for (; ;) { if (!e) { var g = d.next(0); if (g.done) return x; e = I(c.l, g.value, b).value } g = e.next(f); if (g.done) e = null; else return g } } }) }) }; ki.prototype.s = function (a, b) { return li(this, a, Qd(a), b) };
+			ki.prototype.v = function (a) { H.prototype.v.call(this, a); this.I = this.l.I; a = p(this.ta); for (var b = a.next(); !b.done; b = a.next())if (b = b.value, b !== this.l && b.I) throw af(); }; function mi(a, b, c, d) { return a.K(b, c, d, function (e) { if (a.l instanceof ki) return mi(a.l, b, e, d); var f = null; return C.create({ next: function () { for (; ;) { if (!f) { var g = e.next(0); if (g.done) return x; f = I(a.l, g.value, d).value } g = f.next(0); if (g.done) f = null; else return g } } }) }) }; function ni(a, b, c, d) { ki.call(this, b.o.add(d.o), [b, d], { C: !1 }, d); this.S = a.prefix; this.la = a.namespaceURI; this.Xb = a.localName; this.Gb = null; this.A = c; this.Ba = null; this.pa = b } v(ni, ki);
+			ni.prototype.K = function (a, b, c, d) { var e = this, f = null, g = null, k = 0; return d({ next: function () { for (var l = {}; ;) { if (!f) { var m = b.next(0); if (m.done) return x; g = m.value; k = 0; f = I(e.pa, g, c).value } l.mb = f.next(0); if (l.mb.done) f = null; else return k++, m = {}, l = (m[e.Gb] = function (q) { return function () { return C.m(q.mb.value) } }(l), m), e.Ba && (l[e.Ba] = function () { return C.m(new jb(5, k)) }), y(Nc(g, l)); l = { mb: l.mb } } } }) };
+			ni.prototype.v = function (a) {
+				if (this.S && (this.la = a.aa(this.S), !this.la && this.S)) throw Error("XPST0081: Could not resolve namespace for prefix " + this.S + " in a for expression"); this.pa.v(a); Mg(a); this.Gb = Qg(a, this.la, this.Xb); if (this.A) { if (this.A.prefix && (this.A.namespaceURI = a.aa(this.A.prefix), !this.A.namespaceURI && this.A.prefix)) throw Error("XPST0081: Could not resolve namespace for prefix " + this.S + " in the positionalVariableBinding in a for expression"); this.Ba = Qg(a, this.A.namespaceURI, this.A.localName) } this.l.v(a);
+				Sg(a); if (this.pa.I) throw af(); this.l.I && (this.I = !0)
+			}; function oi(a, b, c) { var d = {}; H.call(this, new Hf((d.external = 1, d)), [c], { C: !1, R: "unsorted" }); this.S = a.map(function (e) { return e.name }); this.A = a.map(function (e) { return e.type }); this.s = null; this.K = b; this.l = c } v(oi, H);
+			oi.prototype.h = function (a, b) { var c = this, d = new Ab({ j: this.A, arity: this.A.length, Sa: !0, I: this.l.I, localName: "dynamic-function", namespaceURI: "", i: this.K, value: function (e, f, g) { var k = Aa.apply(3, arguments), l = Nc(Jc(a, -1, null, C.empty()), c.s.reduce(function (m, q, u) { m[q] = yb(k[u]); return m }, Object.create(null))); return I(c.l, l, b) } }); return C.m(d) };
+			oi.prototype.v = function (a) { Mg(a); this.s = this.S.map(function (b) { return Qg(a, b.namespaceURI, b.localName) }); this.l.v(a); Sg(a); if (this.l.I) throw Error("Not implemented: inline functions can not yet be updating."); }; function pi(a, b, c) { ki.call(this, b.o.add(c.o), [b, c], { C: !1, X: c.X, R: c.da, subtree: c.subtree }, c); if (a.prefix || a.namespaceURI) throw Error("Not implemented: let expressions with namespace usage."); this.A = a.prefix; this.S = a.namespaceURI; this.Ba = a.localName; this.la = b; this.pa = null } v(pi, ki); pi.prototype.K = function (a, b, c, d) { var e = this; return d({ next: function () { var f = b.next(0); if (f.done) return x; f = f.value; var g = {}; f = Nc(f, (g[e.pa] = yb(I(e.la, f, c)), g)); return y(f) } }) };
+			pi.prototype.v = function (a) { if (this.A && (this.S = a.aa(this.A), !this.S && this.A)) throw Error("XPST0081: Could not resolve namespace for prefix " + this.A + " using in a for expression"); this.la.v(a); Mg(a); this.pa = Qg(a, this.S, this.Ba); this.l.v(a); Sg(a); this.I = this.l.I; if (this.la.I) throw af(); }; function qi(a, b) { H.call(this, new Hf({}), [], { C: !0, R: "sorted" }, !1, b); switch (b.type) { case 5: var c = w(parseInt(a, 10), b.type); break; case 1: c = w(a, b.type); break; case 4: case 3: c = w(parseFloat(a), b.type); break; default: throw new TypeError("Type " + b + " not expected in a literal"); }this.l = function () { return C.m(c) } } v(qi, H); qi.prototype.h = function () { return this.l() }; function ri(a, b) { var c = {}; H.call(this, new Hf((c.external = 1, c)), a.reduce(function (d, e) { return d.concat(e.key, e.value) }, []), { C: !1 }, !1, b); this.l = a } v(ri, H); ri.prototype.h = function (a, b) { var c = this, d = this.l.map(function (e) { return Zc(I(e.key, a, b), b).Z({ default: function () { throw Error("XPTY0004: A key of a map should be a single atomizable value."); }, m: function (f) { return f } }) }); return ac(d, function (e) { return C.m(new dc(e.map(function (f, g) { return { key: f, value: yb(I(c.l[g].value, a, b)) } }))) }) }; function si(a, b, c) { var d = {}; H.call(this, new Hf((d.external = 1, d)), [], { C: !0 }, !1, c); this.s = b; this.A = a; this.l = null } v(si, H); si.prototype.h = function () { var a = new Ab({ j: this.l.j, I: this.l.I, arity: this.s, localName: this.l.localName, namespaceURI: this.l.namespaceURI, i: this.l.i, value: this.l.callFunction }); return C.m(a) };
+			si.prototype.v = function (a) {
+				var b = this.A.namespaceURI, c = this.A.localName, d = this.A.prefix; if (null === b) { var e = a.Ua({ localName: c, prefix: d }, this.s); if (!e) throw Error("XPST0017: The function " + (d ? d + ":" : "") + c + " with arity " + this.s + " could not be resolved. " + ug(c)); b = e.namespaceURI; c = e.localName } this.l = a.xa(b, c, this.s) || null; if (!this.l) throw a = this.A, Error("XPST0017: Function " + ((a.namespaceURI ? "Q{" + a.namespaceURI + "}" : a.prefix ? a.prefix + ":" : "") + a.localName) + " with arity of " + this.s + " not registered. " + ug(c));
+				H.prototype.v.call(this, a)
+			}; var ti = {}, ui = (ti[5] = 5, ti[27] = 5, ti[28] = 5, ti[31] = 5, ti[32] = 5, ti[33] = 5, ti[34] = 5, ti[30] = 5, ti[36] = 5, ti[35] = 5, ti[38] = 5, ti[37] = 5, ti[29] = 5, ti[4] = 4, ti[6] = 6, ti[3] = 3, ti); function vi(a, b, c) { H.call(this, b.o, [b], { C: !1 }, !1, c); this.s = b; this.l = a } v(vi, H);
+			vi.prototype.h = function (a, b) { var c = this; return Zc(I(this.s, a, b), b).M(function (d) { if (0 === d.length) return C.empty(); var e = d[0]; if (c.type) return d = "+" === c.l ? +e.value : -e.value, 0 === e.type && (d = Number.NaN), C.m(w(d, c.type.type)); if (1 < d.length) throw Error("XPTY0004: The operand to a unary operator must be a sequence with a length less than one"); return B(e.type, 19) ? (e = Pd(e, 3).value, C.m(w("+" === c.l ? e : -e, 3))) : B(e.type, 2) ? "+" === c.l ? C.m(e) : C.m(w(-1 * e.value, ui[e.type])) : C.m(w(Number.NaN, 3)) }) }; function wi(a, b) { H.call(this, a.reduce(function (c, d) { return c.add(d.o) }, new Hf({})), a, { C: a.every(function (c) { return c.C }) }, !1, b); this.l = a; this.s = a.reduce(function (c, d) { return Qh(c, d.B()) }, null) } v(wi, H);
+			wi.prototype.h = function (a, b) { var c = this, d = 0, e = null, f = !1, g = null; if (null !== a) { var k = a.N; null !== k && B(k.type, 53) && (g = Eb(k.value)) } return C.create({ next: function () { if (!f) { for (; d < c.l.length;) { if (!e) { var l = c.l[d]; if (null !== g && null !== l.B() && !g.includes(l.B())) return d++, f = !0, y(db); e = I(l, a, b) } if (!1 === e.ha()) return f = !0, y(db); e = null; d++ } f = !0; return y(cb) } return x } }) }; wi.prototype.B = function () { return this.s }; function xi(a, b) { var c = a.reduce(function (e, f) { return 0 < If(e, f.o) ? e : f.o }, new Hf({})); H.call(this, c, a, { C: a.every(function (e) { return e.C }) }, !1, b); var d; for (b = 0; b < a.length; ++b) { void 0 === d && (d = a[b].B()); if (null === d) break; if (d !== a[b].B()) { d = null; break } } this.s = d; this.l = a } v(xi, H);
+			xi.prototype.h = function (a, b) { var c = this, d = 0, e = null, f = !1, g = null; if (null !== a) { var k = a.N; null !== k && B(k.type, 53) && (g = Eb(k.value)) } return C.create({ next: function () { if (!f) { for (; d < c.l.length;) { if (!e) { var l = c.l[d]; if (null !== g && null !== l.B() && !g.includes(l.B())) { d++; continue } e = I(l, a, b) } if (!0 === e.ha()) return f = !0, y(cb); e = null; d++ } f = !0; return y(db) } return x } }) }; xi.prototype.B = function () { return this.s }; function yi(a, b) { var c; return C.create({ next: function (d) { for (; ;) { if (!c) { var e = a.value.next(d); if (e.done) return x; c = Yc(e.value, b) } e = c.value.next(d); if (e.done) c = null; else return e } } }) }; function zi(a, b) { if ("eqOp" === a) return function (c, d) { d = b(c, d); c = d.U; d = d.V; return c.value.namespaceURI === d.value.namespaceURI && c.value.localName === d.value.localName }; if ("neOp" === a) return function (c, d) { d = b(c, d); c = d.U; d = d.V; return c.value.namespaceURI !== d.value.namespaceURI || c.value.localName !== d.value.localName }; throw Error('XPTY0004: Only the "eq" and "ne" comparison is defined for xs:QName'); }
+			function Ai(a, b) { switch (a) { case "eqOp": return function (c, d) { c = b(c, d); return c.U.value === c.V.value }; case "neOp": return function (c, d) { c = b(c, d); return c.U.value !== c.V.value }; case "ltOp": return function (c, d) { c = b(c, d); return c.U.value < c.V.value }; case "leOp": return function (c, d) { c = b(c, d); return c.U.value <= c.V.value }; case "gtOp": return function (c, d) { c = b(c, d); return c.U.value > c.V.value }; case "geOp": return function (c, d) { c = b(c, d); return c.U.value >= c.V.value } } }
+			function Bi(a, b) { switch (a) { case "ltOp": return function (c, d) { c = b(c, d); return c.U.value.ga < c.V.value.ga }; case "leOp": return function (c, d) { d = b(c, d); c = d.U; d = d.V; return fc(c.value, d.value) || c.value.ga < d.value.ga }; case "gtOp": return function (c, d) { c = b(c, d); return c.U.value.ga > c.V.value.ga }; case "geOp": return function (c, d) { d = b(c, d); c = d.U; d = d.V; return fc(c.value, d.value) || c.value.ga > d.value.ga } } }
+			function Ci(a, b) { switch (a) { case "eqOp": return function (c, d) { c = b(c, d); return fc(c.U.value, c.V.value) }; case "ltOp": return function (c, d) { c = b(c, d); return c.U.value.ea < c.V.value.ea }; case "leOp": return function (c, d) { d = b(c, d); c = d.U; d = d.V; return fc(c.value, d.value) || c.value.ea < d.value.ea }; case "gtOp": return function (c, d) { c = b(c, d); return c.U.value.ea > c.V.value.ea }; case "geOp": return function (c, d) { d = b(c, d); c = d.U; d = d.V; return fc(c.value, d.value) || c.value.ea > d.value.ea } } }
+			function Di(a, b) { switch (a) { case "eqOp": return function (c, d) { c = b(c, d); return fc(c.U.value, c.V.value) }; case "neOp": return function (c, d) { c = b(c, d); return !fc(c.U.value, c.V.value) } } }
+			function Ei(a, b) {
+				switch (a) {
+					case "eqOp": return function (c, d, e) { c = b(c, d); return wc(c.U.value, c.V.value, Lc(e)) }; case "neOp": return function (c, d, e) { c = b(c, d); return !wc(c.U.value, c.V.value, Lc(e)) }; case "ltOp": return function (c, d, e) { c = b(c, d); e = Lc(e); return 0 > vc(c.U.value, c.V.value, e) }; case "leOp": return function (c, d, e) { d = b(c, d); c = d.U; d = d.V; var f; (f = wc(c.value, d.value, Lc(e))) || (e = Lc(e), f = 0 > vc(c.value, d.value, e)); return f }; case "gtOp": return function (c, d, e) {
+						c = b(c, d); e = Lc(e); return 0 < vc(c.U.value, c.V.value,
+							e)
+					}; case "geOp": return function (c, d, e) { d = b(c, d); c = d.U; d = d.V; var f; (f = wc(c.value, d.value, Lc(e))) || (e = Lc(e), f = 0 < vc(c.value, d.value, e)); return f }
+				}
+			} function Fi(a, b) { switch (a) { case "eqOp": return function (c, d, e) { c = b(c, d); return wc(c.U.value, c.V.value, Lc(e)) }; case "neOp": return function (c, d, e) { c = b(c, d); return !wc(c.U.value, c.V.value, Lc(e)) } } }
+			function Gi(a, b, c) {
+				function d(m, q) { return { U: g ? g(m) : m, V: k ? k(q) : q } } function e(m) { return B(b, m) && B(c, m) } function f(m) { return 0 < m.filter(function (q) { return B(b, q) }).length && 0 < m.filter(function (q) { return B(c, q) }).length } var g = null, k = null; B(b, 19) && B(c, 19) ? b = c = 1 : B(b, 19) ? (g = function (m) { return Pd(m, c) }, b = c) : B(c, 19) && (k = function (m) { return Pd(m, b) }, c = b); if (B(b, 23) && B(c, 23)) return zi(a, d); if (e(0) || f([1, 47, 61]) || f([2, 47, 61]) || e(20) || e(22) || e(21) || f([1, 20])) { var l = Ai(a, d); if (void 0 !== l) return l } if (e(16) && (l = Bi(a,
+					d), void 0 !== l) || e(17) && (l = Ci(a, d), void 0 !== l) || e(18) && (l = Di(a, d), void 0 !== l)) return l; if (e(9) || e(7) || e(8)) if (l = Ei(a, d), void 0 !== l) return l; if (e(11) || e(12) || e(13) || e(14) || e(15)) if (l = Fi(a, d), void 0 !== l) return l; throw Error("XPTY0004: " + a + " not available for " + mb[b] + " and " + mb[c]);
+			} var Hi = Object.create(null); function Ii(a, b, c) { var d = b + "~" + c + "~" + a, e = Hi[d]; e || (e = Hi[d] = Gi(a, b, c)); return e } function Ji(a, b, c) { H.call(this, b.o.add(c.o), [b, c], { C: !1 }); this.l = b; this.A = c; this.s = a } v(Ji, H);
+			Ji.prototype.h = function (a, b) { var c = this, d = I(this.l, a, b), e = I(this.A, a, b), f = yi(d, b), g = yi(e, b); return f.Z({ empty: function () { return C.empty() }, m: function () { return g.Z({ empty: function () { return C.empty() }, m: function () { var k = f.first(), l = g.first(); return Ii(c.s, k.type, l.type)(k, l, a) ? C.ba() : C.W() }, multiple: function () { throw Error("XPTY0004: Sequences to compare are not singleton."); } }) }, multiple: function () { throw Error("XPTY0004: Sequences to compare are not singleton."); } }) }; var Ki = {}, Li = (Ki.equalOp = "eqOp", Ki.notEqualOp = "neOp", Ki.lessThanOrEqualOp = "leOp", Ki.lessThanOp = "ltOp", Ki.greaterThanOrEqualOp = "geOp", Ki.greaterThanOp = "gtOp", Ki);
+			function Mi(a, b, c, d) { a = Li[a]; return c.M(function (e) { return b.filter(function (f) { for (var g = 0, k = e.length; g < k; ++g) { var l = e[g], m = void 0, q = void 0, u = f.type, z = l.type; if (B(u, 19) || B(z, 19)) B(u, 2) ? m = 3 : B(z, 2) ? q = 3 : B(u, 17) ? m = 17 : B(z, 17) ? q = 17 : B(u, 16) ? m = 16 : B(z, 16) ? q = 16 : B(u, 19) ? q = z : B(z, 19) && (m = u); q = p([q, m]); m = q.next().value; q = q.next().value; m ? f = Pd(f, m) : q && (l = Pd(l, q)); if (Ii(a, f.type, l.type)(f, l, d)) return !0 } return !1 }).Z({ default: function () { return C.ba() }, empty: function () { return C.W() } }) }) }
+			function Ni(a, b, c) { H.call(this, b.o.add(c.o), [b, c], { C: !1 }); this.l = b; this.A = c; this.s = a } v(Ni, H); Ni.prototype.h = function (a, b) { var c = this, d = I(this.l, a, b), e = I(this.A, a, b); return d.Z({ empty: function () { return C.W() }, default: function () { return e.Z({ empty: function () { return C.W() }, default: function () { var f = yi(d, b), g = yi(e, b); return Mi(c.s, f, g, a) } }) } }) }; function Oi(a, b, c, d) { if (!B(c, 53) || !B(d, 53)) throw Error("XPTY0004: Sequences to compare are not nodes"); switch (a) { case "isOp": return Pi(c, d); case "nodeBeforeOp": return b ? function (e, f) { return 0 > Yd(b, e.first(), f.first()) } : void 0; case "nodeAfterOp": return b ? function (e, f) { return 0 < Yd(b, e.first(), f.first()) } : void 0; default: throw Error("Unexpected operator"); } }
+			function Pi(a, b) { return a !== b || 47 !== a && 53 !== a && 54 !== a && 55 !== a && 56 !== a && 57 !== a && 58 !== a ? function () { return !1 } : function (c, d) { return Sd(c.first().value, d.first().value) } } function Qi(a, b, c) { H.call(this, b.o.add(c.o), [b, c], { C: !1 }); this.l = b; this.A = c; this.s = a } v(Qi, H);
+			Qi.prototype.h = function (a, b) { var c = this, d = I(this.l, a, b), e = I(this.A, a, b); return d.Z({ empty: function () { return C.empty() }, multiple: function () { throw Error("XPTY0004: Sequences to compare are not singleton"); }, m: function () { return e.Z({ empty: function () { return C.empty() }, multiple: function () { throw Error("XPTY0004: Sequences to compare are not singleton"); }, m: function () { var f = d.first(), g = e.first(); return Oi(c.s, b.h, f.type, g.type)(d, e, a) ? C.ba() : C.W() } }) } }) }; function Ri(a, b, c, d) { return c.M(function (e) { if (e.some(function (f) { return !B(f.type, 53) })) throw Error("XPTY0004: Sequences given to " + a + " should only contain nodes."); return "sorted" === d ? C.create(e) : "reverse-sorted" === d ? C.create(e.reverse()) : C.create(Zd(b, e)) }) } function Si(a, b, c, d) { H.call(this, 0 < If(b.o, c.o) ? b.o : c.o, [b, c], { C: b.C && c.C }, !1, d); this.l = a; this.s = b; this.A = c } v(Si, H);
+			Si.prototype.h = function (a, b) {
+				var c = this, d = Ri(this.l, b.h, I(this.s, a, b), this.s.da); a = Ri(this.l, b.h, I(this.A, a, b), this.A.da); var e = d.value, f = a.value, g = null, k = null, l = !1, m = !1; return C.create({
+					next: function () {
+						if (l) return x; for (; !m;) { if (!g) { var q = e.next(0); if (q.done) return l = !0, x; g = q.value } if (!k) { q = f.next(0); if (q.done) { m = !0; break } k = q.value } if (Sd(g.value, k.value)) { if (q = y(g), k = g = null, "intersectOp" === c.l) return q } else if (0 > Yd(b.h, g, k)) { if (q = y(g), g = null, "exceptOp" === c.l) return q } else k = null } if ("exceptOp" ===
+							c.l) return null !== g ? (q = y(g), g = null, q) : e.next(0); l = !0; return x
+					}
+				})
+			}; function Ti(a, b) { Df.call(this, a.reduce(function (c, d) { return c.add(d.o) }, new Hf({})), a, { R: "unsorted", C: a.every(function (c) { return c.C }) }, b) } v(Ti, Df); Ti.prototype.A = function (a, b, c) { return c.length ? Pc(c.map(function (d) { return d(a) })) : C.empty() }; function Ui(a, b, c) { H.call(this, (new Hf({})).add(a.o), [a, b], { C: a.C && b.C }, !1, c); this.l = a; this.s = b } v(Ui, H); Ui.prototype.h = function (a, b) { var c = this, d = I(this.l, a, b), e = Ic(a, d), f = null, g = null, k = !1; return C.create({ next: function (l) { for (; !k;) { if (!f && (f = e.next(l), f.done)) return k = !0, x; g || (g = I(c.s, f.value, b)); var m = g.value.next(l); if (m.done) f = g = null; else return m } } }) }; function Vi(a, b, c) { H.call(this, a.o, [a], { C: !1 }); this.l = pb(b.prefix ? b.prefix + ":" + b.localName : b.localName); if (46 === this.l || 45 === this.l || 44 === this.l) throw Error("XPST0080: Casting to xs:anyAtomicType, xs:anySimpleType or xs:NOTATION is not permitted."); if (b.namespaceURI) throw Error("Not implemented: castable as expressions with a namespace URI."); this.A = a; this.s = c } v(Vi, H);
+			Vi.prototype.h = function (a, b) { var c = this, d = Zc(I(this.A, a, b), b); return d.Z({ empty: function () { return c.s ? C.ba() : C.W() }, m: function () { return d.map(function (e) { return Od(e, c.l).u ? cb : db }) }, multiple: function () { return C.W() } }) }; function Wi(a, b, c) { H.call(this, a.o, [a], { C: !1 }); this.l = pb(b.prefix ? b.prefix + ":" + b.localName : b.localName); if (46 === this.l || 45 === this.l || 44 === this.l) throw Error("XPST0080: Casting to xs:anyAtomicType, xs:anySimpleType or xs:NOTATION is not permitted."); if (b.namespaceURI) throw Error("Not implemented: casting expressions with a namespace URI."); this.A = a; this.s = c } v(Wi, H);
+			Wi.prototype.h = function (a, b) { var c = this, d = Zc(I(this.A, a, b), b); return d.Z({ empty: function () { if (!c.s) throw Error("XPTY0004: Sequence to cast is empty while target type is singleton."); return C.empty() }, m: function () { return d.map(function (e) { return Pd(e, c.l) }) }, multiple: function () { throw Error("XPTY0004: Sequence to cast is not singleton or empty."); } }) }; function Xi(a, b) { var c = a.value, d = null, e = !1; return C.create({ next: function () { for (; !e;) { if (!d) { var f = c.next(0); if (f.done) return e = !0, y(cb); d = b(f.value) } f = d.ha(); d = null; if (!1 === f) return e = !0, y(db) } return x } }) }; function Yi(a, b, c, d) { H.call(this, a.o, [a], { C: !1 }, !1, d); this.A = a; this.s = b; this.l = c } v(Yi, H); Yi.prototype.h = function (a, b) { var c = this, d = I(this.A, a, b); return d.Z({ empty: function () { return "?" === c.l || "*" === c.l ? C.ba() : C.W() }, multiple: function () { return "+" === c.l || "*" === c.l ? Xi(d, function (e) { var f = C.m(e); e = Jc(a, 0, e, f); return I(c.s, e, b) }) : C.W() }, m: function () { return Xi(d, function (e) { var f = C.m(e); e = Jc(a, 0, e, f); return I(c.s, e, b) }) } }) }; function Zi(a, b) { return null !== a && null !== b && B(a.type, 53) && B(b.type, 53) ? Sd(a.value, b.value) : !1 } function $i(a) { var b = a.next(0); if (b.done) return C.empty(); var c = null, d = null; return C.create({ next: function (e) { if (b.done) return x; c || (c = b.value.value); do { var f = c.next(e); if (f.done) { b = a.next(0); if (b.done) return f; c = b.value.value } } while (f.done || Zi(f.value, d)); d = f.value; return f } }) }
+			function aj(a, b) {
+				var c = []; (function () { for (var g = b.next(0), k = {}; !g.done;)k.ob = g.value.value, g = { current: k.ob.next(0), next: function (l) { return function (m) { return l.ob.next(m) } }(k) }, g.current.done || c.push(g), g = b.next(0), k = { ob: k.ob } })(); var d = null, e = !1, f = {}; return C.create((f[Symbol.iterator] = function () { return this }, f.next = function () {
+					e || (e = !0, c.every(function (z) { return B(z.current.value.type, 53) }) && c.sort(function (z, A) { return Yd(a, z.current.value, A.current.value) })); do {
+						if (!c.length) return x; var g = c.shift();
+						var k = g.current; g.current = g.next(0); if (!B(k.value.type, 53)) return k; if (!g.current.done) { for (var l = 0, m = c.length - 1, q = 0; l <= m;) { q = Math.floor((l + m) / 2); var u = Yd(a, g.current.value, c[q].current.value); if (0 === u) { l = q; break } 0 < u ? l = q + 1 : m = q - 1 } c.splice(l, 0, g) }
+					} while (Zi(k.value, d)); d = k.value; return k
+				}, f))
+			}; function bj(a, b) { var c = a.reduce(function (d, e) { return 0 < If(d, e.o) ? d : e.o }, new Hf({})); H.call(this, c, a, { C: a.every(function (d) { return d.C }) }, !1, b); this.l = a } v(bj, H);
+			bj.prototype.h = function (a, b) { var c = this; if (this.l.every(function (e) { return "sorted" === e.da })) { var d = 0; return aj(b.h, { next: function () { return d >= c.l.length ? x : y(I(c.l[d++], a, b)) } }).map(function (e) { if (!B(e.type, 53)) throw Error("XPTY0004: The sequences to union are not of type node()*"); return e }) } return Pc(this.l.map(function (e) { return I(e, a, b) })).M(function (e) { if (e.some(function (f) { return !B(f.type, 53) })) throw Error("XPTY0004: The sequences to union are not of type node()*"); e = Zd(b.h, e); return C.create(e) }) }; function cj(a) {
+				return a.every(function (b) { return null === b || B(b.type, 5) || B(b.type, 4) }) || null !== a.map(function (b) { return b ? $c(b.type) : null }).reduce(function (b, c) { return null === c ? b : c === b ? b : null }) ? a : a.every(function (b) { return null === b || B(b.type, 1) || B(b.type, 20) }) ? a.map(function (b) { return b ? Pd(b, 1) : null }) : a.every(function (b) { return null === b || B(b.type, 4) || B(b.type, 6) }) ? a.map(function (b) { return b ? Pd(b, 6) : b }) : a.every(function (b) { return null === b || B(b.type, 4) || B(b.type, 6) || B(b.type, 3) }) ? a.map(function (b) {
+					return b ?
+						Pd(b, 3) : b
+				}) : null
+			}; function dj(a) { return (a = a.find(function (b) { return !!b })) ? $c(a.type) : null } function ej(a, b) { var c = new Hf({}); ki.call(this, c, [b].concat(t(a.map(function (d) { return d.ca }))), { C: !1, X: !1, R: "unsorted", subtree: !1 }, b); this.A = a } v(ej, ki);
+			ej.prototype.K = function (a, b, c, d) {
+				if (this.A[1]) throw Error("More than one order spec is not supported for the order by clause."); var e = [], f = !1, g, k, l = null, m = this.A[0]; return C.create({
+					next: function () {
+						if (!f) {
+							for (var q = b.next(0); !q.done;)e.push(q.value), q = b.next(0); q = e.map(function (ia) { return m.ca.h(ia, c) }).map(function (ia) { return Zc(ia, c) }); if (q.find(function (ia) { return !ia.G() && !ia.wa() })) throw Ag("Order by only accepts empty or singleton sequences"); g = q.map(function (ia) { return ia.first() }); g = g.map(function (ia) {
+								return null ===
+									ia ? ia : B(19, ia.type) ? Pd(ia, 1) : ia
+							}); if (dj(g) && (g = cj(g), !g)) throw Ag("Could not cast values"); q = g.length; k = g.map(function (ia, Ba) { return Ba }); for (var u = 0; u < q; u++)if (u + 1 !== q) for (var z = u; 0 <= z; z--) {
+								var A = z, D = z + 1; if (D !== q) {
+									var F = g[k[A]], J = g[k[D]]; if (null !== J || null !== F) {
+										if (m.lc) { if (null === F) continue; if (null === J && null !== F) { F = p([k[D], k[A]]); k[A] = F.next().value; k[D] = F.next().value; continue } if (isNaN(J.value) && null !== F && !isNaN(F.value)) { F = p([k[D], k[A]]); k[A] = F.next().value; k[D] = F.next().value; continue } } else {
+											if (null ===
+												J) continue; if (null === F && null !== J) { F = p([k[D], k[A]]); k[A] = F.next().value; k[D] = F.next().value; continue } if (isNaN(F.value) && null !== J && !isNaN(J.value)) { F = p([k[D], k[A]]); k[A] = F.next().value; k[D] = F.next().value; continue }
+										} Ii("gtOp", F.type, J.type)(F, J, a) && (F = p([k[D], k[A]]), k[A] = F.next().value, k[D] = F.next().value)
+									}
+								}
+							} var T = m.Kb ? 0 : g.length - 1; l = d({ next: function () { return m.Kb ? T >= g.length ? x : y(e[k[T++]]) : 0 > T ? x : y(e[k[T--]]) } }).value; f = !0
+						} return l.next(0)
+					}
+				})
+			}; function fj(a) { H.call(this, a ? a.o : new Hf({}), a ? [a] : [], { R: "sorted", subtree: !1, X: !1, C: !1 }); this.l = a } v(fj, H); fj.prototype.h = function (a, b) { if (null === a.N) throw Rc("context is absent, it needs to be present to use paths."); for (var c = b.h, d = a.N.value; 9 !== d.node.nodeType;)if (d = Vb(c, d), null === d) throw Error("XPDY0050: the root node of the context node is not a document node."); c = C.m($b(d)); return this.l ? I(this.l, Jc(a, 0, c.first(), c), b) : c }; function gj(a) { H.call(this, new Hf({}), [], { R: "sorted" }, !1, a) } v(gj, H); gj.prototype.h = function (a) { if (null === a.N) throw Rc('context is absent, it needs to be present to use the "." operator'); return C.m(a.N) }; function hj(a, b) { var c = !1, d = !1; b.forEach(function (e) { B(e.type, 53) ? c = !0 : d = !0 }); if (d && c) throw Error("XPTY0018: The path operator should either return nodes or non-nodes. Mixed sequences are not allowed."); return c ? Zd(a, b) : b } function ij(a, b) { var c = a.every(function (e) { return e.X }), d = a.every(function (e) { return e.subtree }); H.call(this, a.reduce(function (e, f) { return e.add(f.o) }, new Hf({})), a, { C: !1, X: c, R: b ? "sorted" : "unsorted", subtree: d }); this.l = a; this.s = b } v(ij, H);
+			ij.prototype.h = function (a, b) {
+				var c = this, d = !0; return this.l.reduce(function (e, f, g) {
+					var k = null === e ? Qd(a) : Ic(a, e); e = { next: function (q) { q = k.next(q); if (q.done) return x; if (null !== q.value.N && !B(q.value.N.type, 53) && 0 < g) throw Error("XPTY0019: The result of E1 in a path expression E1/E2 should not evaluate to a sequence of nodes."); return y(I(f, q.value, b)) } }; if (c.s) switch (f.da) {
+						case "reverse-sorted": var l = e; e = { next: function (q) { q = l.next(q); return q.done ? q : y(q.value.M(function (u) { return C.create(u.reverse()) })) } };
+						case "sorted": if (f.subtree && d) { var m = $i(e); break } m = aj(b.h, e); break; case "unsorted": return $i(e).M(function (q) { return C.create(hj(b.h, q)) })
+					} else m = $i(e); d = d && f.X; return m
+				}, null)
+			}; ij.prototype.B = function () { return this.l[0].B() }; function jj(a, b) { H.call(this, a.o.add(b.o), [a, b], { C: a.C && b.C, X: a.X, R: a.da, subtree: a.subtree }); this.s = a; this.l = b } v(jj, H);
+			jj.prototype.h = function (a, b) {
+				var c = this, d = I(this.s, a, b); if (this.l.C) { var e = I(this.l, a, b); if (e.G()) return e; var f = e.first(); if (B(f.type, 2)) { var g = f.value; if (!Number.isInteger(g)) return C.empty(); var k = d.value, l = !1; return C.create({ next: function () { if (!l) { for (var A = k.next(0); !A.done; A = k.next(0))if (1 === g--) return l = !0, A; l = !0 } return x } }) } return e.ha() ? d : C.empty() } var m = d.value, q = null, u = 0, z = null; return C.create({
+					next: function (A) {
+						for (var D = !1; !q || !q.done;) {
+							q || (q = m.next(D ? 0 : A), D = !0); if (q.done) break; z || (z =
+								I(c.l, Jc(a, u, q.value, d), b)); var F = z.first(); F = null === F ? !1 : B(F.type, 2) ? F.value === u + 1 : z.ha(); z = null; var J = q.value; q = null; u++; if (F) return y(J)
+						} return q
+					}
+				})
+			}; jj.prototype.B = function () { return this.s.B() }; function kj(a, b, c) {
+				c = [c]; if (B(a.type, 62)) if ("*" === b) c.push.apply(c, t(a.P.map(function (e) { return e() }))); else if (B(b.type, 5)) { var d = b.value; if (a.P.length < d || 0 >= d) throw Error("FOAY0001: Array index out of bounds"); c.push(a.P[d - 1]()) } else throw Ag("The key specifier is not an integer."); else if (B(a.type, 61)) "*" === b ? c.push.apply(c, t(a.h.map(function (e) { return e.value() }))) : (a = a.h.find(function (e) { return bc(e.key, b) })) && c.push(a.value()); else throw Ag("The provided context item is not a map or an array.");
+				return Pc(c)
+			} function lj(a, b, c, d, e) { if ("*" === b) return kj(a, b, c); b = I(b, d, e); b = yb(b)().M(function (f) { return f.reduce(function (g, k) { return kj(a, k, g) }, new ib) }); return Pc([c, b]) }; function mj(a, b) { H.call(this, a.o, [a].concat("*" === b ? [] : [b]), { C: a.C, R: a.da, subtree: a.subtree }); this.l = a; this.s = b } v(mj, H); mj.prototype.h = function (a, b) { var c = this; return I(this.l, a, b).M(function (d) { return d.reduce(function (e, f) { return lj(f, c.s, e, a, b) }, new ib) }) }; mj.prototype.B = function () { return this.l.B() }; function nj(a, b) { var c = {}; H.call(this, new Hf((c.external = 1, c)), "*" === a ? [] : [a], { C: !1 }, !1, b); this.l = a } v(nj, H); nj.prototype.h = function (a, b) { return lj(a.N, this.l, new ib, a, b) }; function oj(a, b, c, d) { var e = b.map(function (g) { return g.jb }); b = b.map(function (g) { return g.name }); var f = e.reduce(function (g, k) { return g.add(k.o) }, c.o); H.call(this, f, e.concat(c), { C: !1 }, !1, d); this.s = a; this.A = b; this.K = e; this.S = c; this.l = null } v(oj, H);
+			oj.prototype.h = function (a, b) {
+				var c = this, d = a, e = this.l.map(function (q, u) { var z = I(c.K[u], d, b).O(); u = {}; d = Nc(a, (u[q] = function () { return C.create(z) }, u)); return z }); if (e.some(function (q) { return 0 === q.length })) return "every" === this.s ? C.ba() : C.W(); var f = Array(e.length).fill(0); f[0] = -1; for (var g = !0; g;) {
+					g = !1; for (var k = 0, l = f.length; k < l; ++k) {
+						var m = e[k]; if (++f[k] > m.length - 1) f[k] = 0; else {
+							g = Object.create(null); k = {}; for (l = 0; l < f.length; k = { xb: k.xb }, l++)k.xb = e[l][f[l]], g[this.l[l]] = function (q) { return function () { return C.m(q.xb) } }(k);
+							g = Nc(a, g); g = I(this.S, g, b); if (g.ha() && "some" === this.s) return C.ba(); if (!g.ha() && "every" === this.s) return C.W(); g = !0; break
+						}
+					}
+				} return "every" === this.s ? C.ba() : C.W()
+			}; oj.prototype.v = function (a) { this.l = []; for (var b = 0, c = this.A.length; b < c; ++b) { this.K[b].v(a); Mg(a); var d = this.A[b], e = d.prefix ? a.aa(d.prefix) : null; d = Qg(a, e, d.localName); this.l[b] = d } this.S.v(a); b = 0; for (c = this.A.length; b < c; ++b)Sg(a) }; function pj(a) { H.call(this, a, [], { C: !1 }) } v(pj, H); pj.prototype.h = function (a) { return this.l(a.N) ? C.ba() : C.W() }; function qj(a) { var b = {}; pj.call(this, new Hf((b.nodeType = 1, b))); this.s = a } v(qj, pj); qj.prototype.l = function (a) { if (!B(a.type, 53)) return !1; a = a.value.node.nodeType; return 3 === this.s && 4 === a ? !0 : this.s === a }; qj.prototype.B = function () { return "type-" + this.s }; function rj(a, b) { b = void 0 === b ? { kind: null } : b; var c = a.prefix, d = a.namespaceURI; a = a.localName; var e = {}; "*" !== a && (e.nodeName = 1); e.nodeType = 1; pj.call(this, new Hf(e)); this.s = a; this.K = d; this.A = c; this.S = b.kind } v(rj, pj);
+			rj.prototype.l = function (a) { var b = B(a.type, 54), c = B(a.type, 47); if (!b && !c) return !1; a = a.value; return null !== this.S && (1 === this.S && !b || 2 === this.S && !c) ? !1 : null === this.A && "" !== this.K && "*" === this.s ? !0 : "*" === this.A ? "*" === this.s ? !0 : this.s === a.node.localName : "*" !== this.s && this.s !== a.node.localName ? !1 : (a.node.namespaceURI || null) === (("" === this.A ? b ? this.K : null : this.K) || null) }; rj.prototype.B = function () { return "*" === this.s ? null === this.S ? "type-1-or-type-2" : "type-" + this.S : "name-" + this.s };
+			rj.prototype.v = function (a) { if (null === this.K && "*" !== this.A && (this.K = a.aa(this.A || "") || null, !this.K && this.A)) throw Error("XPST0081: The prefix " + this.A + " could not be resolved."); }; function sj(a) { var b = {}; pj.call(this, new Hf((b.nodeName = 1, b))); this.s = a } v(sj, pj); sj.prototype.l = function (a) { return B(a.type, 57) && a.value.node.target === this.s }; sj.prototype.B = function () { return "type-7" }; function tj(a) { pj.call(this, new Hf({})); this.s = a } v(tj, pj); tj.prototype.l = function (a) { return B(a.type, pb(this.s.prefix ? this.s.prefix + ":" + this.s.localName : this.s.localName)) }; function uj(a, b, c) { H.call(this, new Hf({}), [], { C: !1, R: "unsorted" }); this.A = c; this.s = b; this.K = a; this.l = null } v(uj, H); uj.prototype.h = function (a, b) { if (!a.Aa[this.l]) { if (this.S) return this.S(a, b); throw Error("XQDY0054: The variable " + this.A + " is declared but not in scope."); } return a.Aa[this.l]() }; uj.prototype.v = function (a) { null === this.s && this.K && (this.s = a.aa(this.K)); this.l = a.ib(this.s || "", this.A); if (!this.l) throw Error("XPST0008, The variable " + this.A + " is not in scope."); if (a = a.Ia[this.l]) this.S = a }; function vj(a, b) { var c = new Hf({}); ki.call(this, c, [a, b], { C: !1, X: !1, R: "unsorted", subtree: !1 }, b); this.A = a } v(vj, ki); vj.prototype.K = function (a, b, c, d) { var e = this, f = null, g = null; return d({ next: function () { for (; ;) { if (!g) { var k = b.next(0); if (k.done) return x; f = k.value; g = I(e.A, f, c) } k = g.ha(); var l = f; g = f = null; if (k) return y(l) } } }) }; function wj(a) { this.type = a }; function xj(a) { this.type = "delete"; this.target = a } v(xj, wj); xj.prototype.h = function (a) { var b = {}; return b.type = this.type, b.target = ig(this.target, a, !1), b }; function yj(a, b, c) { this.type = c; this.target = a; this.content = b } v(yj, wj); yj.prototype.h = function (a) { var b = {}; return b.type = this.type, b.target = ig(this.target, a, !1), b.content = this.content.map(function (c) { return ig(c, a, !0) }), b }; function zj(a, b) { yj.call(this, a, b, "insertAfter") } v(zj, yj); function Aj(a, b) { this.type = "insertAttributes"; this.target = a; this.content = b } v(Aj, wj); Aj.prototype.h = function (a) { var b = {}; return b.type = this.type, b.target = ig(this.target, a, !1), b.content = this.content.map(function (c) { return ig(c, a, !0) }), b }; function Bj(a, b) { yj.call(this, a, b, "insertBefore") } v(Bj, yj); function Cj(a, b) { yj.call(this, a, b, "insertIntoAsFirst") } v(Cj, yj); function Dj(a, b) { yj.call(this, a, b, "insertIntoAsLast") } v(Dj, yj); function Ej(a, b) { yj.call(this, a, b, "insertInto") } v(Ej, yj); function Fj(a, b) { this.type = "rename"; this.target = a; this.o = b.Ca ? b : new zb(b.prefix, b.namespaceURI, b.localName) } v(Fj, wj); Fj.prototype.h = function (a) { var b = {}, c = {}; return c.type = this.type, c.target = ig(this.target, a, !1), c.newName = (b.prefix = this.o.prefix, b.namespaceURI = this.o.namespaceURI, b.localName = this.o.localName, b), c }; function Gj(a, b) { this.type = "replaceElementContent"; this.target = a; this.text = b } v(Gj, wj); Gj.prototype.h = function (a) { var b = {}; return b.type = this.type, b.target = ig(this.target, a, !1), b.text = this.text ? ig(this.text, a, !0) : null, b }; function Hj(a, b) { this.type = "replaceNode"; this.target = a; this.o = b } v(Hj, wj); Hj.prototype.h = function (a) { var b = {}; return b.type = this.type, b.target = ig(this.target, a, !1), b.replacement = this.o.map(function (c) { return ig(c, a, !0) }), b }; function Ij(a, b) { this.type = "replaceValue"; this.target = a; this.o = b } v(Ij, wj); Ij.prototype.h = function (a) { var b = {}; return b.type = this.type, b.target = ig(this.target, a, !1), b["string-value"] = this.o, b }; function Jj(a, b) { return new Hj(a, b) }; function Kj(a) { Af.call(this, new Hf({}), [a], { C: !1, R: "unsorted" }); this.l = a } v(Kj, Af); Kj.prototype.s = function (a, b) { var c = Bf(this.l)(a, b), d = b.h, e, f; return { next: function () { if (!e) { var g = c.next(0); if (g.value.J.some(function (k) { return !B(k.type, 53) })) throw Error("XUTY0007: The target of a delete expression must be a sequence of zero or more nodes."); e = g.value.J; f = g.value.fa } e = e.filter(function (k) { return Vb(d, k.value) }); return y({ fa: zf(e.map(function (k) { return new xj(k.value) }), f), J: [] }) } } }; function Lj(a, b, c, d, e, f) {
+				var g = b.h; a.reduce(function q(l, m) { if (B(m.type, 62)) return m.P.forEach(function (u) { return u().O().forEach(function (z) { return q(l, z) }) }), l; l.push(m); return l }, []).forEach(function (l, m, q) {
+					if (B(l.type, 47)) { if (e) throw f(l.value, g); c.push(l.value.node) } else if (B(l.type, 46) || B(l.type, 53) && 3 === l.value.node.nodeType) {
+						var u = B(l.type, 46) ? Pd(Yc(l, b).first(), 1).value : Qb(g, l.value); 0 !== m && B(q[m - 1].type, 46) && B(l.type, 46) ? (d.push({ data: " " + u, Ta: !0, nodeType: 3 }), e = !0) : u && (d.push({
+							data: "" + u,
+							Ta: !0, nodeType: 3
+						}), e = !0)
+					} else if (B(l.type, 55)) { var z = []; Pb(g, l.value).forEach(function (A) { return z.push($b(A)) }); e = Lj(z, b, c, d, e, f) } else if (B(l.type, 53)) d.push(l.value.node), e = !0; else { if (B(l.type, 60)) throw Tc(l.type); throw Error("Atomizing " + l.type + " is not implemented."); }
+				}); return e
+			} function Mj(a, b, c) { var d = [], e = [], f = !1; a.forEach(function (g) { f = Lj(g, b, d, e, f, c) }); return { attributes: d, Xa: e } }; function Nj(a, b, c, d, e) { var f = []; switch (a) { case 4: d.length && f.push(new Aj(b, d)); e.length && f.push(new Cj(b, e)); break; case 5: d.length && f.push(new Aj(b, d)); e.length && f.push(new Dj(b, e)); break; case 3: d.length && f.push(new Aj(b, d)); e.length && f.push(new Ej(b, e)); break; case 2: d.length && f.push(new Aj(c, d)); e.length && f.push(new Bj(b, e)); break; case 1: d.length && f.push(new Aj(c, d)), e.length && f.push(new zj(b, e)) }return f }
+			function Oj(a, b, c) { Af.call(this, new Hf({}), [a, c], { C: !1, R: "unsorted" }); this.K = a; this.l = b; this.A = c } v(Oj, Af);
+			Oj.prototype.s = function (a, b) {
+				var c = this, d = Bf(this.K)(a, b), e = Bf(this.A)(a, b), f = b.h, g, k, l, m, q, u; return {
+					next: function () {
+						if (!g) { var z = d.next(0), A = Mj([z.value.J], b, bf); g = A.attributes.map(function (D) { return { node: D, F: null } }); k = A.Xa.map(function (D) { return { node: D, F: null } }); l = z.value.fa } if (!m) {
+							z = e.next(0); if (0 === z.value.J.length) throw mf(); if (3 <= c.l) { if (1 !== z.value.J.length) throw cf(); if (!B(z.value.J[0].type, 54) && !B(z.value.J[0].type, 55)) throw cf(); } else {
+								if (1 !== z.value.J.length) throw df(); if (!(B(z.value.J[0].type,
+									54) || B(z.value.J[0].type, 56) || B(z.value.J[0].type, 58) || B(z.value.J[0].type, 57))) throw df(); u = Vb(f, z.value.J[0].value, null); if (null === u) throw Error("XUDY0029: The target " + z.value.J[0].value.outerHTML + " for inserting a node before or after must have a parent.");
+							} m = z.value.J[0]; q = z.value.fa
+						} if (g.length) {
+							if (3 <= c.l) { if (!B(m.type, 54)) throw Error("XUTY0022: An insert expression specifies the insertion of an attribute node into a document node."); } else if (1 !== u.node.nodeType) throw Error("XUDY0030: An insert expression specifies the insertion of an attribute node before or after a child of a document node.");
+							g.reduce(function (D, F) { var J = F.node.prefix || "", T = F.node.prefix || "", ia = F.node.namespaceURI, Ba = T ? m.value.node.lookupNamespaceURI(T) : null; if (Ba && Ba !== ia) throw kf(ia); if ((T = D[T]) && ia !== T) throw lf(ia); D[J] = F.node.namespaceURI; return D }, {})
+						} return y({ J: [], fa: zf(Nj(c.l, m.value, u ? u : null, g, k), l, q) })
+					}
+				}
+			}; function Pj() { return Sc("Casting not supported from given type to a single xs:string or xs:untypedAtomic or any of its derived types.") } var Qj = /([A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])/, Rj = new RegExp(Qj.source + (new RegExp("(" + Qj.source + "|[-.0-9\u00b7\u0300-\u036f\u203f\u2040])")).source + "*", "g"); function Sj(a) { return (a = a.match(Rj)) ? 1 === a.length : !1 }
+			function Tj(a, b) { return Zc(b, a).Z({ m: function (c) { c = c.first(); if (B(c.type, 1) || B(c.type, 19)) { if (!Sj(c.value)) throw Error('XQDY0041: The value "' + c.value + '" of a name expressions cannot be converted to a NCName.'); return C.m(c) } throw Pj(); }, default: function () { throw Pj(); } }).value }
+			function Uj(a, b, c) { return Zc(c, b).Z({ m: function (d) { d = d.first(); if (B(d.type, 23)) return C.m(d); if (B(d.type, 1) || B(d.type, 19)) { d = d.value.split(":"); if (1 === d.length) d = d[0]; else { var e = d[0]; var f = a.aa(e); d = d[1] } if (!Sj(d) || e && !Sj(e)) throw Hg(e ? e + ":" + d : d); if (e && !f) throw Hg(e + ":" + d); return C.m({ type: 23, value: new zb(e, f, d) }) } throw Pj(); }, default: function () { throw Pj(); } }).value }; function Vj(a, b) { Af.call(this, new Hf({}), [a, b], { C: !1, R: "unsorted" }); this.A = a; this.K = b; this.l = void 0 } v(Vj, Af);
+			Vj.prototype.s = function (a, b) {
+				var c = this, d = Bf(this.A)(a, b), e = Bf(this.K)(a, b); return {
+					next: function () {
+						var f = d.next(0); var g = f.value.J; if (0 === g.length) throw mf(); if (1 !== g.length) throw gf(); if (!B(g[0].type, 54) && !B(g[0].type, 47) && !B(g[0].type, 57)) throw gf(); g = g[0]; var k = e.next(0); a: {
+							var l = c.l; var m = C.create(k.value.J); switch (g.type) {
+								case 54: l = Uj(l, b, m).next(0).value.value; if ((m = g.value.node.lookupNamespaceURI(l.prefix)) && m !== l.namespaceURI) throw kf(l.namespaceURI); break a; case 47: l = Uj(l, b, m).next(0).value.value;
+									if (l.namespaceURI && (m = g.value.node.lookupNamespaceURI(l.prefix)) && m !== l.namespaceURI) throw kf(l.namespaceURI); break a; case 57: l = Tj(b, m).next(0).value.value; l = new zb("", null, l); break a
+							}l = void 0
+						} return y({ J: [], fa: zf([new Fj(g.value, l)], f.value.fa, k.value.fa) })
+					}
+				}
+			}; Vj.prototype.v = function (a) { this.l = Of(a); Af.prototype.v.call(this, a) }; function Wj(a, b, c) {
+				var d, e, f; return {
+					next: function () {
+						if (!d) { var g = c.next(0), k = Mj([g.value.J], a, lf); d = { attributes: k.attributes.map(function (l) { return { node: l, F: null } }), Xa: k.Xa.map(function (l) { return { node: l, F: null } }) }; e = g.value.fa } k = b.next(0); if (0 === k.value.J.length) throw mf(); if (1 !== k.value.J.length) throw ff(); if (!(B(k.value.J[0].type, 54) || B(k.value.J[0].type, 47) || B(k.value.J[0].type, 56) || B(k.value.J[0].type, 58) || B(k.value.J[0].type, 57))) throw ff(); f = Vb(a.h, k.value.J[0].value, null); if (null === f) throw Error("XUDY0009: The target " +
+							k.value.J[0].value.outerHTML + " for replacing a node must have a parent."); g = k.value.J[0]; k = k.value.fa; if (B(g.type, 47)) { if (d.Xa.length) throw Error("XUTY0011: When replacing an attribute the new value must be zero or more attribute nodes."); d.attributes.reduce(function (l, m) { var q = m.node.prefix || ""; m = m.node.namespaceURI; var u = f.node.lookupNamespaceURI(q); if (u && u !== m) throw kf(m); if ((u = l[q]) && m !== u) throw lf(m); l[q] = m; return l }, {}) } else if (d.attributes.length) throw Error("XUTY0010: When replacing an an element, text, comment, or processing instruction node the new value must be a single node.");
+						return y({ J: [], fa: zf([Jj(g.value, [].concat(d.attributes, d.Xa))], e, k) })
+					}
+				}
+			}
+			function Xj(a, b, c) {
+				var d, e, f, g, k = !1; return {
+					next: function () {
+						if (k) return x; if (!f) { var l = c.next(0), m = Zc(C.create(l.value.J), a).map(function (q) { return Pd(q, 1) }).O().map(function (q) { return q.value }).join(" "); f = 0 === m.length ? null : { node: a.o.createTextNode(m), F: null }; g = l.value.fa } if (!d) {
+							l = b.next(0); if (0 === l.value.J.length) throw mf(); if (1 !== l.value.J.length) throw ff(); if (!(B(l.value.J[0].type, 54) || B(l.value.J[0].type, 47) || B(l.value.J[0].type, 56) || B(l.value.J[0].type, 58) || B(l.value.J[0].type, 57))) throw ff();
+							d = l.value.J[0]; e = l.value.fa
+						} if (B(d.type, 54)) return k = !0, y({ J: [], fa: zf([new Gj(d.value, f)], g, e) }); if (B(d.type, 47) || B(d.type, 56) || B(d.type, 58) || B(d.type, 57)) {
+							l = f ? Qb(a.h, f) : ""; if (B(d.type, 58) && (l.includes("--") || l.endsWith("-"))) throw Error('XQDY0072: The content "' + l + '" for a comment node contains two adjacent hyphens or ends with a hyphen.'); if (B(d.type, 57) && l.includes("?>")) throw Error('XQDY0026: The content "' + l + '" for a processing instruction node contains "?>".'); k = !0; return y({
+								J: [], fa: zf([new Ij(d.value,
+									l)], g, e)
+							})
+						}
+					}
+				}
+			} function Yj(a, b, c) { Af.call(this, new Hf({}), [b, c], { C: !1, R: "unsorted" }); this.K = a; this.l = b; this.A = c } v(Yj, Af); Yj.prototype.s = function (a, b) { var c = Bf(this.l)(a, b); a = Bf(this.A)(a, b); return this.K ? Xj(b, c, a) : Wj(b, c, a) }; function Zj(a) {
+				switch (a.type) {
+					case "delete": return new xj({ node: a.target, F: null }); case "insertAfter": return new zj({ node: a.target, F: null }, a.content.map(function (b) { return { node: b, F: null } })); case "insertBefore": return new Bj({ node: a.target, F: null }, a.content.map(function (b) { return { node: b, F: null } })); case "insertInto": return new Ej({ node: a.target, F: null }, a.content.map(function (b) { return { node: b, F: null } })); case "insertIntoAsFirst": return new Cj({ node: a.target, F: null }, a.content.map(function (b) {
+						return {
+							node: b,
+							F: null
+						}
+					})); case "insertIntoAsLast": return new Dj({ node: a.target, F: null }, a.content.map(function (b) { return { node: b, F: null } })); case "insertAttributes": return new Aj({ node: a.target, F: null }, a.content.map(function (b) { return { node: b, F: null } })); case "rename": return new Fj({ node: a.target, F: null }, a.newName); case "replaceNode": return new Hj({ node: a.target, F: null }, a.replacement.map(function (b) { return { node: b, F: null } })); case "replaceValue": return new Ij({ node: a.target, F: null }, a["string-value"]); case "replaceElementContent": return new Gj({
+						node: a.target,
+						F: null
+					}, a.text ? { node: a.text, F: null } : null); default: throw Error('Unexpected type "' + a.type + '" when parsing a transferable pending update.');
+				}
+			}; function ak(a, b, c) { if (b.find(function (e) { return Sd(e, a) })) return !0; var d = Vb(c, a); return d ? ak(d, b, c) : !1 } function bk(a, b, c) { Af.call(this, new Hf({}), a.reduce(function (d, e) { d.push(e.jb); return d }, [b, c]), { C: !1, R: "unsorted" }); this.l = a; this.K = b; this.A = c; this.I = null } v(bk, Af); bk.prototype.h = function (a, b) { a = this.s(a, b); return Cf(a, function () { }) };
+			bk.prototype.s = function (a, b) {
+				var c = this, d = b.h, e = b.o, f = b.B, g = [], k, l, m, q = [], u = []; return {
+					next: function () {
+						if (q.length !== c.l.length) for (var z = {}, A = q.length; A < c.l.length; z = { lb: z.lb }, A++) {
+							var D = c.l[A], F = g[A]; F || (g[A] = F = Bf(D.jb)(a, b)); F = F.next(0); if (1 !== F.value.J.length || !B(F.value.J[0].type, 53)) throw Error("XUTY0013: The source expression of a copy modify expression must return a single node."); z.lb = $b(eg(F.value.J[0].value, b)); q.push(z.lb.value); u.push(F.value.fa); F = {}; a = Nc(a, (F[D.qc] = function (J) { return function () { return C.m(J.lb) } }(z),
+								F))
+						} m || (k || (k = Bf(c.K)(a, b)), m = k.next(0).value.fa); m.forEach(function (J) { if (J.target && !ak(J.target, q, d)) throw Error("XUDY0014: The target " + J.target.node.outerHTML + " must be a node created by the copy clause."); if ("put" === J.type) throw Error("XUDY0037: The modify expression of a copy modify expression can not contain a fn:put."); }); z = m.map(function (J) { J = J.h(b); return Zj(J) }); xf(z, d, e, f); l || (l = Bf(c.A)(a, b)); z = l.next(0); return y({ J: z.value.J, fa: zf.apply(null, [z.value.fa].concat(t(u))) })
+					}
+				}
+			};
+			bk.prototype.v = function (a) { Mg(a); this.l.forEach(function (b) { return b.qc = Qg(a, b.Rb.namespaceURI, b.Rb.localName) }); Af.prototype.v.call(this, a); Sg(a); this.I = this.l.some(function (b) { return b.jb.I }) || this.A.I }; function ck(a, b) { return { node: { nodeType: 2, Ta: !0, nodeName: a.Ca(), namespaceURI: a.namespaceURI, prefix: a.prefix, localName: a.localName, name: a.Ca(), value: b }, F: null } } function dk(a, b) { var c = b.wb || []; c = c.concat(a.Oa || []); H.call(this, new Hf({}), c, { C: !1, R: "unsorted" }); a.Oa ? this.s = a.Oa : this.name = new zb(a.prefix, a.namespaceURI, a.localName); this.l = b; this.A = void 0 } v(dk, H);
+			dk.prototype.h = function (a, b) {
+				var c = this, d, e, f, g = !1; return C.create({
+					next: function () {
+						if (g) return x; if (!e) {
+							if (c.s) { if (!d) { var k = c.s.h(a, b); d = Uj(c.A, b, k) } e = d.next(0).value.value } else e = c.name; if (e) {
+								if ("xmlns" === e.prefix) throw Cg(e); if ("" === e.prefix && "xmlns" === e.localName) throw Cg(e); if ("http://www.w3.org/2000/xmlns/" === e.namespaceURI) throw Cg(e); if ("xml" === e.prefix && "http://www.w3.org/XML/1998/namespace" !== e.namespaceURI) throw Cg(e); if ("" !== e.prefix && "xml" !== e.prefix && "http://www.w3.org/XML/1998/namespace" ===
+									e.namespaceURI) throw Cg(e);
+							}
+						} if (c.l.wb) return k = c.l.wb, f || (f = Pc(k.map(function (l) { return Zc(l.h(a, b), b).M(function (m) { return C.m(w(m.map(function (q) { return q.value }).join(" "), 1)) }) })).M(function (l) { return C.m($b(ck(e, l.map(function (m) { return m.value }).join("")))) }).value), f.next(0); g = !0; return y($b(ck(e, c.l.value)))
+					}
+				})
+			};
+			dk.prototype.v = function (a) { this.A = Of(a); if (this.name && this.name.prefix && !this.name.namespaceURI) { var b = a.aa(this.name.prefix); if (void 0 === b && this.name.prefix) throw Uc(this.name.prefix); this.name.namespaceURI = b || null } H.prototype.v.call(this, a) }; function ek(a) { H.call(this, a ? a.o : new Hf({}), a ? [a] : [], { C: !1, R: "unsorted" }); this.l = a } v(ek, H); ek.prototype.h = function (a, b) { var c = { data: "", Ta: !0, nodeType: 8 }, d = { node: c, F: null }; if (!this.l) return C.m($b(d)); a = I(this.l, a, b); return Zc(a, b).M(function (e) { e = e.map(function (f) { return Pd(f, 1).value }).join(" "); if (-1 !== e.indexOf("--\x3e")) throw Error('XQDY0072: The contents of the data of a comment may not include "--\x3e"'); c.data = e; return C.m($b(d)) }) }; function fk(a, b, c, d) { H.call(this, new Hf({}), d.concat(b).concat(a.Oa || []), { C: !1, R: "unsorted" }); a.Oa ? this.s = a.Oa : this.l = new zb(a.prefix, a.namespaceURI, a.localName); this.S = c.reduce(function (e, f) { if (f.prefix in e) throw Error("XQST0071: The namespace declaration with the prefix " + f.prefix + " has already been declared on the constructed element."); e[f.prefix || ""] = f.uri; return e }, {}); this.K = b; this.la = d; this.A = void 0 } v(fk, H);
+			fk.prototype.h = function (a, b) {
+				var c = this, d = !1, e, f, g = !1, k, l, m, q = !1; return C.create({
+					next: function () {
+						if (q) return x; d || (e || (e = Pc(c.K.map(function (J) { return I(J, a, b) }))), f = e.O(), d = !0); if (!g) { k || (k = c.la.map(function (J) { return I(J, a, b) })); for (var u = [], z = 0; z < k.length; z++) { var A = k[z].O(); u.push(A) } l = u; g = !0 } c.s && (m || (u = c.s.h(a, b), m = Uj(c.A, b, u)), u = m.next(0), c.l = u.value.value); if ("xmlns" === c.l.prefix || "http://www.w3.org/2000/xmlns/" === c.l.namespaceURI || "xml" === c.l.prefix && "http://www.w3.org/XML/1998/namespace" !==
+							c.l.namespaceURI || c.l.prefix && "xml" !== c.l.prefix && "http://www.w3.org/XML/1998/namespace" === c.l.namespaceURI) throw Error('XQDY0096: The node name "' + c.l.Ca() + '" is invalid for a computed element constructor.'); var D = { nodeType: 1, Ta: !0, attributes: [], childNodes: [], nodeName: c.l.Ca(), namespaceURI: c.l.namespaceURI, prefix: c.l.prefix, localName: c.l.localName }; u = { node: D, F: null }; f.forEach(function (J) { D.attributes.push(J.value.node) }); z = Mj(l, b, Bg); z.attributes.forEach(function (J) {
+								if (D.attributes.find(function (T) {
+									return T.namespaceURI ===
+										J.namespaceURI && T.localName === J.localName
+								})) throw Error("XQDY0025: The attribute " + J.name + " does not have an unique name in the constructed element."); D.attributes.push(J)
+							}); z.Xa.forEach(function (J) { D.childNodes.push(J) }); for (z = 0; z < D.childNodes.length; z++)if (A = D.childNodes[z], Kb(A) && 3 === A.nodeType) { var F = D.childNodes[z - 1]; F && Kb(F) && 3 === F.nodeType && (F.data += A.data, D.childNodes.splice(z, 1), z--) } q = !0; return y($b(u))
+					}
+				})
+			};
+			fk.prototype.v = function (a) {
+				var b = this; Mg(a); Object.keys(this.S).forEach(function (d) { return Pg(a, d, b.S[d]) }); this.ta.forEach(function (d) { return d.v(a) }); this.K.reduce(function (d, e) { if (e.name) { e = "Q{" + (null === e.name.namespaceURI ? a.aa(e.name.prefix) : e.name.namespaceURI) + "}" + e.name.localName; if (d.includes(e)) throw Error("XQST0040: The attribute " + e + " does not have an unique name in the constructed element."); d.push(e) } return d }, []); if (this.l && null === this.l.namespaceURI) {
+					var c = a.aa(this.l.prefix); if (void 0 ===
+						c && this.l.prefix) throw Uc(this.l.prefix); this.l.namespaceURI = c
+				} this.A = Of(a); Sg(a)
+			}; function gk(a) { if (/^xml$/i.test(a)) throw Error('XQDY0064: The target of a created PI may not be "' + a + '"'); } function hk(a, b) { return { node: { data: b, Ta: !0, nodeName: a, nodeType: 7, target: a }, F: null } } function ik(a, b) { var c = a.Fb ? [a.Fb].concat(b) : [b]; H.call(this, c.reduce(function (d, e) { return d.add(e.o) }, new Hf({})), c, { C: !1, R: "unsorted" }); this.l = a; this.s = b } v(ik, H);
+			ik.prototype.h = function (a, b) { var c = this, d = I(this.s, a, b); return Zc(d, b).M(function (e) { var f = e.map(function (k) { return Pd(k, 1).value }).join(" "); if (-1 !== f.indexOf("?>")) throw Error('XQDY0026: The contents of the data of a processing instruction may not include "?>"'); if (null !== c.l.Nb) return e = c.l.Nb, gk(e), C.m($b(hk(e, f))); e = I(c.l.Fb, a, b); var g = Tj(b, e); return C.create({ next: function () { var k = g.next(0); if (k.done) return k; k = k.value.value; gk(k); return y($b(hk(k, f))) } }) }) }; function jk(a) { H.call(this, a ? a.o : new Hf({}), a ? [a] : [], { C: !1, R: "unsorted" }); this.l = a } v(jk, H); jk.prototype.h = function (a, b) { if (!this.l) return C.empty(); a = I(this.l, a, b); return Zc(a, b).M(function (c) { if (0 === c.length) return C.empty(); c = { node: { data: c.map(function (d) { return Pd(d, 1).value }).join(" "), Ta: !0, nodeType: 3 }, F: null }; return C.m($b(c)) }) }; function kk(a, b, c, d) { var e = new Hf({}), f; Df.call(this, e, (f = [a].concat(t(b.map(function (g) { return g.ic })), [c])).concat.apply(f, t(b.map(function (g) { return g.Pb.map(function (k) { return k.Ob }) }))), { C: !1, X: !1, R: "unsorted", subtree: !1 }, d); this.K = a; this.l = b.length; this.S = b.map(function (g) { return g.Pb }) } v(kk, Df);
+			kk.prototype.A = function (a, b, c) { var d = this; return c[0](a).M(function (e) { for (var f = 0; f < d.l; f++)if (d.S[f].some(function (g) { switch (g.oc) { case "?": if (1 < e.length) return !1; break; case "*": break; case "+": if (1 > e.length) return !1; break; default: if (1 !== e.length) return !1 }var k = C.create(e); return e.every(function (l, m) { l = Jc(a, m, l, k); return I(g.Ob, l, b).ha() }) })) return c[f + 1](a); return c[d.l + 1](a) }) }; kk.prototype.v = function (a) { Df.prototype.v.call(this, a); if (this.K.I) throw af(); }; var lk = { $: !1, ua: !1 }, mk = { $: !0, ua: !1 }, nk = { $: !0, ua: !0 }; function ok(a) { return a.$ ? a.ua ? nk : mk : lk }
+			function R(a, b) {
+				switch (a[0]) {
+					case "andOp": var c = M(a, "type"); return new wi(pk("andOp", a, ok(b)), c); case "orOp": return c = M(a, "type"), new xi(pk("orOp", a, ok(b)), c); case "unaryPlusOp": return c = L(L(a, "operand"), "*"), a = M(a, "type"), new vi("+", R(c, b), a); case "unaryMinusOp": return c = L(L(a, "operand"), "*"), a = M(a, "type"), new vi("-", R(c, b), a); case "addOp": case "subtractOp": case "multiplyOp": case "divOp": case "idivOp": case "modOp": var d = a[0], e = R(N(a, ["firstOperand", "*"]), ok(b)); b = R(N(a, ["secondOperand", "*"]), ok(b));
+						var f = M(a, "type"), g = M(N(a, ["firstOperand", "*"]), "type"), k = M(N(a, ["secondOperand", "*"]), "type"); g && k && M(a, "type") && (c = dh(d, g.type, k.type)); return new mh(d, e, b, f, c); case "sequenceExpr": return qk(a, b); case "unionOp": return c = M(a, "type"), new bj([R(N(a, ["firstOperand", "*"]), ok(b)), R(N(a, ["secondOperand", "*"]), ok(b))], c); case "exceptOp": case "intersectOp": return c = M(a, "type"), new Si(a[0], R(N(a, ["firstOperand", "*"]), ok(b)), R(N(a, ["secondOperand", "*"]), ok(b)), c); case "stringConcatenateOp": return rk(a, b);
+					case "rangeSequenceExpr": return sk(a, b); case "equalOp": case "notEqualOp": case "lessThanOrEqualOp": case "lessThanOp": case "greaterThanOrEqualOp": case "greaterThanOp": return tk("generalCompare", a, b); case "eqOp": case "neOp": case "ltOp": case "leOp": case "gtOp": case "geOp": return tk("valueCompare", a, b); case "isOp": case "nodeBeforeOp": case "nodeAfterOp": return tk("nodeCompare", a, b); case "pathExpr": return uk(a, b); case "contextItemExpr": return new gj(M(a, "type")); case "functionCallExpr": return vk(a, b); case "inlineFunctionExpr": return wk(a,
+						b); case "arrowExpr": return xk(a, b); case "dynamicFunctionInvocationExpr": return yk(a, b); case "namedFunctionRef": return b = L(a, "functionName"), c = M(a, "type"), a = Tg(N(a, ["integerConstantExpr", "value"])), new si(Ug(b), parseInt(a, 10), c); case "integerConstantExpr": return new qi(Tg(L(a, "value")), { type: 5, g: 3 }); case "stringConstantExpr": return new qi(Tg(L(a, "value")), { type: 1, g: 3 }); case "decimalConstantExpr": return new qi(Tg(L(a, "value")), { type: 4, g: 3 }); case "doubleConstantExpr": return new qi(Tg(L(a, "value")), {
+							type: 3,
+							g: 3
+						}); case "varRef": return a = Ug(L(a, "name")), new uj(a.prefix, a.namespaceURI, a.localName); case "flworExpr": return zk(a, b); case "quantifiedExpr": return Ak(a, b); case "ifThenElseExpr": return c = M(a, "type"), new hi(R(L(L(a, "ifClause"), "*"), ok(b)), R(L(L(a, "thenClause"), "*"), b), R(L(L(a, "elseClause"), "*"), b), c); case "instanceOfExpr": return c = R(N(a, ["argExpr", "*"]), b), d = N(a, ["sequenceType", "*"]), e = N(a, ["sequenceType", "occurrenceIndicator"]), a = M(a, "type"), new Yi(c, R(d, ok(b)), e ? Tg(e) : "", a); case "castExpr": return b =
+							R(L(L(a, "argExpr"), "*"), ok(b)), c = L(a, "singleType"), a = Ug(L(c, "atomicType")), c = null !== L(c, "optional"), new Wi(b, a, c); case "castableExpr": return b = R(L(L(a, "argExpr"), "*"), ok(b)), c = L(a, "singleType"), a = Ug(L(c, "atomicType")), c = null !== L(c, "optional"), new Vi(b, a, c); case "simpleMapExpr": return Bk(a, b); case "mapConstructor": return Ck(a, b); case "arrayConstructor": return Dk(a, b); case "unaryLookup": return c = M(a, "type"), new nj(Ek(a, b), c); case "typeswitchExpr": return Fk(a, b); case "elementConstructor": return Gk(a,
+								b); case "attributeConstructor": return Hk(a, b); case "computedAttributeConstructor": return (c = L(a, "tagName")) ? c = Ug(c) : (c = L(a, "tagNameExpr"), c = { Oa: R(L(c, "*"), ok(b)) }), a = R(L(L(a, "valueExpr"), "*"), ok(b)), new dk(c, { wb: [a] }); case "computedCommentConstructor": if (!b.$) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context"); a = (a = L(a, "argExpr")) ? R(L(a, "*"), ok(b)) : null; return new ek(a); case "computedTextConstructor": if (!b.$) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context");
+						a = (a = L(a, "argExpr")) ? R(L(a, "*"), ok(b)) : null; return new jk(a); case "computedElementConstructor": return Ik(a, b); case "computedPIConstructor": if (!b.$) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context"); c = L(a, "piTargetExpr"); d = L(a, "piTarget"); e = L(a, "piValueExpr"); a = M(a, "type"); return new ik({ Fb: c ? R(L(c, "*"), ok(b)) : null, Nb: d ? Tg(d) : null }, e ? R(L(e, "*"), ok(b)) : new Ti([], a)); case "CDataSection": return new qi(Tg(a), { type: 1, g: 3 }); case "deleteExpr": return a = R(N(a, ["targetExpr",
+							"*"]), b), new Kj(a); case "insertExpr": c = R(N(a, ["sourceExpr", "*"]), b); e = O(a, "*")[1]; switch (e[0]) { case "insertAfter": d = 1; break; case "insertBefore": d = 2; break; case "insertInto": d = (d = L(e, "*")) ? "insertAsFirst" === d[0] ? 4 : 5 : 3 }a = R(N(a, ["targetExpr", "*"]), b); return new Oj(c, d, a); case "renameExpr": return c = R(N(a, ["targetExpr", "*"]), b), a = R(N(a, ["newNameExpr", "*"]), b), new Vj(c, a); case "replaceExpr": return c = !!L(a, "replaceValue"), d = R(N(a, ["targetExpr", "*"]), b), a = R(N(a, ["replacementExpr", "*"]), b), new Yj(c, d, a); case "transformExpr": return Jk(a,
+								b); case "x:stackTrace": c = a[1]; for (a = a[2]; "x:stackTrace" === a[0];)a = a[2]; return new ji(c, a[0], R(a, b)); default: return Kk(a)
+				}
+			}
+			function Kk(a) {
+				switch (a[0]) {
+					case "nameTest": return new rj(Ug(a)); case "piTest": return (a = L(a, "piTarget")) ? new sj(Tg(a)) : new qj(7); case "commentTest": return new qj(8); case "textTest": return new qj(3); case "documentTest": return new qj(9); case "attributeTest": var b = (a = L(a, "attributeName")) && L(a, "star"); return !a || b ? new qj(2) : new rj(Ug(L(a, "QName")), { kind: 2 }); case "elementTest": return b = (a = L(a, "elementName")) && L(a, "star"), !a || b ? new qj(1) : new rj(Ug(L(a, "QName")), { kind: 1 }); case "anyKindTest": return new tj({
+						prefix: "",
+						namespaceURI: null, localName: "node()"
+					}); case "anyMapTest": return new tj({ prefix: "", namespaceURI: null, localName: "map(*)" }); case "anyArrayTest": return new tj({ prefix: "", namespaceURI: null, localName: "array(*)" }); case "Wildcard": return L(a, "star") ? (b = L(a, "uri")) ? a = new rj({ localName: "*", namespaceURI: Tg(b), prefix: "" }) : (b = L(a, "NCName"), a = "star" === L(a, "*")[0] ? new rj({ localName: Tg(b), namespaceURI: null, prefix: "*" }) : new rj({ localName: "*", namespaceURI: null, prefix: Tg(b) })) : a = new rj({
+						localName: "*", namespaceURI: null,
+						prefix: "*"
+					}), a; case "atomicType": return new tj(Ug(a)); case "anyItemType": return new tj({ prefix: "", namespaceURI: null, localName: "item()" }); default: throw Error("No selector counterpart for: " + a[0] + ".");
+				}
+			} function Dk(a, b) { var c = M(a, "type"); a = L(a, "*"); var d = O(a, "arrayElem").map(function (e) { return R(L(e, "*"), ok(b)) }); switch (a[0]) { case "curlyArray": return new Kh(d, c); case "squareArray": return new Lh(d, c); default: throw Error("Unrecognized arrayType: " + a[0]); } }
+			function Ck(a, b) { var c = M(a, "type"); return new ri(O(a, "mapConstructorEntry").map(function (d) { return { key: R(N(d, ["mapKeyExpr", "*"]), ok(b)), value: R(N(d, ["mapValueExpr", "*"]), ok(b)) } }), c) } function pk(a, b, c) { function d(f) { var g = L(L(f, "firstOperand"), "*"); f = L(L(f, "secondOperand"), "*"); g[0] === a ? d(g) : e.push(R(g, c)); f[0] === a ? d(f) : e.push(R(f, c)) } var e = []; d(b); return e } function Ek(a, b) { a = L(a, "*"); switch (a[0]) { case "NCName": return new qi(Tg(a), { type: 1, g: 3 }); case "star": return "*"; default: return R(a, ok(b)) } }
+			function tk(a, b, c) { var d = N(b, ["firstOperand", "*"]), e = N(b, ["secondOperand", "*"]); d = R(d, ok(c)); c = R(e, ok(c)); switch (a) { case "valueCompare": return new Ji(b[0], d, c); case "nodeCompare": return new Qi(b[0], d, c); case "generalCompare": return new Ni(b[0], d, c) } }
+			function Lk(a, b, c) { a = O(a, "*"); return new ej(a.filter(function (d) { return "stable" !== d[0] }).map(function (d) { var e = L(d, "orderModifier"), f = e ? L(e, "orderingKind") : null; e = e ? L(e, "emptyOrderingMode") : null; f = f ? "ascending" === Tg(f) : !0; e = e ? "empty least" === Tg(e) : !0; return { ca: R(N(d, ["orderByExpr", "*"]), b), Kb: f, lc: e } }), c) }
+			function zk(a, b) {
+				var c = O(a, "*"); a = L(c[c.length - 1], "*"); c = c.slice(0, -1); if (1 < c.length && !b.$) throw Error("XPST0003: Use of XQuery FLWOR expressions in XPath is no allowed"); return c.reduceRight(function (d, e) {
+					switch (e[0]) {
+						case "forClause": e = O(e, "*"); for (var f = e.length - 1; 0 <= f; --f) { var g = e[f], k = N(g, ["forExpr", "*"]), l = L(g, "positionalVariableBinding"); d = new ni(Ug(N(g, ["typedVariableBinding", "varName"])), R(k, ok(b)), l ? Ug(l) : null, d) } return d; case "letClause": e = O(e, "*"); for (f = e.length - 1; 0 <= f; --f)g = e[f], k = N(g,
+							["letExpr", "*"]), d = new pi(Ug(N(g, ["typedVariableBinding", "varName"])), R(k, ok(b)), d); return d; case "whereClause": e = O(e, "*"); for (f = e.length - 1; 0 <= f; --f)d = new vj(R(e[f], b), d); return d; case "windowClause": throw Error("Not implemented: " + e[0] + " is not implemented yet."); case "groupByClause": throw Error("Not implemented: " + e[0] + " is not implemented yet."); case "orderByClause": return Lk(e, b, d); case "countClause": throw Error("Not implemented: " + e[0] + " is not implemented yet."); default: throw Error("Not implemented: " +
+								e[0] + " is not supported in a flwor expression");
+					}
+				}, R(a, b))
+			} function vk(a, b) { var c = L(a, "functionName"), d = O(L(a, "arguments"), "*"); a = M(a, "type"); return new Nf(new si(Ug(c), d.length, a), d.map(function (e) { return "argumentPlaceholder" === e[0] ? null : R(e, b) }), a) }
+			function xk(a, b) { var c = M(a, "type"), d = N(a, ["argExpr", "*"]); a = O(a, "*").slice(1); d = [R(d, b)]; for (var e = 0; e < a.length; e++)if ("arguments" !== a[e][0]) { if ("arguments" === a[e + 1][0]) { var f = O(a[e + 1], "*"); d = d.concat(f.map(function (g) { return "argumentPlaceholder" === g[0] ? null : R(g, b) })) } f = "EQName" === a[e][0] ? new si(Ug(a[e]), d.length, c) : R(a[e], ok(b)); d = [new Nf(f, d, c)] } return d[0] }
+			function yk(a, b) { var c = N(a, ["functionItem", "*"]), d = M(a, "type"); a = L(a, "arguments"); var e = []; a && (e = O(a, "*").map(function (f) { return "argumentPlaceholder" === f[0] ? null : R(f, b) })); return new Nf(R(c, b), e, d) } function wk(a, b) { var c = O(L(a, "paramList"), "*"), d = N(a, ["functionBody", "*"]), e = M(a, "type"); return new oi(c.map(function (f) { return { name: Ug(L(f, "varName")), type: Vg(f) } }), Vg(a), d ? R(d, b) : new Ti([], e)) }
+			function uk(a, b) {
+				var c = M(a, "type"), d = O(a, "stepExpr"), e = !1, f = d.map(function (g) {
+					var k = L(g, "xpathAxis"), l = O(g, "*"), m = [], q = null; l = p(l); for (var u = l.next(); !u.done; u = l.next())switch (u = u.value, u[0]) { case "lookup": m.push(["lookup", Ek(u, b)]); break; case "predicate": case "predicates": u = p(O(u, "*")); for (var z = u.next(); !z.done; z = u.next())z = R(z.value, ok(b)), q = Qh(q, z.B()), m.push(["predicate", z]) }if (k) switch (e = !0, g = L(g, "attributeTest anyElementTest piTest documentTest elementTest commentTest namespaceTest anyKindTest textTest anyFunctionTest typedFunctionTest schemaAttributeTest atomicType anyItemType parenthesizedItemType typedMapTest typedArrayTest nameTest Wildcard".split(" ")),
+						g = Kk(g), Tg(k)) { case "ancestor": var A = new Oh(g, { Ra: !1 }); break; case "ancestor-or-self": A = new Oh(g, { Ra: !0 }); break; case "attribute": A = new Rh(g, q); break; case "child": A = new Sh(g, q); break; case "descendant": A = new Vh(g, { Ra: !1 }); break; case "descendant-or-self": A = new Vh(g, { Ra: !0 }); break; case "parent": A = new bi(g, q); break; case "following-sibling": A = new ai(g, q); break; case "preceding-sibling": A = new fi(g, q); break; case "following": A = new Zh(g); break; case "preceding": A = new di(g); break; case "self": A = new gi(g, q) } else A =
+							N(g, ["filterExpr", "*"]), A = R(A, ok(b)); m = p(m); for (k = m.next(); !k.done; k = m.next())switch (k = k.value, k[0]) { case "lookup": A = new mj(A, k[1]); break; case "predicate": A = new jj(A, k[1]) }A.type = c; return A
+				}); a = L(a, "rootExpr"); d = e || null !== a || 1 < d.length; if (!d && 1 === f.length || !a && 1 === f.length && "sorted" === f[0].da) return f[0]; if (a && 0 === f.length) return new fj(null); f = new ij(f, d); return a ? new fj(f) : f
+			}
+			function Ak(a, b) { var c = M(a, "type"), d = Tg(L(a, "quantifier")), e = N(a, ["predicateExpr", "*"]); a = O(a, "quantifiedExprInClause").map(function (f) { var g = Ug(N(f, ["typedVariableBinding", "varName"])); f = N(f, ["sourceExpr", "*"]); return { name: g, jb: R(f, ok(b)) } }); return new oj(d, a, R(e, ok(b)), c) } function qk(a, b) { var c = O(a, "*").map(function (d) { return R(d, b) }); if (1 === c.length) return c[0]; c = M(a, "type"); return new Ti(O(a, "*").map(function (d) { return R(d, b) }), c) }
+			function Bk(a, b) { var c = M(a, "type"); return O(a, "*").reduce(function (d, e) { return null === d ? R(e, ok(b)) : new Ui(d, R(e, ok(b)), c) }, null) } function rk(a, b) { var c = M(a, "type"); a = [N(a, ["firstOperand", "*"]), N(a, ["secondOperand", "*"])]; return new Nf(new si({ localName: "concat", namespaceURI: "http://www.w3.org/2005/xpath-functions", prefix: "" }, a.length, c), a.map(function (d) { return R(d, ok(b)) }), c) }
+			function sk(a, b) { var c = M(a, "type"); a = [L(L(a, "startExpr"), "*"), L(L(a, "endExpr"), "*")]; var d = new si({ localName: "to", namespaceURI: "http://fontoxpath/operators", prefix: "" }, a.length, c); return new Nf(d, a.map(function (e) { return R(e, ok(b)) }), c) }
+			function Gk(a, b) { if (!b.$) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context"); var c = Ug(L(a, "tagName")), d = L(a, "attributeList"), e = d ? O(d, "attributeConstructor").map(function (f) { return R(f, ok(b)) }) : []; d = d ? O(d, "namespaceDeclaration").map(function (f) { var g = L(f, "prefix"); return { prefix: g ? Tg(g) : "", uri: Tg(L(f, "uri")) } }) : []; a = (a = L(a, "elementContent")) ? O(a, "*").map(function (f) { return R(f, ok(b)) }) : []; return new fk(c, e, d, a) }
+			function Hk(a, b) { if (!b.$) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context"); var c = Ug(L(a, "attributeName")), d = L(a, "attributeValue"); d = d ? Tg(d) : null; a = (a = L(a, "attributeValueExpr")) ? O(a, "*").map(function (e) { return R(e, ok(b)) }) : null; return new dk(c, { value: d, wb: a }) } function Ik(a, b) { var c = L(a, "tagName"); c ? c = Ug(c) : (c = L(a, "tagNameExpr"), c = { Oa: R(L(c, "*"), ok(b)) }); a = (a = L(a, "contentExpr")) ? O(a, "*").map(function (d) { return R(d, ok(b)) }) : []; return new fk(c, [], [], a) }
+			function Jk(a, b) { var c = O(L(a, "transformCopies"), "transformCopy").map(function (e) { var f = Ug(L(L(e, "varRef"), "name")); return { jb: R(L(L(e, "copySource"), "*"), b), Rb: new zb(f.prefix, f.namespaceURI, f.localName) } }), d = R(L(L(a, "modifyExpr"), "*"), b); a = R(L(L(a, "returnExpr"), "*"), b); return new bk(c, d, a) }
+			function Fk(a, b) {
+				if (!b.$) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context"); var c = M(a, "type"), d = R(L(L(a, "argExpr"), "*"), b), e = O(a, "typeswitchExprCaseClause").map(function (f) { var g = 0 === O(f, "sequenceTypeUnion").length ? [L(f, "sequenceType")] : O(L(f, "sequenceTypeUnion"), "sequenceType"); return { ic: R(N(f, ["resultExpr", "*"]), b), Pb: g.map(function (k) { var l = L(k, "occurrenceIndicator"); return { oc: l ? Tg(l) : "", Ob: R(L(k, "*"), b) } }) } }); a = R(N(a, ["typeswitchExprDefaultClause", "resultExpr",
+					"*"]), b); return new kk(d, e, a, c)
+			} function Mk(a, b) { return R(a, b) }; var Nk = new Map; function Ok(a, b, c, d, e, f) { this.B = a; this.l = b; this.h = c; this.v = d; this.o = e; this.s = f }
+			function Pk(a, b, c, d, e, f, g, k) { a = Nk.get(a); if (!a) return null; b = a[b + (f ? "_DEBUG" : "")]; return b ? (b = b.find(function (l) { return l.o === g && l.B.every(function (m) { return c(m.prefix) === m.namespaceURI }) && l.l.every(function (m) { return void 0 !== d[m.name] }) && l.v.every(function (m) { return e[m.prefix] === m.namespaceURI }) && l.s.every(function (m) { var q = k(m.nc, m.arity); return q && q.namespaceURI === m.Lb.namespaceURI && q.localName === m.Lb.localName }) })) ? { ca: b.h, rc: !1 } : null : null }
+			function Qk(a, b, c, d, e, f, g) { var k = Nk.get(a); k || (k = Object.create(null), Nk.set(a, k)); a = b + (f ? "_DEBUG" : ""); (b = k[a]) || (b = k[a] = []); b.push(new Ok(Object.values(c.h), Object.values(c.o), e, Object.keys(d).map(function (l) { return { namespaceURI: d[l], prefix: l } }), g, c.B)) }; function Rk(a) {
+				var b = new Gb; if ("http://www.w3.org/2005/XQueryX" !== a.namespaceURI && "http://www.w3.org/2005/XQueryX" !== a.namespaceURI && "http://fontoxml.com/fontoxpath" !== a.namespaceURI && "http://www.w3.org/2007/xquery-update-10" !== a.namespaceURI) throw Sc("The XML structure passed as an XQueryX program was not valid XQueryX"); var c = ["stackTrace" === a.localName ? "x:stackTrace" : a.localName], d = b.getAllAttributes(a); d && 0 < d.length && c.push(Array.from(d).reduce(function (e, f) {
+					"start" === f.localName || "end" === f.localName &&
+						"stackTrace" === a.localName ? e[f.localName] = JSON.parse(f.value) : "type" === f.localName ? e[f.localName] = qb(f.value) : e[f.localName] = f.value; return e
+				}, {})); b = b.getChildNodes(a); b = p(b); for (d = b.next(); !d.done; d = b.next())switch (d = d.value, d.nodeType) { case 1: c.push(Rk(d)); break; case 3: c.push(d.data) }return c
+			}; var Sk = Object.create(null); function Tk(a, b) { var c = Sk[a]; c || (c = Sk[a] = { Ma: [], Va: [], ra: null, source: b.source }); var d = c.ra || function () { }; c.Ma = c.Ma.concat(b.Ma); c.Va = c.Va.concat(b.Va); c.ra = function (e) { d(e); b.ra && b.ra(e) } } function Uk(a, b) { var c = Sk[b]; if (!c) throw Error("XQST0051: No modules found with the namespace uri " + b); c.Ma.forEach(function (d) { d.hb && Og(a, b, d.localName, d.arity, d) }); c.Va.forEach(function (d) { Qg(a, b, d.localName); Rg(a, b, d.localName, function (e, f) { return I(d.ca, e, f) }) }) }
+			function Vk() { Object.keys(Sk).forEach(function (a) { a = Sk[a]; if (a.ra) try { a.ra(a) } catch (b) { a.ra = null, pg(a.source, b) } a.ra = null }) }; function hl(a) { return a.replace(/(\x0D\x0A)|(\x0D(?!\x0A))/g, String.fromCharCode(10)) }; var S = prsc; function il(a, b) { return function (c, d) { if (b.has(d)) return b.get(d); c = a(c, d); b.set(d, c); return c } } function U(a, b) { return S.delimited(b, a, b) } function V(a, b) { return a.reverse().reduce(function (c, d) { return S.preceded(d, c) }, b) } function jl(a, b, c, d) { return S.then(S.then(a, b, function (e, f) { return [e, f] }), c, function (e, f) { var g = p(e); e = g.next().value; g = g.next().value; return d(e, g, f) }) }
+			function kl(a, b, c, d, e) { return S.then(S.then(S.then(a, b, function (f, g) { return [f, g] }), c, function (f, g) { var k = p(f); f = k.next().value; k = k.next().value; return [f, k, g] }), d, function (f, g) { var k = p(f); f = k.next().value; var l = k.next().value; k = k.next().value; return e(f, l, k, g) }) }
+			function ll(a, b, c, d, e, f) { return S.then(S.then(S.then(S.then(a, b, function (g, k) { return [g, k] }), c, function (g, k) { var l = p(g); g = l.next().value; l = l.next().value; return [g, l, k] }), d, function (g, k) { var l = p(g); g = l.next().value; var m = l.next().value; l = l.next().value; return [g, m, l, k] }), e, function (g, k) { var l = p(g); g = l.next().value; var m = l.next().value, q = l.next().value; l = l.next().value; return f(g, m, q, l, k) }) } function ml(a) { return S.map(a, function (b) { return [b] }) }
+			function nl(a, b) { return S.map(S.or(a), function () { return b }) } function ol(a) { return function (b, c) { return (b = a.exec(b.substring(c))) && 0 === b.index ? S.okWithValue(c + b[0].length, b[0]) : S.error(c, [a.source], !1) } }; var pl = S.or([S.token(" "), S.token("\t"), S.token("\r"), S.token("\n")]), ql = S.token("(:"), rl = S.token(":)"), sl = S.token("(#"), tl = S.token("#)"), ul = S.token("("), vl = S.token(")"), wl = S.token("["), xl = S.token("]"), yl = S.token("{"), zl = S.token("}"), Al = S.token("{{"), Bl = S.token("}}"), Cl = S.token("'"), Dl = S.token("''"), El = S.token('"'), Fl = S.token('""'), Gl = S.token("<![CDATA["), Hl = S.token("]]\x3e"), Il = S.token("/>"), Jl = S.token("</"), Kl = S.token("\x3c!--"), Ll = S.token("--\x3e"), Ml = S.token("<?"), Nl = S.token("?>"), Ol = S.token("&#x"),
+				Pl = S.token("&#"), Ql = S.token(":*"), Rl = S.token("*:"), Sl = S.token(":="), Tl = S.token("&"), Ul = S.token(":"), Vl = S.token(";"), Wl = S.token("*"), Xl = S.token("@"), Yl = S.token("$"), Zl = S.token("#"), $l = S.token("%"), am = S.token("?"), bm = S.token("="), cm = S.followed(S.token("!"), S.not(S.peek(bm), [])), dm = S.followed(S.token("|"), S.not(S.peek(S.token("|")), [])), em = S.token("||"), fm = S.token("!="), gm = S.token("<"), hm = S.token("<<"), im = S.token("<="), jm = S.token(">"), km = S.token(">>"), lm = S.token(">="), mm = S.token(","), nm = S.token("."),
+				om = S.token(".."), pm = S.token("+"), qm = S.token("-"), rm = S.token("/"), sm = S.token("//"), tm = S.token("=>"), um = S.token("e"), vm = S.token("E"); S.token("l"); S.token("L"); S.token("m"); S.token("M"); var wm = S.token("Q"); S.token("x"); S.token("X");
+			var xm = S.token("as"), ym = S.token("cast"), zm = S.token("castable"), Am = S.token("treat"), Bm = S.token("instance"), Cm = S.token("of"), Dm = S.token("node"), Em = S.token("nodes"), Fm = S.token("delete"), Gm = S.token("value"), Hm = S.token("function"), Im = S.token("map"), Jm = S.token("element"), Km = S.token("attribute"), Lm = S.token("schema-element"), Mm = S.token("intersect"), Nm = S.token("except"), Om = S.token("union"), Pm = S.token("to"), Qm = S.token("is"), Rm = S.token("or"), Sm = S.token("and"), Tm = S.token("div"), Um = S.token("idiv"), Vm = S.token("mod"),
+				Wm = S.token("eq"), Xm = S.token("ne"), Ym = S.token("lt"), Zm = S.token("le"), $m = S.token("gt"), an = S.token("ge"), bn = S.token("amp"), cn = S.token("quot"), dn = S.token("apos"), en = S.token("if"), fn = S.token("then"), gn = S.token("else"), hn = S.token("allowing"), jn = S.token("empty"), kn = S.token("at"), ln = S.token("in"), mn = S.token("for"), nn = S.token("let"), on = S.token("where"), pn = S.token("collation"), qn = S.token("group"), rn = S.token("by"), sn = S.token("order"), tn = S.token("stable"), un = S.token("return"), vn = S.token("array"), wn = S.token("document"),
+				xn = S.token("namespace"), yn = S.token("text"), zn = S.token("comment"), An = S.token("processing-instruction"), Bn = S.token("lax"), Cn = S.token("strict"), Dn = S.token("validate"), En = S.token("type"), Fn = S.token("declare"), Gn = S.token("default"), Hn = S.token("boundary-space"), In = S.token("strip"), Jn = S.token("preserve"), Kn = S.token("no-preserve"), Ln = S.token("inherit"), Mn = S.token("no-inherit"), Nn = S.token("greatest"), On = S.token("least"), Pn = S.token("copy-namespaces"), Qn = S.token("decimal-format"), Rn = S.token("case"), Sn = S.token("typeswitch"),
+				Tn = S.token("some"), Un = S.token("every"), Vn = S.token("satisfies"), Wn = S.token("replace"), Xn = S.token("with"), Yn = S.token("copy"), Zn = S.token("modify"), $n = S.token("first"), ao = S.token("last"), bo = S.token("before"), co = S.token("after"), eo = S.token("into"), fo = S.token("insert"), go = S.token("rename"), ho = S.token("switch"), io = S.token("variable"), jo = S.token("external"), ko = S.token("updating"), lo = S.token("import"), mo = S.token("schema"), no = S.token("module"), oo = S.token("base-uri"), po = S.token("construction"), qo = S.token("ordering"),
+				ro = S.token("ordered"), so = S.token("unordered"), to = S.token("option"), uo = S.token("context"), vo = S.token("item"), wo = S.token("xquery"), xo = S.token("version"), yo = S.token("encoding"), zo = S.token("document-node"), Ao = S.token("namespace-node"), Bo = S.token("schema-attribute"), Co = S.token("ascending"), Do = S.token("descending"), Eo = S.token("empty-sequence"), Fo = S.token("child::"), Go = S.token("descendant::"), Ho = S.token("attribute::"), Io = S.token("self::"), Jo = S.token("descendant-or-self::"), Ko = S.token("following-sibling::"),
+				Lo = S.token("following::"), Mo = S.token("parent::"), No = S.token("ancestor::"), Oo = S.token("preceding-sibling::"), Po = S.token("preceding::"), Qo = S.token("ancestor-or-self::"), Ro = S.token("decimal-separator"), So = S.token("grouping-separator"), To = S.token("infinity"), Uo = S.token("minus-sign"), Vo = S.token("NaN"), Wo = S.token("per-mille"), Xo = S.token("zero-digit"), Yo = S.token("digit"), Zo = S.token("pattern-separator"), $o = S.token("exponent-separator"), ap = S.token("schema-attribute("), bp = S.token("document-node("), cp = S.token("processing-instruction("),
+				dp = S.token("processing-instruction()"), ep = S.token("comment()"), fp = S.token("text()"), gp = S.token("namespace-node()"), hp = S.token("node()"), ip = S.token("item()"), jp = S.token("empty-sequence()"); var kp = new Map, lp = new Map, mp = S.or([ol(/[\t\n\r -\uD7FF\uE000\uFFFD]/), ol(/[\uD800-\uDBFF][\uDC00-\uDFFF]/)]), np = S.preceded(S.peek(S.not(S.or([ql, rl]), ['comment contents cannot contain "(:" or ":)"'])), mp), op = S.map(S.delimited(ql, S.star(S.or([np, function (a, b) { return op(a, b) }])), rl, !0), function (a) { return a.join("") }), pp = S.or([pl, op]), qp = S.map(S.plus(pl), function (a) { return a.join("") }), W = il(S.map(S.star(pp), function (a) { return a.join("") }), kp), X = il(S.map(S.plus(pp), function (a) { return a.join("") }), lp); var rp = S.or([ol(/[A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/), S.then(ol(/[\uD800-\uDB7F]/), ol(/[\uDC00-\uDFFF]/), function (a, b) { return a + b })]), sp = S.or([rp, ol(/[\-\.0-9\xB7\u0300-\u036F\u203F\u2040]/)]), tp = S.then(rp, S.star(sp), function (a, b) { return a + b.join("") }), up = S.map(tp, function (a) { return ["prefix", a] }), vp = S.or([rp, Ul]), wp = S.or([sp, Ul]); S.then(vp, S.star(wp), function (a, b) { return a + b.join("") });
+			var xp = S.map(tp, function (a) { var b = {}; return [(b.prefix = "", b.URI = null, b), a] }), yp = S.then(tp, S.preceded(Ul, tp), function (a, b) { var c = {}; return [(c.prefix = a, c.URI = null, c), b] }), zp = S.or([yp, xp]), Ap = S.followed(V([wm, W, yl], S.map(S.star(ol(/[^{}]/)), function (a) { return a.join("").replace(/\s+/g, " ").trim() })), zl), Bp = S.then(Ap, tp, function (a, b) { return [a, b] }), Cp = S.or([S.map(Bp, function (a) { var b = {}; return [(b.prefix = null, b.URI = a[0], b), a[1]] }), zp]), Dp = S.or([S.map(Cp, function (a) { return ["QName"].concat(t(a)) }), S.map(Wl,
+				function () { return ["star"] })]), Ep = S.map(S.preceded(Yl, Cp), function (a) { return ["varRef", ["name"].concat(t(a))] }); var Fp = S.peek(S.or([ul, El, Cl, pp])), Gp = S.map(S.or([Fo, Go, Ho, Io, Jo, Ko, Lo]), function (a) { return a.substring(0, a.length - 2) }), Hp = S.map(S.or([Mo, No, Oo, Po, Qo]), function (a) { return a.substring(0, a.length - 2) }), Ip = jl(Tl, S.or([Ym, $m, bn, cn, dn]), Vl, function (a, b, c) { return a + b + c }), Jp = S.or([jl(Ol, ol(/[0-9a-fA-F]+/), Vl, function (a, b, c) { return a + b + c }), jl(Pl, ol(/[0-9]+/), Vl, function (a, b, c) { return a + b + c })]), Kp = nl([Fl], '"'), Lp = nl([Dl], "'"), Mp = ml(nl([ep], "commentTest")), Np = ml(nl([fp], "textTest")), Op = ml(nl([gp], "namespaceTest")),
+					Pp = ml(nl([hp], "anyKindTest")), Qp = ol(/[0-9]+/), Rp = S.then(S.or([S.then(nm, Qp, function (a, b) { return a + b }), S.then(Qp, S.optional(S.preceded(nm, ol(/[0-9]*/))), function (a, b) { return a + (null !== b ? "." + b : "") })]), jl(S.or([um, vm]), S.optional(S.or([pm, qm])), Qp, function (a, b, c) { return a + (b ? b : "") + c }), function (a, b) { return ["doubleConstantExpr", ["value", a + b]] }), Sp = S.or([S.map(S.preceded(nm, Qp), function (a) { return ["decimalConstantExpr", ["value", "." + a]] }), S.then(S.followed(Qp, nm), S.optional(Qp), function (a, b) {
+						return ["decimalConstantExpr",
+							["value", a + "." + (null !== b ? b : "")]]
+					})]), Tp = S.map(Qp, function (a) { return ["integerConstantExpr", ["value", a]] }), Up = S.followed(S.or([Rp, Sp, Tp]), S.peek(S.not(ol(/[a-zA-Z]/), ["no alphabetical characters after numeric literal"]))), Vp = S.map(S.followed(nm, S.peek(S.not(nm, ["context item should not be followed by another ."]))), function () { return ["contextItemExpr"] }), Wp = S.or([vn, Km, zn, zo, Jm, Eo, Hm, en, vo, Im, Ao, Dm, An, Bo, Lm, ho, yn, Sn]), Xp = ml(nl([am], "argumentPlaceholder")), Yp = S.or([am, Wl, pm]), Zp = S.preceded(S.peek(S.not(ol(/[{}<&]/),
+						["elementContentChar cannot be {, }, <, or &"])), mp), $p = S.map(S.delimited(Gl, S.star(S.preceded(S.peek(S.not(Hl, ['CDataSection content may not contain "]]\x3e"'])), mp)), Hl, !0), function (a) { return ["CDataSection", a.join("")] }), aq = S.preceded(S.peek(S.not(ol(/["{}<&]/), ['quotAttrValueContentChar cannot be ", {, }, <, or &'])), mp), bq = S.preceded(S.peek(S.not(ol(/['{}<&]/), ["aposAttrValueContentChar cannot be ', {, }, <, or &"])), mp), cq = S.map(S.star(S.or([S.preceded(S.peek(S.not(qm, [])), mp), S.map(V([qm, S.peek(S.not(qm,
+							[]))], mp), function (a) { return "-" + a })])), function (a) { return a.join("") }), dq = S.map(S.delimited(Kl, cq, Ll, !0), function (a) { return ["computedCommentConstructor", ["argExpr", ["stringConstantExpr", ["value", a]]]] }), eq = S.filter(tp, function (a) { return "xml" !== a.toLowerCase() }, ['A processing instruction target cannot be "xml"']), fq = S.map(S.star(S.preceded(S.peek(S.not(Nl, [])), mp)), function (a) { return a.join("") }), gq = S.then(S.preceded(Ml, S.cut(eq)), S.cut(S.followed(S.optional(S.preceded(qp, fq)), Nl)), function (a, b) {
+								return ["computedPIConstructor",
+									["piTarget", a], ["piValueExpr", ["stringConstantExpr", ["value", b]]]]
+							}), hq = S.map(sm, function () { return ["stepExpr", ["xpathAxis", "descendant-or-self"], ["anyKindTest"]] }), iq = S.or([Bn, Cn]), jq = S.map(S.star(S.followed(mp, S.peek(S.not(tl, ["Pragma contents should not contain '#)'"])))), function (a) { return a.join("") }), kq = S.map(S.followed(S.or([Wm, Xm, Ym, Zm, $m, an]), Fp), function (a) { return a + "Op" }), lq = S.or([S.followed(nl([Qm], "isOp"), Fp), nl([hm], "nodeBeforeOp"), nl([km], "nodeAfterOp")]), mq = S.or([nl([bm], "equalOp"),
+							nl([fm], "notEqualOp"), nl([im], "lessThanOrEqualOp"), nl([gm], "lessThanOp"), nl([lm], "greaterThanOrEqualOp"), nl([jm], "greaterThanOp")]), nq = S.map(ko, function () { return ["annotation", ["annotationName", "updating"]] }), oq = S.or([Jn, Kn]), pq = S.or([Ln, Mn]), qq = S.or([Ro, So, To, Uo, Vo, $l, Wo, Xo, Yo, Zo, $o]), rq = S.map(V([Fn, X, Hn, X], S.or([Jn, In])), function (a) { return ["boundarySpaceDecl", a] }), sq = S.map(V([Fn, X, po, X], S.or([Jn, In])), function (a) { return ["constructionDecl", a] }), tq = S.map(V([Fn, X, qo, X], S.or([ro, so])), function (a) {
+								return ["orderingModeDecl",
+									a]
+							}), uq = S.map(V([Fn, X, Gn, X, sn, X, jn, X], S.or([Nn, On])), function (a) { return ["emptyOrderDecl", a] }), vq = S.then(V([Fn, X, Pn, X], oq), V([W, mm, W], pq), function (a, b) { return ["copyNamespacesDecl", ["preserveMode", a], ["inheritMode", b]] }); function wq(a) {
+								switch (a[0]) { case "constantExpr": case "varRef": case "contextItemExpr": case "functionCallExpr": case "sequenceExpr": case "elementConstructor": case "computedElementConstructor": case "computedAttributeConstructor": case "computedDocumentConstructor": case "computedTextConstructor": case "computedCommentConstructor": case "computedNamespaceConstructor": case "computedPIConstructor": case "orderedExpr": case "unorderedExpr": case "namedFunctionRef": case "inlineFunctionExpr": case "dynamicFunctionInvocationExpr": case "mapConstructor": case "arrayConstructor": case "stringConstructor": case "unaryLookup": return a }return ["sequenceExpr",
+									a]
+							} function xq(a) { if (!(1 <= a && 55295 >= a || 57344 <= a && 65533 >= a || 65536 <= a && 1114111 >= a)) throw Error("XQST0090: The character reference " + a + " (" + a.toString(16) + ") does not reference a valid codePoint."); }
+			function yq(a) { return a.replace(/(&[^;]+);/g, function (b) { if (/^&#x/.test(b)) return b = parseInt(b.slice(3, -1), 16), xq(b), String.fromCodePoint(b); if (/^&#/.test(b)) return b = parseInt(b.slice(2, -1), 10), xq(b), String.fromCodePoint(b); switch (b) { case "&lt;": return "<"; case "&gt;": return ">"; case "&amp;": return "&"; case "&quot;": return String.fromCharCode(34); case "&apos;": return String.fromCharCode(39) }throw Error('XPST0003: Unknown character reference: "' + b + '"'); }) }
+			function zq(a, b, c) {
+				if (!a.length) return []; for (var d = [a[0]], e = 1; e < a.length; ++e) { var f = d[d.length - 1]; "string" === typeof f && "string" === typeof a[e] ? d[d.length - 1] = f + a[e] : d.push(a[e]) } if ("string" === typeof d[0] && 0 === d.length) return []; d = d.reduce(function (g, k, l) { if ("string" !== typeof k) g.push(k); else if (c && /^\s*$/.test(k)) { var m = d[l + 1]; m && "CDataSection" === m[0] ? g.push(yq(k)) : (l = d[l - 1]) && "CDataSection" === l[0] && g.push(yq(k)) } else g.push(yq(k)); return g }, []); if (!d.length) return d; if (1 < d.length || b) for (a = 0; a < d.length; a++)"string" ===
+					typeof d[a] && (d[a] = ["stringConstantExpr", ["value", d[a]]]); return d
+			} function Aq(a) { return a[0].prefix ? a[0].prefix + ":" + a[1] : a[1] }; var Bq = S.then(Cp, S.optional(am), function (a, b) { return null !== b ? ["singleType", ["atomicType"].concat(t(a)), ["optional"]] : ["singleType", ["atomicType"].concat(t(a))] }), Cq = S.map(Cp, function (a) { return ["atomicType"].concat(t(a)) }); var Dq = new Map;
+			function Eq(a) {
+				function b(n, r) { return r.reduce(function (G, ea) { return [ea[0], ["firstOperand", G], ["secondOperand", ea[1]]] }, n) } function c(n, r, G) { return S.then(n, S.star(S.then(U(r, W), S.cut(n), function (ea, oa) { return [ea, oa] })), G) } function d(n, r, G, ea) { G = void 0 === G ? "firstOperand" : G; ea = void 0 === ea ? "secondOperand" : ea; return S.then(n, S.optional(S.then(U(r, W), S.cut(n), function (oa, Ja) { return [oa, Ja] })), function (oa, Ja) { return null === Ja ? oa : [Ja[0], [G, oa], [ea, Ja[1]]] }) } function e(n) {
+					return a.vb ? function (r, G) {
+						r = n(r,
+							G); if (!r.success) return r; var ea = m.has(G) ? m.get(G) : { offset: G, line: -1, ja: -1 }, oa = m.has(r.offset) ? m.get(r.offset) : { offset: r.offset, line: -1, ja: -1 }; m.set(G, ea); m.set(r.offset, oa); return S.okWithValue(r.offset, ["x:stackTrace", { start: ea, end: oa }, r.value])
+					} : n
+				} function f(n, r) { return Wk(n, r) } function g(n, r) { return hh(n, r) } function k(n, r) { return e(S.or([Yr, Zr, $r, as, bs, cs, ds, es, fs, gs, hs]))(n, r) } function l(n, r) {
+					return c(k, mm, function (G, ea) { return 0 === ea.length ? G : ["sequenceExpr", G].concat(t(ea.map(function (oa) { return oa[1] }))) })(n,
+						r)
+				} var m = new Map, q = S.preceded(wl, S.followed(U(l, W), xl)), u = S.map(a.Ya ? S.or([U(S.star(S.or([Ip, Jp, Kp, ol(/[^"&]/)])), El), U(S.star(S.or([Ip, Jp, Lp, ol(/[^'&]/)])), Cl)]) : S.or([U(S.star(S.or([Kp, ol(/[^"]/)])), El), U(S.star(S.or([Lp, ol(/[^']/)])), Cl)]), function (n) { return n.join("") }), z = S.or([S.map(V([Jm, W], S.delimited(S.followed(ul, W), S.then(Dp, V([W, mm, W], Cp), function (n, r) { return [["elementName", n], ["typeName"].concat(t(r))] }), S.preceded(W, vl))), function (n) {
+					var r = p(n); n = r.next().value; r = r.next().value; return ["elementTest",
+						n, r]
+				}), S.map(V([Jm, W], S.delimited(ul, Dp, vl)), function (n) { return ["elementTest", ["elementName", n]] }), S.map(V([Jm, W], S.delimited(ul, W, vl)), function () { return ["elementTest"] })]), A = S.or([S.map(Cp, function (n) { return ["QName"].concat(t(n)) }), S.map(Wl, function () { return ["star"] })]), D = S.or([S.map(V([Km, W], S.delimited(S.followed(ul, W), S.then(A, V([W, mm, W], Cp), function (n, r) { return [["attributeName", n], ["typeName"].concat(t(r))] }), S.preceded(W, vl))), function (n) {
+					var r = p(n); n = r.next().value; r = r.next().value; return ["attributeTest",
+						n, r]
+				}), S.map(V([Km, W], S.delimited(ul, A, vl)), function (n) { return ["attributeTest", ["attributeName", n]] }), S.map(V([Km, W], S.delimited(ul, W, vl)), function () { return ["attributeTest"] })]), F = S.map(V([Lm, W, ul], S.followed(Cp, vl)), function (n) { return ["schemaElementTest"].concat(t(n)) }), J = S.map(S.delimited(ap, U(Cp, W), vl), function (n) { return ["schemaAttributeTest"].concat(t(n)) }), T = S.map(S.preceded(bp, S.followed(U(S.optional(S.or([z, F])), W), vl)), function (n) { return ["documentTest"].concat(t(n ? [n] : [])) }), ia = S.or([S.map(S.preceded(cp,
+					S.followed(U(S.or([tp, u]), W), vl)), function (n) { return ["piTest", ["piTarget", n]] }), ml(nl([dp], "piTest"))]), Ba = S.or([T, z, D, F, J, ia, Mp, Np, Op, Pp]), Ra = S.or([S.map(S.preceded(Rl, tp), function (n) { return ["Wildcard", ["star"], ["NCName", n]] }), ml(nl([Wl], "Wildcard")), S.map(S.followed(Ap, Wl), function (n) { return ["Wildcard", ["uri", n], ["star"]] }), S.map(S.followed(tp, Ql), function (n) { return ["Wildcard", ["NCName", n], ["star"]] })]), kb = S.or([Ra, S.map(Cp, function (n) { return ["nameTest"].concat(t(n)) })]), Rb = S.or([Ba, kb]), Gd = S.then(S.optional(Xl),
+						Rb, function (n, r) { return null !== n || "attributeTest" === r[0] || "schemaAttributeTest" === r[0] ? ["stepExpr", ["xpathAxis", "attribute"], r] : ["stepExpr", ["xpathAxis", "child"], r] }), is = S.or([S.then(Gp, Rb, function (n, r) { return ["stepExpr", ["xpathAxis", n], r] }), Gd]), js = S.map(om, function () { return ["stepExpr", ["xpathAxis", "parent"], ["anyKindTest"]] }), ks = S.or([S.then(Hp, Rb, function (n, r) { return ["stepExpr", ["xpathAxis", n], r] }), js]), ls = S.map(S.star(S.preceded(W, q)), function (n) {
+							return 0 < n.length ? ["predicates"].concat(t(n)) :
+								void 0
+						}), ms = S.then(S.or([ks, is]), ls, function (n, r) { return void 0 === r ? n : n.concat([r]) }), ih = S.or([Up, S.map(u, function (n) { return ["stringConstantExpr", ["value", a.Ya ? yq(n) : n]] })]), jh = S.or([S.delimited(ul, U(l, W), vl), S.map(S.delimited(ul, W, vl), function () { return ["sequenceExpr"] })]), Xk = S.or([k, Xp]), ef = S.map(S.delimited(ul, U(S.optional(S.then(Xk, S.star(S.preceded(U(mm, W), Xk)), function (n, r) { return [n].concat(t(r)) })), W), vl), function (n) { return null !== n ? n : [] }), ns = S.preceded(S.not(jl(Wp, W, ul, function () { }), ["cannot use reseved keyword for function names"]),
+							S.then(Cp, S.preceded(W, ef), function (n, r) { return ["functionCallExpr", ["functionName"].concat(t(n)), null !== r ? ["arguments"].concat(t(r)) : ["arguments"]] })), os = S.then(Cp, S.preceded(Zl, Tp), function (n, r) { return ["namedFunctionRef", ["functionName"].concat(t(n)), r] }), lb = S.delimited(yl, U(S.optional(l), W), zl), Yk = S.map(lb, function (n) { return n ? n : ["sequenceExpr"] }), Bb = S.or([S.map(jp, function () { return [["voidSequenceType"]] }), S.then(f, S.optional(S.preceded(W, Yp)), function (n, r) {
+								return [n].concat(t(null !== r ? [["occurrenceIndicator",
+									r]] : []))
+							})]), kh = S.then(V([$l, W], Cp), S.optional(S.followed(S.then(V([ul, W], ih), S.star(V([mm, W], ih)), function (n, r) { return n.concat(r) }), vl)), function (n, r) { return ["annotation", ["annotationName"].concat(t(n))].concat(t(r ? ["arguments", r] : [])) }), ps = S.map(V([Hm, W, ul, W, Wl, W], vl), function () { return ["anyFunctionTest"] }), qs = S.then(V([Hm, W, ul, W], S.optional(c(Bb, mm, function (n, r) { return n.concat.apply(n, r.map(function (G) { return G[1] })) }))), V([W, vl, X, xm, X], Bb), function (n, r) {
+								return ["typedFunctionTest", ["paramTypeList",
+									["sequenceType"].concat(t(n ? n : []))], ["sequenceType"].concat(t(r))]
+							}), rs = S.then(S.star(kh), S.or([ps, qs]), function (n, r) { return [r[0]].concat(t(n), t(r.slice(1))) }), ss = S.map(V([Im, W, ul, W, Wl, W], vl), function () { return ["anyMapTest"] }), ts = S.then(V([Im, W, ul, W], Cq), V([W, mm], S.followed(U(Bb, W), vl)), function (n, r) { return ["typedMapTest", n, ["sequenceType"].concat(t(r))] }), us = S.or([ss, ts]), vs = S.map(V([vn, W, ul, W, Wl, W], vl), function () { return ["anyArrayTest"] }), ws = S.map(V([vn, W, ul], S.followed(U(Bb, W), vl)), function (n) {
+								return ["typedArrayTest",
+									["sequenceType"].concat(t(n))]
+							}), xs = S.or([vs, ws]), ys = S.map(S.delimited(ul, U(f, W), vl), function (n) { return ["parenthesizedItemType", n] }), Wk = S.or([Ba, ml(nl([ip], "anyItemType")), rs, us, xs, Cq, ys]), Vc = S.map(V([xm, X], Bb), function (n) { return ["typeDeclaration"].concat(t(n)) }), zs = S.then(S.preceded(Yl, Cp), S.optional(S.preceded(X, Vc)), function (n, r) { return ["param", ["varName"].concat(t(n))].concat(t(r ? [r] : [])) }), Zk = c(zs, mm, function (n, r) { return [n].concat(t(r.map(function (G) { return G[1] }))) }), As = kl(S.star(kh), V([W, Hm,
+								W, ul, W], S.optional(Zk)), V([W, vl, W], S.optional(S.map(V([xm, W], S.followed(Bb, W)), function (n) { return ["typeDeclaration"].concat(t(n)) }))), Yk, function (n, r, G, ea) { return ["inlineFunctionExpr"].concat(t(n), [["paramList"].concat(t(r ? r : []))], t(G ? [G] : []), [["functionBody", ea]]) }), Bs = S.or([os, As]), Cs = S.map(k, function (n) { return ["mapKeyExpr", n] }), Ds = S.map(k, function (n) { return ["mapValueExpr", n] }), Es = S.then(Cs, S.preceded(U(Ul, W), Ds), function (n, r) { return ["mapConstructorEntry", n, r] }), Fs = S.preceded(Im, S.delimited(U(yl,
+									W), S.map(S.optional(c(Es, U(mm, W), function (n, r) { return [n].concat(t(r.map(function (G) { return G[1] }))) })), function (n) { return n ? ["mapConstructor"].concat(t(n)) : ["mapConstructor"] }), S.preceded(W, zl))), Gs = S.map(S.delimited(wl, U(S.optional(c(k, mm, function (n, r) { return [n].concat(t(r.map(function (G) { return G[1] }))).map(function (G) { return ["arrayElem", G] }) })), W), xl), function (n) { return ["squareArray"].concat(t(null !== n ? n : [])) }), Hs = S.map(S.preceded(vn, S.preceded(W, lb)), function (n) {
+										return ["curlyArray"].concat(t(null !==
+											n ? [["arrayElem", n]] : []))
+									}), Is = S.map(S.or([Gs, Hs]), function (n) { return ["arrayConstructor", n] }), $k = S.or([tp, Tp, jh, Wl]), Js = S.map(S.preceded(am, S.preceded(W, $k)), function (n) { return "*" === n ? ["unaryLookup", ["star"]] : "string" === typeof n ? ["unaryLookup", ["NCName", n]] : ["unaryLookup", n] }), lh = S.or([Ip, Jp, nl([Al], "{"), nl([Bl], "}"), S.map(lb, function (n) { return n || ["sequenceExpr"] })]), Ks = S.or([$p, function (n, r) { return al(n, r) }, lh, Zp]), Ls = S.or([S.map(aq, function (n) { return n.replace(/[\x20\x0D\x0A\x09]/g, " ") }), lh]),
+					Ms = S.or([S.map(bq, function (n) { return n.replace(/[\x20\x0D\x0A\x09]/g, " ") }), lh]), Ns = S.map(S.or([U(S.star(S.or([Kp, Ls])), El), U(S.star(S.or([Lp, Ms])), Cl)]), function (n) { return zq(n, !1, !1) }), Os = S.then(zp, S.preceded(U(bm, S.optional(qp)), Ns), function (n, r) {
+						if ("" === n[0].prefix && "xmlns" === n[1]) { if (r.length && "string" !== typeof r[0]) throw Error("XQST0022: A namespace declaration may not contain enclosed expressions"); return ["namespaceDeclaration", r.length ? ["uri", r[0]] : ["uri"]] } if ("xmlns" === n[0].prefix) {
+							if (r.length &&
+								"string" !== typeof r[0]) throw Error("XQST0022: The namespace declaration for 'xmlns:" + n[1] + "' may not contain enclosed expressions"); return ["namespaceDeclaration", ["prefix", n[1]], r.length ? ["uri", r[0]] : ["uri"]]
+						} return ["attributeConstructor", ["attributeName"].concat(n), 0 === r.length ? ["attributeValue"] : 1 === r.length && "string" === typeof r[0] ? ["attributeValue", r[0]] : ["attributeValueExpr"].concat(r)]
+					}), Ps = S.map(S.star(S.preceded(qp, S.optional(Os))), function (n) { return n.filter(Boolean) }), Qs = jl(S.preceded(gm,
+						zp), Ps, S.or([S.map(Il, function () { return null }), S.then(S.preceded(jm, S.star(Ks)), V([W, Jl], S.followed(zp, S.then(S.optional(qp), jm, function () { return null }))), function (n, r) { return [zq(n, !0, !0), r] })]), function (n, r, G) {
+							var ea = G; if (G && G.length) { ea = Aq(n); var oa = Aq(G[1]); if (ea !== oa) throw Error('XQST0118: The start and the end tag of an element constructor must be equal. "' + ea + '" does not match "' + oa + '"'); ea = G[0] } return ["elementConstructor", ["tagName"].concat(t(n))].concat(t(r.length ? [["attributeList"].concat(t(r))] :
+								[]), t(ea && ea.length ? [["elementContent"].concat(t(ea))] : []))
+						}), al = S.or([Qs, dq, gq]), Rs = S.map(V([wn, W], lb), function (n) { return ["computedDocumentConstructor"].concat(t(n ? [["argExpr", n]] : [])) }), Ss = S.map(lb, function (n) { return n ? [["contentExpr", n]] : [] }), Ts = S.then(V([Jm, W], S.or([S.map(Cp, function (n) { return ["tagName"].concat(t(n)) }), S.map(S.delimited(yl, U(l, W), zl), function (n) { return ["tagNameExpr", n] })])), S.preceded(W, Ss), function (n, r) { return ["computedElementConstructor", n].concat(t(r)) }), Us = S.then(S.preceded(Km,
+							S.or([S.map(V([Fp, W], Cp), function (n) { return ["tagName"].concat(t(n)) }), S.map(S.preceded(W, S.delimited(yl, U(l, W), zl)), function (n) { return ["tagNameExpr", n] })])), S.preceded(W, lb), function (n, r) { return ["computedAttributeConstructor", n, ["valueExpr", r ? r : ["sequenceExpr"]]] }), Vs = S.map(lb, function (n) { return n ? [["prefixExpr", n]] : [] }), Ws = S.map(lb, function (n) { return n ? [["URIExpr", n]] : [] }), Xs = S.then(V([xn, W], S.or([up, Vs])), S.preceded(W, Ws), function (n, r) { return ["computedNamespaceConstructor"].concat(t(n), t(r)) }),
+					Ys = S.map(V([yn, W], lb), function (n) { return ["computedTextConstructor"].concat(t(n ? [["argExpr", n]] : [])) }), Zs = S.map(V([zn, W], lb), function (n) { return ["computedCommentConstructor"].concat(t(n ? [["argExpr", n]] : [])) }), $s = V([An, W], S.then(S.or([S.map(tp, function (n) { return ["piTarget", n] }), S.map(S.delimited(yl, U(l, W), zl), function (n) { return ["piTargetExpr", n] })]), S.preceded(W, lb), function (n, r) { return ["computedPIConstructor", n].concat(t(r ? [["piValueExpr", r]] : [])) })), at = S.or([Rs, Ts, Us, Xs, Ys, Zs, $s]), bt = S.or([al, at]),
+					bl = S.or([ih, Ep, jh, Vp, ns, bt, Bs, Fs, Is, Js]), cl = S.map(V([am, W], $k), function (n) { return "*" === n ? ["lookup", ["star"]] : "string" === typeof n ? ["lookup", ["NCName", n]] : ["lookup", n] }), dt = S.then(S.map(bl, function (n) { return wq(n) }), S.star(S.or([S.map(S.preceded(W, q), function (n) { return ["predicate", n] }), S.map(S.preceded(W, ef), function (n) { return ["argumentList", n] }), S.preceded(W, cl)])), function (n, r) {
+						function G() {
+							dl && 1 === Ja.length ? Wc.push(["predicate", Ja[0]]) : 0 !== Ja.length && Wc.push(["predicates"].concat(t(Ja))); Ja.length =
+								0
+						} function ea(ct) { G(); 0 !== Wc.length ? ("sequenceExpr" === oa[0][0] && 2 < oa[0].length && (oa = [["sequenceExpr"].concat(t(oa))]), oa = [["filterExpr"].concat(t(oa))].concat(t(Wc)), Wc.length = 0) : ct && (oa = [["filterExpr"].concat(t(oa))]) } var oa = [n], Ja = [], Wc = [], dl = !1; n = p(r); for (r = n.next(); !r.done; r = n.next())switch (r = r.value, r[0]) {
+							case "predicate": Ja.push(r[1]); break; case "lookup": dl = !0; G(); Wc.push(r); break; case "argumentList": ea(!1); 1 < oa.length && (oa = [["sequenceExpr", ["pathExpr", ["stepExpr"].concat(t(oa))]]]); oa = [["dynamicFunctionInvocationExpr",
+								["functionItem"].concat(t(oa))].concat(t(r[1].length ? [["arguments"].concat(t(r[1]))] : []))]; break; default: throw Error("unreachable");
+						}ea(!0); return oa
+					}), Xc = S.or([S.map(dt, function (n) { return ["stepExpr"].concat(t(n)) }), ms]), et = S.followed(bl, S.peek(S.not(S.preceded(W, S.or([q, ef, cl])), ["primary expression not followed by predicate, argumentList, or lookup"]))), ft = S.or([jl(Xc, S.preceded(W, hq), S.preceded(W, g), function (n, r, G) { return ["pathExpr", n, r].concat(t(G)) }), S.then(Xc, S.preceded(U(rm, W), g), function (n,
+						r) { return ["pathExpr", n].concat(t(r)) }), et, S.map(Xc, function (n) { return ["pathExpr", n] })]), hh = S.or([jl(Xc, S.preceded(W, hq), S.preceded(W, g), function (n, r, G) { return [n, r].concat(t(G)) }), S.then(Xc, S.preceded(U(rm, W), g), function (n, r) { return [n].concat(t(r)) }), S.map(Xc, function (n) { return [n] })]), gt = S.or([S.map(V([rm, W], hh), function (n) { return ["pathExpr", ["rootExpr"]].concat(t(n)) }), S.then(hq, S.preceded(W, hh), function (n, r) { return ["pathExpr", ["rootExpr"], n].concat(t(r)) }), S.map(S.followed(rm, S.not(S.preceded(W,
+							a.Ya ? ol(/[*<a-zA-Z]/) : ol(/[*a-zA-Z]/)), ["Single rootExpr cannot be by followed by something that can be interpreted as a relative path"])), function () { return ["pathExpr", ["rootExpr"]] })]), ht = il(S.or([ft, gt]), Dq), it = S.preceded(Dn, S.then(S.optional(S.or([S.map(S.preceded(W, iq), function (n) { return ["validationMode", n] }), S.map(V([W, En, W], Cp), function (n) { return ["type"].concat(t(n)) })])), S.delimited(S.preceded(W, yl), U(l, W), zl), function (n, r) { return ["validateExpr"].concat(t(n ? [n] : []), [["argExpr", r]]) })), jt = S.delimited(sl,
+								S.then(S.preceded(W, Cp), S.optional(S.preceded(X, jq)), function (n, r) { return r ? ["pragma", ["pragmaName", n], ["pragmaContents", r]] : ["pragma", ["pragmaName", n]] }), S.preceded(W, tl)), kt = S.map(S.followed(S.plus(jt), S.preceded(W, S.delimited(yl, U(S.optional(l), W), zl))), function (n) { return ["extensionExpr"].concat(t(n)) }), lt = e(c(ht, cm, function (n, r) {
+									return 0 === r.length ? n : ["simpleMapExpr", "pathExpr" === n[0] ? n : ["pathExpr", ["stepExpr", ["filterExpr", wq(n)]]]].concat(r.map(function (G) {
+										G = G[1]; return "pathExpr" === G[0] ? G : ["pathExpr",
+											["stepExpr", ["filterExpr", wq(G)]]]
+									}))
+								})), mt = S.or([it, kt, lt]), el = S.or([S.then(S.or([nl([qm], "unaryMinusOp"), nl([pm], "unaryPlusOp")]), S.preceded(W, function (n, r) { return el(n, r) }), function (n, r) { return [n, ["operand", r]] }), mt]), nt = S.or([S.map(Cp, function (n) { return ["EQName"].concat(t(n)) }), Ep, jh]), ot = S.then(el, S.star(V([W, tm, W], S.then(nt, S.preceded(W, ef), function (n, r) { return [n, r] }))), function (n, r) { return r.reduce(function (G, ea) { return ["arrowExpr", ["argExpr", G], ea[0], ["arguments"].concat(t(ea[1]))] }, n) }),
+					pt = S.then(ot, S.optional(V([W, ym, X, xm, Fp, W], Bq)), function (n, r) { return null !== r ? ["castExpr", ["argExpr", n], r] : n }), qt = S.then(pt, S.optional(V([W, zm, X, xm, Fp, W], Bq)), function (n, r) { return null !== r ? ["castableExpr", ["argExpr", n], r] : n }), rt = S.then(qt, S.optional(V([W, Am, X, xm, Fp, W], Bb)), function (n, r) { return null !== r ? ["treatExpr", ["argExpr", n], ["sequenceType"].concat(t(r))] : n }), st = S.then(rt, S.optional(V([W, Bm, X, Cm, Fp, W], Bb)), function (n, r) {
+						return null !== r ? ["instanceOfExpr", ["argExpr", n], ["sequenceType"].concat(t(r))] :
+							n
+					}), tt = c(st, S.followed(S.or([nl([Mm], "intersectOp"), nl([Nm], "exceptOp")]), Fp), b), ut = c(tt, S.or([nl([dm], "unionOp"), S.followed(nl([Om], "unionOp"), Fp)]), b), vt = c(ut, S.or([nl([Wl], "multiplyOp"), S.followed(nl([Tm], "divOp"), Fp), S.followed(nl([Um], "idivOp"), Fp), S.followed(nl([Vm], "modOp"), Fp)]), b), wt = c(vt, S.or([nl([qm], "subtractOp"), nl([pm], "addOp")]), b), xt = d(wt, S.followed(nl([Pm], "rangeSequenceExpr"), Fp), "startExpr", "endExpr"), yt = c(xt, nl([em], "stringConcatenateOp"), b), zt = d(yt, S.or([kq, lq, mq])), At = c(zt, S.followed(nl([Sm],
+						"andOp"), Fp), b), hs = c(At, S.followed(nl([Rm], "orOp"), Fp), b), bs = S.then(S.then(V([en, W, ul, W], l), V([W, vl, W, fn, Fp, W], k), function (n, r) { return [n, r] }), V([W, gn, Fp, W], k), function (n, r) { return ["ifThenElseExpr", ["ifClause", n[0]], ["thenClause", n[1]], ["elseClause", r]] }), Bt = S.delimited(hn, X, jn), Ct = S.map(V([kn, X, Yl], Cp), function (n) { return ["positionalVariableBinding"].concat(t(n)) }), Dt = ll(S.preceded(Yl, S.cut(Cp)), S.cut(S.preceded(W, S.optional(Vc))), S.cut(S.preceded(W, S.optional(Bt))), S.cut(S.preceded(W, S.optional(Ct))),
+							S.cut(S.preceded(U(ln, W), k)), function (n, r, G, ea, oa) { return ["forClauseItem", ["typedVariableBinding", ["varName"].concat(t(n), t(r ? [r] : []))]].concat(t(G ? [["allowingEmpty"]] : []), t(ea ? [ea] : []), [["forExpr", oa]]) }), Et = V([mn, X], c(Dt, mm, function (n, r) { return ["forClause", n].concat(t(r.map(function (G) { return G[1] }))) })), Ft = jl(S.preceded(Yl, Cp), S.preceded(W, S.optional(Vc)), S.preceded(U(Sl, W), k), function (n, r, G) {
+								return ["letClauseItem", ["typedVariableBinding", ["varName"].concat(t(n))].concat(t(r ? [r] : [])), ["letExpr",
+									G]]
+							}), Gt = S.map(V([nn, W], c(Ft, mm, function (n, r) { return [n].concat(t(r.map(function (G) { return G[1] }))) })), function (n) { return ["letClause"].concat(t(n)) }), fl = S.or([Et, Gt]), Ht = S.map(V([on, Fp, W], k), function (n) { return ["whereClause", n] }), It = S.map(S.preceded(Yl, Cp), function (n) { return ["varName"].concat(t(n)) }), Jt = S.then(S.preceded(W, S.optional(Vc)), S.preceded(U(Sl, W), k), function (n, r) { return ["groupVarInitialize"].concat(t(n ? [["typeDeclaration"].concat(t(n))] : []), [["varValue", r]]) }), Kt = jl(It, S.optional(Jt), S.optional(S.map(S.preceded(U(pn,
+								W), u), function (n) { return ["collation", n] })), function (n, r, G) { return ["groupingSpec", n].concat(t(r ? [r] : []), t(G ? [G] : [])) }), Lt = c(Kt, mm, function (n, r) { return [n].concat(t(r.map(function (G) { return G[1] }))) }), Mt = S.map(V([qn, X, rn, W], Lt), function (n) { return ["groupByClause"].concat(t(n)) }), Nt = jl(S.optional(S.or([Co, Do])), S.optional(V([W, jn, W], S.or([Nn, On].map(function (n) { return S.map(n, function (r) { return "empty " + r }) })))), S.preceded(W, S.optional(V([pn, W], u))), function (n, r, G) {
+									return n || r || G ? ["orderModifier"].concat(t(n ?
+										[["orderingKind", n]] : []), t(r ? [["emptyOrderingMode", r]] : []), t(G ? [["collation", G]] : [])) : null
+								}), Ot = S.then(k, S.preceded(W, Nt), function (n, r) { return ["orderBySpec", ["orderByExpr", n]].concat(t(r ? [r] : [])) }), Pt = c(Ot, mm, function (n, r) { return [n].concat(t(r.map(function (G) { return G[1] }))) }), Qt = S.then(S.or([S.map(V([sn, X], rn), function () { return !1 }), S.map(V([tn, X, sn, X], rn), function () { return !0 })]), S.preceded(W, Pt), function (n, r) { return ["orderByClause"].concat(t(n ? [["stable"]] : []), t(r)) }), Rt = S.or([fl, Ht, Mt, Qt]), St = S.map(V([un,
+									W], k), function (n) { return ["returnClause", n] }), Yr = jl(fl, S.cut(S.star(S.preceded(W, Rt))), S.cut(S.preceded(W, St)), function (n, r, G) { return ["flworExpr", n].concat(t(r), [G]) }), Tt = c(Bb, dm, function (n, r) { return 0 === r.length ? ["sequenceType"].concat(t(n)) : ["sequenceTypeUnion", ["sequenceType"].concat(t(n))].concat(t(r.map(function (G) { return ["sequenceType"].concat(t(G[1])) }))) }), Ut = jl(V([Rn, W], S.optional(S.preceded(Yl, S.followed(S.followed(Cp, X), xm)))), S.preceded(W, Tt), V([X, un, X], k), function (n, r, G) {
+										return ["typeswitchExprCaseClause"].concat(n ?
+											[["variableBinding"].concat(t(n))] : [], [r], [["resultExpr", G]])
+									}), as = kl(S.preceded(Sn, U(S.delimited(ul, U(l, W), vl), W)), S.plus(S.followed(Ut, W)), V([Gn, X], S.optional(S.preceded(Yl, S.followed(Cp, X)))), V([un, X], k), function (n, r, G, ea) { return ["typeswitchExpr", ["argExpr", n]].concat(t(r), [["typeswitchExprDefaultClause"].concat(t(G || []), [["resultExpr", ea]])]) }), Vt = jl(S.preceded(Yl, Cp), S.optional(S.preceded(X, Vc)), S.preceded(U(ln, X), k), function (n, r, G) {
+										return ["quantifiedExprInClause", ["typedVariableBinding", ["varName"].concat(t(n))].concat(t(r ?
+											[r] : [])), ["sourceExpr", G]]
+									}), Wt = c(Vt, mm, function (n, r) { return [n].concat(t(r.map(function (G) { return G[1] }))) }), Zr = jl(S.or([Tn, Un]), S.preceded(X, Wt), S.preceded(U(Vn, W), k), function (n, r, G) { return ["quantifiedExpr", ["quantifier", n]].concat(t(r), [["predicateExpr", G]]) }), ds = S.map(V([Fm, X, S.or([Em, Dm]), X], k), function (n) { return ["deleteExpr", ["targetExpr", n]] }), fs = jl(V([Wn, X], S.optional(V([Gm, X, Cm], X))), V([Dm, X], k), S.preceded(U(Xn, X), k), function (n, r, G) {
+										return n ? ["replaceExpr", ["replaceValue"], ["targetExpr", r],
+											["replacementExpr", G]] : ["replaceExpr", ["targetExpr", r], ["replacementExpr", G]]
+									}), Xt = S.then(Ep, S.preceded(U(Sl, W), k), function (n, r) { return ["transformCopy", n, ["copySource", r]] }), gs = jl(V([Yn, X], c(Xt, mm, function (n, r) { return [n].concat(t(r.map(function (G) { return G[1] }))) })), V([W, Zn, X], k), S.preceded(U(un, X), k), function (n, r, G) { return ["transformExpr", ["transformCopies"].concat(t(n)), ["modifyExpr", r], ["returnExpr", G]] }), Yt = S.or([S.followed(S.map(S.optional(S.followed(V([xm, X], S.or([S.map($n, function () { return ["insertAsFirst"] }),
+									S.map(ao, function () { return ["insertAsLast"] })])), X)), function (n) { return n ? ["insertInto", n] : ["insertInto"] }), eo), S.map(co, function () { return ["insertAfter"] }), S.map(bo, function () { return ["insertBefore"] })]), cs = jl(V([fo, X, S.or([Em, Dm]), X], k), S.preceded(X, Yt), S.preceded(X, k), function (n, r, G) { return ["insertExpr", ["sourceExpr", n], r, ["targetExpr", G]] }), es = S.then(V([go, X, Dm, W], k), V([X, xm, X], k), function (n, r) { return ["renameExpr", ["targetExpr", n], ["newNameExpr", r]] }), Zt = S.then(S.plus(S.map(V([Rn, X], k), function (n) {
+										return ["switchCaseExpr",
+											n]
+									})), V([X, un, X], k), function (n, r) { return ["switchExprCaseClause"].concat(t(n), [["resultExpr", r]]) }), $r = jl(V([ho, W, ul], l), V([W, vl, W], S.plus(S.followed(Zt, W))), V([Gn, X, un, X], k), function (n, r, G) { return ["switchExpr", ["argExpr", n]].concat(t(r), [["switchExprDefaultClause", ["resultExpr", G]]]) }), $t = S.map(l, function (n) { return ["queryBody", n] }), au = V([Fn, X, xn, X], S.cut(S.then(tp, S.preceded(U(bm, W), u), function (n, r) { return ["namespaceDecl", ["prefix", n], ["uri", r]] }))), bu = S.then(V([io, X, Yl, W], S.then(Cp, S.optional(S.preceded(W,
+										Vc)), function (n, r) { return [n, r] })), S.cut(S.or([S.map(V([W, Sl, W], k), function (n) { return ["varValue", n] }), S.map(V([X, jo], S.optional(V([W, Sl, W], k))), function (n) { return ["external"].concat(t(n ? [["varValue", n]] : [])) })])), function (n, r) { var G = p(n); n = G.next().value; G = G.next().value; return ["varDecl", ["varName"].concat(t(n))].concat(t(null !== G ? [G] : []), [r]) }), cu = kl(V([Hm, X, S.peek(S.not(Wp, ["Cannot use reserved function name"]))], Cp), S.cut(V([W, ul, W], S.optional(Zk))), S.cut(V([W, vl], S.optional(V([X, xm, X], Bb)))), S.cut(S.preceded(W,
+											S.or([S.map(Yk, function (n) { return ["functionBody", n] }), S.map(jo, function () { return ["externalDefinition"] })]))), function (n, r, G, ea) { return ["functionDecl", ["functionName"].concat(t(n)), ["paramList"].concat(t(r || []))].concat(t(G ? [["typeDeclaration"].concat(t(G))] : []), [ea]) }), du = V([Fn, X], S.then(S.star(S.followed(S.or([kh, nq]), X)), S.or([bu, cu]), function (n, r) { return [r[0]].concat(t(n), t(r.slice(1))) })), eu = S.then(V([Fn, X, Gn, X], S.or([Jm, Hm])), V([X, xn, X], u), function (n, r) {
+												return ["defaultNamespaceDecl", ["defaultNamespaceCategory",
+													n], ["uri", r]]
+											}), fu = S.or([S.map(S.followed(V([xn, X], tp), S.preceded(W, bm)), function (n) { return ["namespacePrefix", n] }), S.map(V([Gn, X, Jm, X], xn), function () { return ["defaultElementNamespace"] })]), gu = V([lo, X, mo], jl(S.optional(S.preceded(X, fu)), S.preceded(W, u), S.optional(S.then(V([X, kn, X], u), S.star(V([W, mm, W], u)), function (n, r) { return [n].concat(t(r)) })), function (n, r, G) { return ["schemaImport"].concat(t(n ? [n] : []), [["targetNamespace", r]], t(G ? [G] : [])) })), hu = V([lo, X, no], jl(S.optional(S.followed(V([X, xn, X], tp), S.preceded(W,
+												bm))), S.preceded(W, u), S.optional(S.then(V([X, kn, X], u), S.star(V([W, mm, W], u)), function (n, r) { return [n].concat(t(r)) })), function (n, r) { return ["moduleImport", ["namespacePrefix", n], ["targetNamespace", r]] })), iu = S.or([gu, hu]), ju = S.map(V([Fn, X, Gn, X, pn, X], u), function (n) { return ["defaultCollationDecl", n] }), ku = S.map(V([Fn, X, oo, X], u), function (n) { return ["baseUriDecl", n] }), lu = S.then(V([Fn, X], S.or([S.map(V([Qn, X], Cp), function (n) { return ["decimalFormatName"].concat(t(n)) }), S.map(V([Gn, X], Qn), function () { return null })])),
+													S.star(S.then(S.preceded(X, qq), S.preceded(U(bm, X), u), function (n, r) { return ["decimalFormatParam", ["decimalFormatParamName", n], ["decimalFormatParamValue", r]] })), function (n, r) { return ["decimalFormatDecl"].concat(t(n ? [n] : []), t(r)) }), mu = S.or([rq, ju, ku, sq, tq, uq, vq, lu]), nu = S.then(V([Fn, X, to, X], Cp), S.preceded(X, u), function (n, r) { return ["optionDecl", ["optionName", n], ["optionContents", r]] }), ou = S.then(V([Fn, X, uo, X, vo], S.optional(V([X, xm], Wk))), S.or([S.map(S.preceded(U(Sl, W), k), function (n) { return ["varValue", n] }),
+													S.map(V([X, jo], S.optional(S.preceded(U(Sl, W), k))), function () { return ["external"] })]), function (n, r) { return ["contextItemDecl"].concat(t(n ? [["contextItemType", n]] : []), [r]) }), gl = S.then(S.star(S.followed(S.or([eu, mu, au, iu]), S.cut(U(Vl, W)))), S.star(S.followed(S.or([ou, du, nu]), S.cut(U(Vl, W)))), function (n, r) { return 0 === n.length && 0 === r.length ? null : ["prolog"].concat(t(n), t(r)) }), pu = V([no, X, xn, X], S.then(S.followed(tp, U(bm, W)), S.followed(u, U(Vl, W)), function (n, r) { return ["moduleDecl", ["prefix", n], ["uri", r]] })),
+					qu = S.then(pu, S.preceded(W, gl), function (n, r) { return ["libraryModule", n].concat(t(r ? [r] : [])) }), ru = S.then(gl, S.preceded(W, $t), function (n, r) { return ["mainModule"].concat(t(n ? [n] : []), [r]) }), su = S.map(V([wo, W], S.followed(S.or([S.then(S.preceded(yo, X), u, function (n) { return ["encoding", n] }), S.then(V([xo, X], u), S.optional(V([X, yo, X], u)), function (n, r) { return [["version", n]].concat(t(r ? [["encoding", r]] : [])) })]), S.preceded(W, Vl))), function (n) { return ["versionDecl"].concat(t(n)) }), tu = S.then(S.optional(U(su, W)), S.or([qu,
+						ru]), function (n, r) { return ["module"].concat(t(n ? [n] : []), [r]) }), uu = S.complete(U(tu, W)); return function (n, r) { m.clear(); r = uu(n, r); for (var G = 1, ea = 1, oa = 0; oa < n.length + 1; oa++) { if (m.has(oa)) { var Ja = m.get(oa); Ja.line = ea; Ja.ja = G } Ja = n[oa]; "\r" === Ja || "\n" === Ja ? (ea++, G = 1) : G++ } return r }
+			} var Fq = Eq({ vb: !1, Ya: !1 }), Gq = Eq({ vb: !0, Ya: !1 }), Hq = Eq({ vb: !1, Ya: !0 }), Iq = Eq({ vb: !0, Ya: !0 }); function Jq(a, b) { var c = !!b.$; b = !!b.debug; kp.clear(); lp.clear(); Dq.clear(); c = c ? b ? Iq(a, 0) : Hq(a, 0) : b ? Gq(a, 0) : Fq(a, 0); if (!0 === c.success) return c.value; a = a.substring(0, c.offset).split("\n"); b = a[a.length - 1].length + 1; throw new ii({ start: { offset: c.offset, line: a.length, ja: b }, end: { offset: c.offset + 1, line: a.length, ja: b + 1 } }, "", Error("XPST0003: Failed to parse script. Expected " + [].concat(t(new Set(c.expected))))); }; var Kq = "http://www.w3.org/XML/1998/namespace http://www.w3.org/2001/XMLSchema http://www.w3.org/2001/XMLSchema-instance http://www.w3.org/2005/xpath-functions http://www.w3.org/2005/xpath-functions/math http://www.w3.org/2012/xquery http://www.w3.org/2005/xpath-functions/array http://www.w3.org/2005/xpath-functions/map".split(" ");
+			function Lq(a, b, c, d, e) {
+				var f = L(a, "functionName"), g = M(f, "prefix") || "", k = M(f, "URI"), l = Tg(f); if (null === k && (k = "" === g ? null === b.v ? "http://www.w3.org/2005/xpath-functions" : b.v : b.aa(g), !k && g)) throw Ig(g); if (Kq.includes(k)) throw Dg(); g = O(a, "annotation").map(function (J) { return L(J, "annotationName") }); f = g.every(function (J) { return !M(J, "URI") && "private" !== Tg(J) }); g = g.some(function (J) { return !M(J, "URI") && "updating" === Tg(J) }); if (!k) throw Eg(); var m = Vg(a), q = O(L(a, "paramList"), "param"), u = q.map(function (J) {
+					return L(J,
+						"varName")
+				}), z = q.map(function (J) { return Vg(J) }); if (a = L(a, "functionBody")) {
+					if (b.xa(k, l, z.length)) throw Error("XQST0049: The function Q{" + k + "}" + l + "#" + z.length + " has already been declared."); if (!e) return; var A = Mk(a[1], { ua: !1, $: !0 }), D = new Lg(b), F = u.map(function (J) { var T = M(J, "URI"), ia = M(J, "prefix"); J = Tg(J); ia && null === T && (T = b.aa(ia || "")); return Qg(D, T, J) }); e = g ? {
+						j: z, arity: u.length, callFunction: function (J, T, ia) {
+							var Ba = Aa.apply(3, arguments), Ra = Nc(Jc(J, -1, null, C.empty()), F.reduce(function (kb, Rb, Gd) {
+								kb[Rb] =
+								yb(Ba[Gd]); return kb
+							}, Object.create(null))); return A.s(Ra, T)
+						}, Eb: !1, I: !0, hb: f, localName: l, namespaceURI: k, i: m
+					} : { j: z, arity: u.length, callFunction: function (J, T, ia) { var Ba = Aa.apply(3, arguments), Ra = Nc(Jc(J, -1, null, C.empty()), F.reduce(function (kb, Rb, Gd) { kb[Rb] = yb(Ba[Gd]); return kb }, Object.create(null))); return I(A, Ra, T) }, Eb: !1, I: !1, hb: f, localName: l, namespaceURI: k, i: m }; c.push({ ca: A, Mb: D }); d.push({ arity: u.length, ca: A, Ib: e, localName: l, namespaceURI: k, hb: f })
+				} else {
+					if (g) throw Error("Updating external function declarations are not supported");
+					e = { j: z, arity: u.length, callFunction: function (J, T, ia) { var Ba = Aa.apply(3, arguments), Ra = ia.xa(k, l, u.length, !0); if (!Ra) throw Error("XPST0017: Function Q{" + k + "}" + l + " with arity of " + u.length + " not registered. " + ug(l)); if (Ra.i.type !== m.type || Ra.j.some(function (kb, Rb) { return kb.type !== z[Rb].type })) throw Error("External function declaration types do not match actual function"); return Ra.callFunction.apply(Ra, [J, T, ia].concat(t(Ba))) }, Eb: !0, I: !1, localName: l, namespaceURI: k, hb: f, i: m }
+				} Og(b, k, l, u.length, e)
+			}
+			function Mq(a, b, c, d) {
+				var e = [], f = []; O(a, "*").forEach(function (A) { switch (A[0]) { case "moduleImport": case "namespaceDecl": case "defaultNamespaceDecl": case "functionDecl": case "varDecl": break; default: throw Error("Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules"); } }); var g = new Set; O(a, "moduleImport").forEach(function (A) {
+					var D = Tg(L(A, "namespacePrefix")); A = Tg(L(A, "targetNamespace")); if (g.has(A)) throw Error('XQST0047: The namespace "' +
+						A + '" is imported more than once.'); g.add(A); Pg(b, D, A)
+				}); O(a, "namespaceDecl").forEach(function (A) { var D = Tg(L(A, "prefix")); A = Tg(L(A, "uri")); if ("xml" === D || "xmlns" === D) throw Gg(); if ("http://www.w3.org/XML/1998/namespace" === A || "http://www.w3.org/2000/xmlns/" === A) throw Gg(); Pg(b, D, A) }); for (var k = null, l = null, m = p(O(a, "defaultNamespaceDecl")), q = m.next(); !q.done; q = m.next()) {
+					var u = q.value; q = Tg(L(u, "defaultNamespaceCategory")); u = Tg(L(u, "uri")); if (!u) throw Eg(); if ("http://www.w3.org/XML/1998/namespace" === u || "http://www.w3.org/2000/xmlns/" ===
+						u) throw Gg(); if ("function" === q) { if (k) throw Fg(); k = u } else if ("element" === q) { if (l) throw Fg(); l = u }
+				} k && (b.v = k); l && Pg(b, "", l); O(a, "functionDecl").forEach(function (A) { Lq(A, b, e, f, c) }); var z = []; O(a, "varDecl").forEach(function (A) {
+					var D = Ug(L(A, "varName")), F = D.namespaceURI; if (null === F && (F = b.aa(D.prefix), !F && D.prefix)) throw Ig(D.prefix); if (Kq.includes(F)) throw Dg(); var J = L(A, "external"); A = L(A, "varValue"); var T, ia; null !== J ? (J = L(J, "varValue"), null !== J && (T = L(J, "*"))) : null !== A && (T = L(A, "*")); if (z.some(function (Ra) {
+						return Ra.namespaceURI ===
+							F && Ra.localName === D.localName
+					})) throw Error("XQST0049: The variable " + (F ? "Q{" + F + "}" : "") + D.localName + " has already been declared."); Qg(b, F || "", D.localName); if (c && (T && (ia = Mk(T, { ua: !1, $: !0 })), T && !Ng(b, F || "", D.localName))) { var Ba = null; Rg(b, F, D.localName, function (Ra, kb) { if (Ba) return Ba(); Ba = yb(I(ia, Ra, kb)); return Ba() }); e.push({ ca: ia, Mb: b }); z.push({ ca: ia, localName: D.localName, namespaceURI: F }) }
+				}); f.forEach(function (A) {
+					if (!A.Ib.I && A.ca.I) throw af("The function Q{" + A.namespaceURI + "}" + A.localName + " is updating but the %updating annotation is missing.");
+				}); return { Ma: f.map(function (A) { return A.Ib }), Va: z, source: d, ra: function (A) { g.forEach(function (D) { Uk(b, D) }); e.forEach(function (D) { var F = D.ca, J = D.Mb; g.forEach(function (T) { Uk(J, T) }); A.Ma.forEach(function (T) { J.xa(T.namespaceURI, T.localName, T.arity, !0) || T.hb && Og(J, T.namespaceURI, T.localName, T.arity, T) }); A.Va.forEach(function (T) { J.ib(T.namespaceURI, T.localName) || Qg(J, T.namespaceURI, T.localName) }); F.v(J) }) } }
+			}; function Nq(a, b, c, d, e, f, g) { var k = b.$ ? "XQuery" : "XPath"; c = b.La ? null : Pk(a, k, c, d, e, b.debug, f, g); return null !== c ? { state: c.rc ? 1 : 2, ca: c.ca } : { state: 0, hc: "string" === typeof a ? Jq(a, b) : Rk(a) } } function Oq(a, b, c, d) { var e = L(a, "mainModule"); if (!e) throw Error("Can not execute a library module."); var f = L(e, "prolog"); if (f) { if (!b.$) throw Error("XPST0003: Use of XQuery functionality is not allowed in XPath context"); Vk(); d = Mq(f, c, !0, d); d.ra(d) } oh(a, new Jh(c)); a = N(e, ["queryBody", "*"]); return R(a, b) }
+			function Pq(a, b, c, d, e, f, g) { var k = new zg(c, d, f, g), l = new Lg(k); 0 < Object.keys(e).length && Vk(); Object.keys(e).forEach(function (m) { var q = e[m]; Uk(l, q); Pg(l, m, q) }); "string" === typeof a && (a = hl(a)); c = Nq(a, b, c, d, e, f, g); switch (c.state) { case 2: return { ia: l, ca: c.ca }; case 1: return c.ca.v(l), Qk(a, b.$ ? "XQuery" : "XPath", k, e, c.ca, b.debug, f), { ia: l, ca: c.ca }; case 0: return c = Oq(c.hc, b, l, a), c.v(l), b.La || Qk(a, b.$ ? "XQuery" : "XPath", k, e, c, b.debug, f), { ia: l, ca: c } } }; function Qq(a, b, c, d) {
+				a = a.first(); var e = b.first().h.reduce(function (u, z) { u[z.key.value] = yb(z.value()); return u }, Object.create(null)); b = e["."] ? e["."]() : C.empty(); delete e["."]; try {
+					if (B(a.type, 1)) var f = a.value; else if (B(a.type, 54)) f = a.value.node; else throw Sc("Unable to convert selector argument of type " + mb[a.type] + " to either an " + mb[1] + " or an " + mb[54] + " representing an XQueryX program while calling 'fontoxpath:evaluate'"); var g = Pq(f, { ua: !1, $: !0, debug: d.debug, La: d.La }, function (u) { return c.aa(u) },
+						Object.keys(e).reduce(function (u, z) { u[z] = z; return u }, {}), {}, "http://www.w3.org/2005/xpath-functions", function (u, z) { return c.Ua(u, z) }), k = g.ca, l = g.ia, m = !b.G(), q = new Hc({ N: m ? b.first() : null, Ka: m ? 0 : -1, Da: b, Aa: Object.keys(e).reduce(function (u, z) { u[l.ib(null, z)] = e[z]; return u }, Object.create(null)) }); return { sc: k.h(q, d).value, pc: a }
+				} catch (u) { pg(a.value, u) }
+			}; function Rq(a, b, c) { if (1 !== b.node.nodeType && 9 !== b.node.nodeType) return []; var d = Pb(a, b).reduce(function (e, f) { f = p(Rq(a, f, c)); for (var g = f.next(); !g.done; g = f.next())e.push(g.value); return e }, []); c(b) && d.unshift(b); return d }
+			function Sq(a, b, c, d, e) {
+				a = e.first(); if (!a) throw Rc("The context is absent, it needs to be present to use id function."); if (!B(a.type, 53)) throw Sc("The context item is not a node, it needs to be node to use id function."); var f = b.h, g = d.O().reduce(function (k, l) { l.value.split(/\s+/).forEach(function (m) { k[m] = !0 }); return k }, Object.create(null)); for (b = a.value; 9 !== b.node.nodeType;)if (b = Vb(f, b), null === b) throw Error("FODC0001: the root node of the target node is not a document node."); b = Rq(f, b, function (k) {
+					if (1 !==
+						k.node.nodeType) return !1; k = Ob(f, k, "id"); if (!k || !g[k]) return !1; g[k] = !1; return !0
+				}); return C.create(b.map(function (k) { return $b(k) }))
+			}
+			function Tq(a, b, c, d, e) {
+				a = e.first(); if (!a) throw Rc("The context is absent, it needs to be present to use idref function."); if (!B(a.type, 53)) throw Sc("The context item is not a node, it needs to be node to use idref function."); var f = b.h, g = d.O().reduce(function (k, l) { k[l.value] = !0; return k }, Object.create(null)); for (b = a.value; 9 !== b.node.nodeType;)if (b = Vb(f, b), null === b) throw Error("FODC0001: the root node of the context node is not a document node."); b = Rq(f, b, function (k) {
+					return 1 !== k.node.nodeType ? !1 :
+						(k = Ob(f, k, "idref")) ? k.split(/\s+/).some(function (l) { return g[l] }) : !1
+				}); return C.create(b.map(function (k) { return $b(k) }))
+			}; function Uq(a) { switch (typeof a) { case "object": return Array.isArray(a) ? C.m(new Yb(a.map(function (b) { return yb(Uq(b)) }))) : null === a ? C.empty() : C.m(new dc(Object.keys(a).map(function (b) { return { key: w(b, 1), value: yb(Uq(a[b])) } }))); case "number": return C.m(w(a, 3)); case "string": return C.m(w(a, 1)); case "boolean": return a ? C.ba() : C.W(); default: throw Error("Unexpected type in JSON parse"); } }; function Vq(a, b, c, d, e) {
+				var f = C.m(w("duplicates", 1)); a = cc(a, b, c, e, f); var g = a.G() ? "use-first" : a.first().value; return d.M(function (k) {
+					return C.m(new dc(k.reduce(function (l, m) {
+						m.h.forEach(function (q) { var u = l.findIndex(function (z) { return bc(z.key, q.key) }); if (0 <= u) switch (g) { case "reject": throw Error("FOJS0003: Duplicate encountered when merging maps."); case "use-last": l.splice(u, 1, q); return; case "combine": l.splice(u, 1, { key: q.key, value: yb(C.create(l[u].value().O().concat(q.value().O()))) }); return; default: return }l.push(q) });
+						return l
+					}, [])))
+				})
+			}; function Wq(a, b, c) { var d = 1, e = a.value; a = a.Qa(!0); var f = null, g = Math.max(b - 1, 0); -1 !== a && (f = Math.max(0, (null === c ? a : Math.max(0, Math.min(a, c + (b - 1)))) - g)); return C.create({ next: function (k) { for (; d < b;)e.next(k), d++; if (null !== c && d >= b + c) return x; k = e.next(k); d++; return k } }, f) } function Xq(a) { return a.map(function (b) { return B(b.type, 19) ? Pd(b, 3) : b }) }
+			function Yq(a) { a = Xq(a); if (a.some(function (b) { return Number.isNaN(b.value) })) return [w(NaN, 3)]; a = cj(a); if (!a) throw Error("FORG0006: Incompatible types to be converted to a common type"); return a }
+			function Zq(a, b, c, d, e, f) { return ac([e, f], function (g) { var k = p(g); g = k.next().value; k = k.next().value; if (Infinity === g.value) return C.empty(); if (-Infinity === g.value) return k && Infinity === k.value ? C.empty() : d; if (k) { if (isNaN(k.value)) return C.empty(); Infinity === k.value && (k = null) } return isNaN(g.value) ? C.empty() : Wq(d, Math.round(g.value), k ? Math.round(k.value) : null) }) }
+			function $q(a, b, c, d, e) { if (d.G()) return e; a = Xq(d.O()); a = cj(a); if (!a) throw Error("FORG0006: Incompatible types to be converted to a common type"); if (!a.every(function (f) { return B(f.type, 2) })) throw Error("FORG0006: items passed to fn:sum are not all numeric."); b = a.reduce(function (f, g) { return f + g.value }, 0); return a.every(function (f) { return B(f.type, 5) }) ? C.m(w(b, 5)) : a.every(function (f) { return B(f.type, 3) }) ? C.m(w(b, 3)) : a.every(function (f) { return B(f.type, 4) }) ? C.m(w(b, 4)) : C.m(w(b, 6)) }; var ar = [].concat(Vf, [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "boolean", j: [{ type: 59, g: 2 }], i: { type: 0, g: 3 }, callFunction: function (a, b, c, d) { return d.ha() ? C.ba() : C.W() } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "true", j: [], i: { type: 0, g: 3 }, callFunction: function () { return C.ba() } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "not", j: [{ type: 59, g: 2 }], i: { type: 0, g: 3 }, callFunction: function (a, b, c, d) { return !1 === d.ha() ? C.ba() : C.W() } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				localName: "false", j: [], i: { type: 0, g: 3 }, callFunction: function () { return C.W() }
+			}], [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "last", j: [], i: { type: 5, g: 3 }, callFunction: function (a) { if (null === a.N) throw Rc("The fn:last() function depends on dynamic context, which is absent."); var b = !1; return C.create({ next: function () { if (b) return x; var c = a.Da.Qa(); b = !0; return y(w(c, 5)) } }, 1) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "position", j: [], i: { type: 5, g: 3 }, callFunction: function (a) {
+					if (null ===
+						a.N) throw Rc("The fn:position() function depends on dynamic context, which is absent."); return C.m(w(a.Ka + 1, 5))
+				}
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "current-dateTime", j: [], i: { type: 10, g: 3 }, callFunction: function (a) { return C.m(w(Kc(a), 10)) } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "current-date", j: [], i: { type: 7, g: 3 }, callFunction: function (a) { return C.m(w(tc(Kc(a), 7), 7)) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "current-time",
+				j: [], i: { type: 8, g: 3 }, callFunction: function (a) { return C.m(w(tc(Kc(a), 8), 8)) }
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "implicit-timezone", j: [], i: { type: 17, g: 3 }, callFunction: function (a) { return C.m(w(Lc(a), 17)) } }], Wf, dg, kg, [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "years-from-duration", j: [{ type: 18, g: 0 }], i: { type: 5, g: 0 }, callFunction: function (a, b, c, d) { return d.G() ? d : C.m(w(d.first().value.gb(), 5)) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "months-from-duration",
+				j: [{ type: 18, g: 0 }], i: { type: 5, g: 0 }, callFunction: function (a, b, c, d) { return d.G() ? d : C.m(w(d.first().value.cb(), 5)) }
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "days-from-duration", j: [{ type: 18, g: 0 }], i: { type: 5, g: 0 }, callFunction: function (a, b, c, d) { return d.G() ? d : C.m(w(d.first().value.bb(), 5)) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "hours-from-duration", j: [{ type: 18, g: 0 }], i: { type: 5, g: 0 }, callFunction: function (a, b, c, d) {
+					return d.G() ? d : C.m(w(d.first().value.getHours(),
+						5))
+				}
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "minutes-from-duration", j: [{ type: 18, g: 0 }], i: { type: 5, g: 0 }, callFunction: function (a, b, c, d) { return d.G() ? d : C.m(w(d.first().value.getMinutes(), 5)) } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "seconds-from-duration", j: [{ type: 18, g: 0 }], i: { type: 4, g: 0 }, callFunction: function (a, b, c, d) { return d.G() ? d : C.m(w(d.first().value.getSeconds(), 4)) } }], mg, [{
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "id", j: [{
+					type: 1,
+					g: 2
+				}, { type: 53, g: 3 }], i: { type: 54, g: 2 }, callFunction: Sq
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "id", j: [{ type: 1, g: 2 }], i: { type: 54, g: 2 }, callFunction: function (a, b, c, d) { return Sq(a, b, c, d, C.m(a.N)) } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "idref", j: [{ type: 1, g: 2 }, { type: 53, g: 3 }], i: { type: 53, g: 2 }, callFunction: Tq }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "idref", j: [{ type: 1, g: 2 }], i: { type: 53, g: 2 }, callFunction: function (a, b, c, d) {
+					return Tq(a,
+						b, c, d, C.m(a.N))
+				}
+			}], [{ namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "parse-json", j: [{ type: 1, g: 3 }], i: { type: 59, g: 0 }, callFunction: function (a, b, c, d) { try { var e = JSON.parse(d.first().value) } catch (f) { throw Error("FOJS0001: parsed JSON string contains illegal JSON."); } return Uq(e) } }], [{
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "contains", j: [{ type: 61, g: 3 }, { type: 46, g: 3 }], i: { type: 0, g: 3 }, callFunction: function (a, b, c, d, e) {
+					return ac([d, e], function (f) {
+						f = p(f); var g = f.next().value,
+							k = f.next().value; return g.h.some(function (l) { return bc(l.key, k) }) ? C.ba() : C.W()
+					})
+				}
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "entry", j: [{ type: 46, g: 3 }, { type: 59, g: 2 }], i: { type: 61, g: 3 }, callFunction: function (a, b, c, d, e) { return d.map(function (f) { return new dc([{ key: f, value: yb(e) }]) }) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "for-each", j: [{ type: 61, g: 3 }, { type: 59, g: 2 }], i: { type: 59, g: 2 }, callFunction: function (a, b, c, d, e) {
+					return ac([d, e], function (f) {
+						f = p(f);
+						var g = f.next().value, k = f.next().value; return Pc(g.h.map(function (l) { return k.value.call(void 0, a, b, c, C.m(l.key), l.value()) }))
+					})
+				}
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "get", j: [{ type: 61, g: 3 }, { type: 46, g: 3 }], i: { type: 59, g: 2 }, callFunction: cc }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "keys", j: [{ type: 61, g: 3 }], i: { type: 46, g: 2 }, callFunction: function (a, b, c, d) { return ac([d], function (e) { e = p(e).next().value; return C.create(e.h.map(function (f) { return f.key })) }) } },
+			{ namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "merge", j: [{ type: 61, g: 2 }, { type: 61, g: 3 }], i: { type: 61, g: 3 }, callFunction: Vq }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "merge", j: [{ type: 61, g: 2 }], i: { type: 61, g: 3 }, callFunction: function (a, b, c, d) { return Vq(a, b, c, d, C.m(new dc([{ key: w("duplicates", 1), value: function () { return C.m(w("use-first", 1)) } }]))) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "put", j: [{ type: 61, g: 3 }, { type: 46, g: 3 }, {
+					type: 59,
+					g: 2
+				}], i: { type: 61, g: 3 }, callFunction: function (a, b, c, d, e, f) { return ac([d, e], function (g) { g = p(g); var k = g.next().value, l = g.next().value; g = k.h.concat(); k = g.findIndex(function (m) { return bc(m.key, l) }); 0 <= k ? g.splice(k, 1, { key: l, value: yb(f) }) : g.push({ key: l, value: yb(f) }); return C.m(new dc(g)) }) }
+			}, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "remove", j: [{ type: 61, g: 3 }, { type: 46, g: 2 }], i: { type: 61, g: 3 }, callFunction: function (a, b, c, d, e) {
+					return ac([d], function (f) {
+						var g = p(f).next().value.h.concat();
+						return e.M(function (k) { k.forEach(function (l) { var m = g.findIndex(function (q) { return bc(q.key, l) }); 0 <= m && g.splice(m, 1) }); return C.m(new dc(g)) })
+					})
+				}
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions/map", localName: "size", j: [{ type: 61, g: 3 }], i: { type: 5, g: 3 }, callFunction: function (a, b, c, d) { return d.map(function (e) { return w(e.h.length, 5) }) } }], [{ namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "pi", j: [], i: { type: 3, g: 3 }, callFunction: function () { return C.m(w(Math.PI, 3)) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/math",
+				localName: "exp", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: function (a, b, c, d) { return d.map(function (e) { return w(Math.pow(Math.E, e.value), 3) }) }
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "exp10", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: function (a, b, c, d) { return d.map(function (e) { return w(Math.pow(10, e.value), 3) }) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "log", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: function (a, b, c, d) {
+					return d.map(function (e) {
+						return w(Math.log(e.value),
+							3)
+					})
+				}
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "log10", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: function (a, b, c, d) { return d.map(function (e) { return w(Math.log10(e.value), 3) }) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "pow", j: [{ type: 3, g: 0 }, { type: 2, g: 3 }], i: { type: 3, g: 0 }, callFunction: function (a, b, c, d, e) {
+					return e.M(function (f) {
+						var g = p(f).next().value; return d.map(function (k) {
+							return 1 !== Math.abs(k.value) || Number.isFinite(g.value) ? w(Math.pow(k.value,
+								g.value), 3) : w(1, 3)
+						})
+					})
+				}
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "sqrt", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: function (a, b, c, d) { return d.map(function (e) { return w(Math.sqrt(e.value), 3) }) } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "sin", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: function (a, b, c, d) { return d.map(function (e) { return w(Math.sin(e.value), 3) }) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "cos", j: [{
+					type: 3,
+					g: 0
+				}], i: { type: 3, g: 0 }, callFunction: function (a, b, c, d) { return d.map(function (e) { return w(Math.cos(e.value), 3) }) }
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "tan", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: function (a, b, c, d) { return d.map(function (e) { return w(Math.tan(e.value), 3) }) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "asin", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: function (a, b, c, d) {
+					return d.map(function (e) {
+						return w(Math.asin(e.value),
+							3)
+					})
+				}
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "acos", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: function (a, b, c, d) { return d.map(function (e) { return w(Math.acos(e.value), 3) }) } }, { namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "atan", j: [{ type: 3, g: 0 }], i: { type: 3, g: 0 }, callFunction: function (a, b, c, d) { return d.map(function (e) { return w(Math.atan(e.value), 3) }) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions/math", localName: "atan2", j: [{ type: 3, g: 0 },
+				{ type: 3, g: 3 }], i: { type: 3, g: 0 }, callFunction: function (a, b, c, d, e) { return e.M(function (f) { var g = p(f).next().value; return d.map(function (k) { return w(Math.atan2(k.value, g.value), 3) }) }) }
+			}], Oe, re, [{ namespaceURI: "http://fontoxpath/operators", localName: "to", j: [{ type: 5, g: 0 }, { type: 5, g: 0 }], i: { type: 5, g: 2 }, callFunction: function (a, b, c, d, e) { a = d.first(); e = e.first(); if (null === a || null === e) return C.empty(); var f = a.value; e = e.value; return f > e ? C.empty() : C.create({ next: function () { return y(w(f++, 5)) } }, e - f + 1) } }], [{
+				namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				localName: "QName", j: [{ type: 1, g: 0 }, { type: 1, g: 3 }], i: { type: 23, g: 3 }, callFunction: function (a, b, c, d, e) {
+					return ac([d, e], function (f) {
+						var g = p(f); f = g.next().value; g = g.next().value.value; if (!bd(g, 23)) throw Error("FOCA0002: The provided QName is invalid."); f = f ? f.value || null : null; if (null === f && g.includes(":")) throw Error("FOCA0002: The URI of a QName may not be empty if a prefix is provided."); if (d.G()) return C.m(w(new zb("", null, g), 23)); if (!g.includes(":")) return C.m(w(new zb("", f, g), 23)); var k = p(g.split(":"));
+						g = k.next().value; k = k.next().value; return C.m(w(new zb(g, f, k), 23))
+					})
+				}
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "prefix-from-QName", j: [{ type: 23, g: 0 }], i: { type: 24, g: 0 }, callFunction: function (a, b, c, d) { return ac([d], function (e) { e = p(e).next().value; if (null === e) return C.empty(); e = e.value; return e.prefix ? C.m(w(e.prefix, 24)) : C.empty() }) } }, {
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "local-name-from-QName", j: [{ type: 23, g: 0 }], i: { type: 24, g: 0 }, callFunction: function (a,
+					b, c, d) { return d.map(function (e) { return w(e.value.localName, 24) }) }
+			}, { namespaceURI: "http://www.w3.org/2005/xpath-functions", localName: "namespace-uri-from-QName", j: [{ type: 23, g: 0 }], i: { type: 20, g: 0 }, callFunction: function (a, b, c, d) { return d.map(function (e) { return w(e.value.namespaceURI || "", 20) }) } }], [{
+				j: [{ type: 59, g: 2 }], callFunction: function (a, b, c, d) { return d.Z({ empty: function () { return C.ba() }, multiple: function () { return C.W() }, m: function () { return C.W() } }) }, localName: "empty", namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				i: { type: 0, g: 3 }
+			}, { j: [{ type: 59, g: 2 }], callFunction: function (a, b, c, d) { return d.Z({ empty: function () { return C.W() }, multiple: function () { return C.ba() }, m: function () { return C.ba() } }) }, localName: "exists", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 0, g: 3 } }, { j: [{ type: 59, g: 2 }], callFunction: function (a, b, c, d) { return Wq(d, 1, 1) }, localName: "head", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 0 } }, {
+				j: [{ type: 59, g: 2 }], callFunction: function (a, b, c, d) { return Wq(d, 2, null) }, localName: "tail",
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 }
+			}, { j: [{ type: 59, g: 2 }, { type: 5, g: 3 }, { type: 59, g: 2 }], callFunction: function (a, b, c, d, e, f) { if (d.G()) return f; if (f.G()) return d; a = d.O(); e = e.first().value - 1; 0 > e ? e = 0 : e > a.length && (e = a.length); b = a.slice(e); return C.create(a.slice(0, e).concat(f.O(), b)) }, localName: "insert-before", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } }, {
+				j: [{ type: 59, g: 2 }, { type: 5, g: 3 }], callFunction: function (a, b, c, d, e) {
+					a = e.first().value; d = d.O(); if (!d.length ||
+						1 > a || a > d.length) return C.create(d); d.splice(a - 1, 1); return C.create(d)
+				}, localName: "remove", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 }
+			}, { j: [{ type: 59, g: 2 }], callFunction: function (a, b, c, d) { return d.M(function (e) { return C.create(e.reverse()) }) }, localName: "reverse", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } }, {
+				j: [{ type: 59, g: 2 }, { type: 3, g: 3 }], callFunction: function (a, b, c, d, e) { return Zq(a, b, c, d, e, C.empty()) }, localName: "subsequence", namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				i: { type: 59, g: 2 }
+			}, { j: [{ type: 59, g: 2 }, { type: 3, g: 3 }, { type: 3, g: 3 }], callFunction: Zq, localName: "subsequence", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } }, { j: [{ type: 59, g: 2 }], callFunction: function (a, b, c, d) { return d }, localName: "unordered", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } }, {
+				j: [{ type: 46, g: 2 }], callFunction: function (a, b, c, d) { var e = Zc(d, b).O(); return C.create(e).filter(function (f, g) { return e.slice(0, g).every(function (k) { return !Re(f, k) }) }) }, localName: "distinct-values",
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 2 }
+			}, { j: [{ type: 46, g: 2 }, { type: 1, g: 3 }], callFunction: function () { throw Error("FOCH0002: No collations are supported"); }, localName: "distinct-values", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 2 } }, {
+				j: [{ type: 46, g: 2 }, { type: 46, g: 3 }], callFunction: function (a, b, c, d, e) {
+					return e.M(function (f) {
+						var g = p(f).next().value; return Zc(d, b).map(function (k, l) { return Ii("eqOp", k.type, g.type)(k, g, a) ? w(l + 1, 5) : w(-1, 5) }).filter(function (k) {
+							return -1 !==
+								k.value
+						})
+					})
+				}, localName: "index-of", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 5, g: 2 }
+			}, { j: [{ type: 46, g: 2 }, { type: 46, g: 3 }, { type: 1, g: 3 }], callFunction: function () { throw Error("FOCH0002: No collations are supported"); }, localName: "index-of", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 5, g: 2 } }, {
+				j: [{ type: 59, g: 2 }, { type: 59, g: 2 }], callFunction: function (a, b, c, d, e) {
+					var f = !1, g = Ue(a, b, c, d, e); return C.create({
+						next: function () {
+							if (f) return x; var k = g.next(0); if (k.done) return k; f = !0; return y(w(k.value,
+								0))
+						}
+					})
+				}, localName: "deep-equal", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 0, g: 3 }
+			}, { j: [{ type: 59, g: 2 }, { type: 59, g: 2 }, { type: 1, g: 3 }], callFunction: function () { throw Error("FOCH0002: No collations are supported"); }, localName: "deep-equal", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 0, g: 3 } }, {
+				j: [{ type: 59, g: 2 }], callFunction: function (a, b, c, d) { var e = !1; return C.create({ next: function () { if (e) return x; var f = d.Qa(); e = !0; return y(w(f, 5)) } }) }, localName: "count", namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				i: { type: 5, g: 3 }
+			}, {
+				j: [{ type: 46, g: 2 }], callFunction: function (a, b, c, d) { if (d.G()) return d; a = Xq(d.O()); a = cj(a); if (!a) throw Error("FORG0006: Incompatible types to be converted to a common type"); if (!a.every(function (e) { return B(e.type, 2) })) throw Error("FORG0006: items passed to fn:avg are not all numeric."); b = a.reduce(function (e, f) { return e + f.value }, 0) / a.length; return a.every(function (e) { return B(e.type, 5) || B(e.type, 3) }) ? C.m(w(b, 3)) : a.every(function (e) { return B(e.type, 4) }) ? C.m(w(b, 4)) : C.m(w(b, 6)) }, localName: "avg",
+				namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 0 }
+			}, { j: [{ type: 46, g: 2 }], callFunction: function (a, b, c, d) { if (d.G()) return d; a = Yq(d.O()); return C.m(a.reduce(function (e, f) { return e.value < f.value ? f : e })) }, localName: "max", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 0 } }, { j: [{ type: 46, g: 2 }, { type: 1, g: 3 }], callFunction: function () { throw Error("FOCH0002: No collations are supported"); }, localName: "max", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 0 } },
+			{ j: [{ type: 46, g: 2 }], callFunction: function (a, b, c, d) { if (d.G()) return d; a = Yq(d.O()); return C.m(a.reduce(function (e, f) { return e.value > f.value ? f : e })) }, localName: "min", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 0 } }, { j: [{ type: 46, g: 2 }, { type: 1, g: 3 }], callFunction: function () { throw Error("FOCH0002: No collations are supported"); }, localName: "min", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 0 } }, {
+				j: [{ type: 46, g: 2 }], callFunction: function (a, b, c, d) {
+					return $q(a, b, c, d, C.m(w(0,
+						5)))
+				}, localName: "sum", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 3 }
+			}, { j: [{ type: 46, g: 2 }, { type: 46, g: 0 }], callFunction: $q, localName: "sum", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 46, g: 0 } }, { j: [{ type: 59, g: 2 }], callFunction: function (a, b, c, d) { if (!d.G() && !d.wa()) throw Error("FORG0003: The argument passed to fn:zero-or-one contained more than one item."); return d }, localName: "zero-or-one", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 0 } }, {
+				j: [{
+					type: 59,
+					g: 2
+				}], callFunction: function (a, b, c, d) { if (d.G()) throw Error("FORG0004: The argument passed to fn:one-or-more was empty."); return d }, localName: "one-or-more", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 1 }
+			}, { j: [{ type: 59, g: 2 }], callFunction: function (a, b, c, d) { if (!d.wa()) throw Error("FORG0005: The argument passed to fn:exactly-one is empty or contained more than one item."); return d }, localName: "exactly-one", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 3 } }, {
+				j: [{
+					type: 59,
+					g: 2
+				}, { type: 60, g: 3 }], callFunction: function (a, b, c, d, e) { if (d.G()) return d; var f = e.first(), g = f.o; if (1 !== g.length) throw Error("XPTY0004: signature of function passed to fn:filter is incompatible."); return d.filter(function (k) { k = fe(g[0], C.m(k), b, "fn:filter", !1); k = f.value.call(void 0, a, b, c, k); if (!k.wa() || !B(k.first().type, 0)) throw Error("XPTY0004: signature of function passed to fn:filter is incompatible."); return k.first().value }) }, localName: "filter", namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				i: { type: 59, g: 2 }
+			}, {
+				j: [{ type: 59, g: 2 }, { type: 60, g: 3 }], callFunction: function (a, b, c, d, e) { if (d.G()) return d; var f = e.first(), g = f.o; if (1 !== g.length) throw Error("XPTY0004: signature of function passed to fn:for-each is incompatible."); var k = d.value, l; return C.create({ next: function (m) { for (; ;) { if (!l) { var q = k.next(0); if (q.done) return q; q = fe(g[0], C.m(q.value), b, "fn:for-each", !1); l = f.value.call(void 0, a, b, c, q).value } q = l.next(m); if (!q.done) return q; l = null } } }) }, localName: "for-each", namespaceURI: "http://www.w3.org/2005/xpath-functions",
+				i: { type: 59, g: 2 }
+			}, { j: [{ type: 59, g: 2 }, { type: 59, g: 2 }, { type: 60, g: 3 }], callFunction: function (a, b, c, d, e, f) { if (d.G()) return d; var g = f.first(), k = g.o; if (2 !== k.length) throw Error("XPTY0004: signature of function passed to fn:fold-left is incompatible."); return d.M(function (l) { return l.reduce(function (m, q) { m = fe(k[0], m, b, "fn:fold-left", !1); q = fe(k[1], C.m(q), b, "fn:fold-left", !1); return g.value.call(void 0, a, b, c, m, q) }, e) }) }, localName: "fold-left", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } },
+			{ j: [{ type: 59, g: 2 }, { type: 59, g: 2 }, { type: 60, g: 3 }], callFunction: function (a, b, c, d, e, f) { if (d.G()) return d; var g = f.first(), k = g.o; if (2 !== k.length) throw Error("XPTY0004: signature of function passed to fn:fold-right is incompatible."); return d.M(function (l) { return l.reduceRight(function (m, q) { m = fe(k[0], m, b, "fn:fold-right", !1); q = fe(k[1], C.m(q), b, "fn:fold-right", !1); return g.value.call(void 0, a, b, c, q, m) }, e) }) }, localName: "fold-right", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 59, g: 2 } }, {
+				j: [{
+					type: 59,
+					g: 2
+				}], callFunction: function (a, b, c, d) { if (!b.v) throw Error("serialize() called but no xmlSerializer set in execution parameters."); a = d.O(); if (!a.every(function (e) { return B(e.type, 53) })) throw Error("Expected argument to fn:serialize to resolve to a sequence of Nodes."); return C.m(w(a.map(function (e) { return b.v.serializeToString(ig(e.value, b, !1)) }).join(""), 1)) }, localName: "serialize", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 1, g: 3 }
+			}], De, [{
+				j: [{ type: 59, g: 3 }, { type: 61, g: 3 }], callFunction: function (a,
+					b, c, d, e) { var f, g; return C.create({ next: function () { if (!f) { var k = Qq(d, e, c, b); f = k.sc; g = k.pc } try { return f.next(0) } catch (l) { pg(g.value, l) } } }) }, localName: "evaluate", namespaceURI: "http://fontoxml.com/fontoxpath", i: { type: 59, g: 2 }
+			}, { j: [], callFunction: function () { return C.m(w("undefined" === typeof VERSION ? "devbuild" : VERSION, 1)) }, localName: "version", namespaceURI: "http://fontoxml.com/fontoxpath", i: { type: 1, g: 3 } }], [{
+				j: [{ type: 23, g: 3 }, { type: 5, g: 3 }], callFunction: function (a, b, c, d, e) {
+					return ac([d, e], function (f) {
+						var g =
+							p(f); f = g.next().value; g = g.next().value; var k = c.xa(f.value.namespaceURI, f.value.localName, g.value); if (null === k) return C.empty(); f = new Ab({ j: k.j, arity: g.value, localName: f.value.localName, namespaceURI: f.value.namespaceURI, i: k.i, value: k.callFunction }); return C.m(f)
+					})
+				}, localName: "function-lookup", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { g: 0, type: 60 }
+			}, {
+				j: [{ type: 60, g: 3 }], callFunction: function (a, b, c, d) {
+					return ac([d], function (e) {
+						e = p(e).next().value; return e.Sa() ? C.empty() : C.m(w(new zb("", e.l,
+							e.B), 23))
+					})
+				}, localName: "function-name", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 23, g: 0 }
+			}, { j: [{ type: 60, g: 3 }], callFunction: function (a, b, c, d) { return ac([d], function (e) { e = p(e).next().value; return C.m(w(e.v, 5)) }) }, localName: "function-arity", namespaceURI: "http://www.w3.org/2005/xpath-functions", i: { type: 5, g: 3 } }]); function br(a) { this.h = a } h = br.prototype; h.createAttributeNS = function (a, b) { return this.h.createAttributeNS(a, b) }; h.createCDATASection = function (a) { return this.h.createCDATASection(a) }; h.createComment = function (a) { return this.h.createComment(a) }; h.createDocument = function () { return this.h.createDocument() }; h.createElementNS = function (a, b) { return this.h.createElementNS(a, b) }; h.createProcessingInstruction = function (a, b) { return this.h.createProcessingInstruction(a, b) }; h.createTextNode = function (a) { return this.h.createTextNode(a) }; var cr = Symbol("IS_XPATH_VALUE_SYMBOL"); function dr(a) { return function (b, c) { b = Dc(new Mb(null === c ? new Gb : c), b, qb(a)); c = {}; return c[cr] = !0, c.Hb = b, c } }; ar.forEach(function (a) { wg(a.namespaceURI, a.localName, a.j, a.i, a.callFunction) }); function er(a) { return a && "object" === typeof a && "lookupNamespaceURI" in a ? function (b) { return a.lookupNamespaceURI(b || null) } : function () { return null } } function fr(a) { return function (b) { var c = b.localName; return b.prefix ? null : { namespaceURI: a, localName: c } } }
+			function gr(a, b, c, d, e, f) {
+				if (null === d || void 0 === d) d = d || {}; if (e) { var g = e.logger || { trace: console.log.bind(console) }; var k = e.documentWriter; var l = e.moduleImports; var m = e.namespaceResolver; var q = e.functionNameResolver; var u = e.nodesFactory; var z = e.xmlSerializer } else g = { trace: console.log.bind(console) }, l = {}, z = k = u = m = null, q = void 0; var A = new Mb(null === c ? new Gb : c); c = l || Object.create(null); l = void 0 === e.defaultFunctionNamespaceURI ? "http://www.w3.org/2005/xpath-functions" : e.defaultFunctionNamespaceURI; var D = Pq(a,
+					f, m || er(b), d, c, l, q || fr(l)); a = b ? Ec(A, b) : C.empty(); b = !u && f.$ ? new of(b) : new br(u); k = k ? new Jb(k) : Ib; u = Object.keys(d).reduce(function (T, ia) { var Ba = d[ia]; T["Q{}" + ia + "[0]"] = Ba && "object" === typeof Ba && cr in Ba ? function () { return C.create(Ba.Hb) } : function () { return Ec(A, d[ia]) }; return T }, Object.create(null)); m = {}; q = p(Object.keys(D.ia.Ia)); for (c = q.next(); !c.done; m = { Za: m.Za }, c = q.next())m.Za = c.value, u[m.Za] || (u[m.Za] = function (T) { return function () { return (0, D.ia.Ia[T.Za])(F, J) } }(m)); var F = new Hc({
+						N: a.first(), Ka: 0,
+						Da: a, Aa: u
+					}); var J = new Oc(f.debug, f.La, A, b, k, e.currentContext, new Map, g, z); return { Bb: F, Cb: J, ca: D.ca }
+			}; function hr(a, b) {
+				var c = {}, d = 0, e = !1, f = null; return {
+					next: function () {
+						if (e) return x; for (var g = {}; d < a.h.length;) {
+							a: {
+								var k = a.h[d].key.value; if (!f) {
+									g.pb = a.h[d]; var l = g.pb.value().Z({ default: function (m) { return m }, multiple: function (m) { return function () { throw Error("Serialization error: The value of an entry in a map is expected to be a single item or an empty sequence. Use arrays when putting multiple values in a map. The value of the key " + m.pb.key.value + " holds multiple items"); } }(g) }).first(); if (null ===
+										l) { c[k] = null; d++; break a } f = ir(l, b)
+								} l = f.next(0); f = null; c[k] = l.value; d++
+							} g = { pb: g.pb }
+						} e = !0; return y(c)
+					}
+				}
+			}
+			function jr(a, b) { var c = [], d = 0, e = !1, f = null; return { next: function () { if (e) return x; for (; d < a.P.length;) { if (!f) { var g = a.P[d]().Z({ default: function (k) { return k }, multiple: function () { throw Error("Serialization error: The value of an entry in an array is expected to be a single item or an empty sequence. Use nested arrays when putting multiple values in an array."); } }).first(); if (null === g) { c[d++] = null; continue } f = ir(g, b) } g = f.next(0); f = null; c[d++] = g.value } e = !0; return y(c) } } }
+			function ir(a, b) { if (B(a.type, 61)) return hr(a, b); if (B(a.type, 62)) return jr(a, b); if (B(a.type, 23)) { var c = a.value; return { next: function () { return y("Q{" + (c.namespaceURI || "") + "}" + c.localName) } } } switch (a.type) { case 7: case 8: case 9: case 11: case 12: case 13: case 14: case 15: var d = a.value; return { next: function () { return y(uc(d)) } }; case 47: case 53: case 54: case 55: case 56: case 57: case 58: var e = a.value; return { next: function () { return y(ig(e, b, !1)) } }; default: return { next: function () { return y(a.value) } } } }; var kr = { ANY: 0, NUMBER: 1, STRING: 2, BOOLEAN: 3, NODES: 7, FIRST_NODE: 9, STRINGS: 10, MAP: 11, ARRAY: 12, NUMBERS: 13, ALL_RESULTS: 14, ASYNC_ITERATOR: 99 }; kr[kr.ANY] = "ANY"; kr[kr.NUMBER] = "NUMBER"; kr[kr.STRING] = "STRING"; kr[kr.BOOLEAN] = "BOOLEAN"; kr[kr.NODES] = "NODES"; kr[kr.FIRST_NODE] = "FIRST_NODE"; kr[kr.STRINGS] = "STRINGS"; kr[kr.MAP] = "MAP"; kr[kr.ARRAY] = "ARRAY"; kr[kr.NUMBERS] = "NUMBERS"; kr[kr.ALL_RESULTS] = "ALL_RESULTS"; kr[kr.ASYNC_ITERATOR] = "ASYNC_ITERATOR";
+			function lr(a, b, c, d) {
+				switch (c) {
+					case 3: return b.ha(); case 2: return b = Zc(b, d).O(), b.length ? b.map(function (l) { return Pd(l, 1).value }).join(" ") : ""; case 10: return b = Zc(b, d).O(), b.length ? b.map(function (l) { return l.value + "" }) : []; case 1: return b = b.first(), null !== b && B(b.type, 2) ? b.value : NaN; case 9: b = b.first(); if (null === b) return null; if (!B(b.type, 53)) throw Error("Expected XPath " + ng(a) + " to resolve to Node. Got " + mb[b.type]); return ig(b.value, d, !1); case 7: b = b.O(); if (!b.every(function (l) { return B(l.type, 53) })) throw Error("Expected XPath " +
+						ng(a) + " to resolve to a sequence of Nodes."); return b.map(function (l) { return ig(l.value, d, !1) }); case 11: b = b.O(); if (1 !== b.length) throw Error("Expected XPath " + ng(a) + " to resolve to a single map."); b = b[0]; if (!B(b.type, 61)) throw Error("Expected XPath " + ng(a) + " to resolve to a map"); return hr(b, d).next(0).value; case 12: b = b.O(); if (1 !== b.length) throw Error("Expected XPath " + ng(a) + " to resolve to a single array."); b = b[0]; if (!B(b.type, 62)) throw Error("Expected XPath " + ng(a) + " to resolve to an array"); return jr(b,
+							d).next(0).value; case 13: return b.O().map(function (l) { if (!B(l.type, 2)) throw Error("Expected XPath " + ng(a) + " to resolve to numbers"); return l.value }); case 99: var e = b.value, f = null, g = !1, k = function () { for (; !g;) { if (!f) { var l = e.next(0); if (l.done) { g = !0; break } f = ir(l.value, d) } l = f.next(0); f = null; return l } return Promise.resolve({ done: !0, value: null }) }; "asyncIterator" in Symbol ? (b = {}, b = (b[Symbol.asyncIterator] = function () { return this }, b.next = function () {
+								return (new Promise(function (l) { return l(k()) })).catch(function (l) {
+									pg(a,
+										l)
+								})
+							}, b)) : b = { next: function () { return new Promise(function (l) { return l(k()) }) } }; return b; case 14: return b.O().map(function (l) { return ir(l, d).next(0).value }); default: return b = b.O(), b.every(function (l) { return B(l.type, 53) && !B(l.type, 47) }) ? (b = b.map(function (l) { return ig(l.value, d, !1) }), 1 === b.length ? b[0] : b) : 1 === b.length ? (b = b[0], B(b.type, 62) ? jr(b, d).next(0).value : B(b.type, 61) ? hr(b, d).next(0).value : Yc(b, d).first().value) : Zc(C.create(b), d).O().map(function (l) { return l.value })
+				}
+			}; var mr = !1, nr = null, or = {
+				getPerformanceSummary: function () { var a = nr.getEntriesByType("measure").filter(function (b) { return b.name.startsWith("XPath: ") }); return Array.from(a.reduce(function (b, c) { var d = c.name.substring(7); b.has(d) ? (d = b.get(d), d.times += 1, d.totalDuration += c.duration) : b.set(d, { xpath: d, times: 1, totalDuration: c.duration, average: 0 }); return b }, new Map).values()).map(function (b) { b.average = b.totalDuration / b.times; return b }).sort(function (b, c) { return c.totalDuration - b.totalDuration }) }, setPerformanceImplementation: function (a) {
+					nr =
+					a
+				}, startProfiling: function () { if (null === nr) throw Error("Performance API object must be set using `profiler.setPerformanceImplementation` before starting to profile"); nr.clearMarks(); nr.clearMeasures(); mr = !0 }, stopProfiling: function () { mr = !1 }
+			}, pr = 0; var qr = { XPATH_3_1_LANGUAGE: "XPath3.1", XQUERY_3_1_LANGUAGE: "XQuery3.1", XQUERY_UPDATE_3_1_LANGUAGE: "XQueryUpdate3.1" }; function rr(a, b, c, d, e, f) {
+				e = e || 0; if (!a || "string" !== typeof a && !("nodeType" in a)) throw new TypeError("Failed to execute 'evaluateXPath': xpathExpression must be a string or an element depicting an XQueryX DOM tree."); f = f || {}; try { var g = gr(a, b, c || null, d || {}, f, { ua: "XQueryUpdate3.1" === f.language, $: "XQuery3.1" === f.language || "XQueryUpdate3.1" === f.language, debug: !!f.debug, La: !!f.disableCache }); var k = g.Bb; var l = g.Cb; var m = g.ca } catch (z) { pg(a, z) } if (m.I) throw Error("XUST0001: Updating expressions should be evaluated as updating expressions");
+				if (3 === e && b && "object" === typeof b && "nodeType" in b && (c = m.B(), b = Fb(b), null !== c && !b.includes(c))) return !1; try { b = a; mr && ("string" !== typeof b && (b = ng(b)), nr.mark(b + (0 === pr ? "" : "@" + pr)), pr++); var q = I(m, k, l), u = lr(a, q, e, l); e = a; mr && ("string" !== typeof e && (e = ng(e)), pr--, k = e + (0 === pr ? "" : "@" + pr), nr.measure("XPath: " + e, k), nr.clearMarks(k)); return u } catch (z) { pg(a, z) }
+			} Object.assign(rr, { tc: 14, ANY_TYPE: 0, Tb: 12, Ub: 99, BOOLEAN_TYPE: 3, Wb: 9, Zb: 11, ac: 7, bc: 13, NUMBER_TYPE: 1, cc: 10, STRING_TYPE: 2, uc: "XPath3.1", vc: "XQuery3.1", fc: "XQueryUpdate3.1" });
+			var sr = {}; Object.assign(rr, (sr.ALL_RESULTS_TYPE = 14, sr.ANY_TYPE = 0, sr.ARRAY_TYPE = 12, sr.ASYNC_ITERATOR_TYPE = 99, sr.BOOLEAN_TYPE = 3, sr.FIRST_NODE_TYPE = 9, sr.MAP_TYPE = 11, sr.NODES_TYPE = 7, sr.NUMBERS_TYPE = 13, sr.NUMBER_TYPE = 1, sr.STRINGS_TYPE = 10, sr.STRING_TYPE = 2, sr.XPATH_3_1_LANGUAGE = "XPath3.1", sr.XQUERY_3_1_LANGUAGE = "XQuery3.1", sr.XQUERY_UPDATE_3_1_LANGUAGE = "XQueryUpdate3.1", sr)); function tr(a, b, c, d, e) { return rr(a, b, c, d, rr.Ub, e) }; function ur(a, b, c, d) { var e = {}; return e.pendingUpdateList = a.fa.map(function (f) { return f.h(d) }), e.xdmValue = lr(b, C.create(a.J), c, d), e }; function vr(a, b, c, d, e) {
+				var f, g, k, l, m, q, u, z, A, D; return za(new ya(new ua(function (F) {
+					switch (F.h) {
+						case 1: e = e || {}; Vk(); try { l = gr(a, b, c || null, d || {}, e || {}, { ua: !0, $: !0, debug: !!e.debug, La: !!e.disableCache }), f = l.Bb, g = l.Cb, k = l.ca } catch (T) { pg(a, T) } if (k.I) { F.h = 2; break } m = []; q = tr(a, b, c, d, Object.assign(Object.assign({}, e), { language: "XQueryUpdate3.1" })); var J = q.next(); F.h = 3; return { value: J }; case 3: u = F.l; case 4: if (u.done) { F.h = 6; break } m.push(u.value); J = q.next(); F.h = 7; return { value: J }; case 7: u = F.l; F.h = 4; break; case 6: return z =
+							{}, F.return(Promise.resolve((z.pendingUpdateList = [], z.xdmValue = m, z))); case 2: try { D = k.s(f, g), A = D.next(0) } catch (T) { pg(a, T) } return F.return(ur(A.value, a, e.returnType, g))
+					}
+				})))
+			}; function wr(a, b, c, d, e) { e = e || {}; Vk(); try { var f = gr(a, b, c || null, d || {}, e || {}, { ua: !0, $: !0, debug: !!e.debug, La: !!e.disableCache }); var g = f.Bb; var k = f.Cb; var l = f.ca } catch (q) { pg(a, q) } if (!l.I) return g = {}, k = {}, k.pendingUpdateList = [], k.xdmValue = rr(a, b, c, d, e.i, Object.assign(Object.assign({}, e), (g.language = rr.fc, g))), k; try { var m = l.s(g, k).next(0) } catch (q) { pg(a, q) } return ur(m.value, a, e.returnType, k) }; function xr(a, b, c, d, e) { return rr(a, b, c, d, rr.Tb, e) }; function yr(a, b, c, d, e) { return rr(a, b, c, d, rr.BOOLEAN_TYPE, e) }; function zr(a, b, c, d, e) { return rr(a, b, c, d, rr.Wb, e) }; function Ar(a, b, c, d, e) { return rr(a, b, c, d, rr.Zb, e) }; function Br(a, b, c, d, e) { return rr(a, b, c, d, rr.ac, e) }; function Cr(a, b, c, d, e) { return rr(a, b, c, d, rr.NUMBER_TYPE, e) }; function Dr(a, b, c, d, e) { return rr(a, b, c, d, rr.bc, e) }; function Er(a, b, c, d, e) { return rr(a, b, c, d, rr.STRING_TYPE, e) }; function Fr(a, b, c, d, e) { return rr(a, b, c, d, rr.cc, e) }; function Gr(a, b, c, d) { b = new Mb(b ? b : new Gb); d = d ? new Jb(d) : Ib; c = c ? c = new br(c) : null; a = a.map(Zj); xf(a, b, c, d) }; function Y(a, b, c) { return { code: a, va: b, H: c, isAstAccepted: !0 } } function Hr(a) { return { isAstAccepted: !1, reason: a } }; function Z(a, b) { return a.isAstAccepted ? b(a) : a } function Ir(a, b) { return a.isAstAccepted ? b(a) : [a, null] }
+			function Jr(a, b, c) { return Z(a, function (d) { switch (d.va.type) { case 0: return d; case 1: return Z(Kr(c, d, "nodes"), function (e) { return Z(Kr(c, b, "contextItem"), function (f) { return Y("(function () {\n\t\t\t\t\t\t\tconst { done, value } = " + e.code + "(" + f.code + ").next();\n\t\t\t\t\t\t\treturn done ? null : value;\n\t\t\t\t\t\t})()", { type: 0 }, [].concat(t(e.H), t(f.H))) }) }); default: throw Error("invalid generated code type to convert to value: " + d.va.type); } }) }
+			function Lr(a, b, c, d) { a = Jr(a, c, d); return b && 0 === b.type && 3 === b.g ? a : Z(a, function (e) { return Y("!!" + e.code, { type: 0 }, e.H) }) } function Mr(a, b, c) { return b ? a.isAstAccepted && 0 !== a.va.type ? Hr("Atomization only implemented for single value") : B(b.type, 1) ? a : B(b.type, 47) ? Z(Kr(c, a, "attr"), function (d) { return Y("(" + d.code + " ? domFacade.getData(" + d.code + ") : null)", { type: 0 }, d.H) }) : Hr("Atomization only implemented for string and attribute") : Hr("Can not atomize value if type was not annotated") }
+			function Nr(a, b, c, d) { a = Jr(a, c, d); d = Mr(a, b, d); return ed(b) ? Z(d, function (e) { return Y(e.code + " ?? ''", { type: 0 }, e.H) }) : d }
+			function Or(a, b, c) { return Z(Kr(c, a, "node"), function (d) { return 1 === d.va.type ? d : b && !B(b.type, 53) ? Hr("Can not evaluate to node if expression does not result in nodes") : Y("(function () {\n\t\t\t\tif (" + d.code + " !== null && !" + d.code + ".nodeType) {\n\t\t\t\t\tthrow new Error('XPDY0050: The result of the expression was not a node');\n\t\t\t\t}\n\t\t\t\treturn " + d.code + ";\n\t\t\t})()", { type: 0 }, d.H) }) }
+			function Pr(a, b, c, d) { return Z(a, function (e) { switch (e.va.type) { case 1: return Z(Kr(d, e, "nodes"), function (f) { return Z(Kr(d, c, "contextItem"), function (g) { return Y("Array.from(" + f.code + "(" + g.code + "))", { type: 0 }, [].concat(t(f.H), t(g.H))) }) }); case 0: return Z(Kr(d, Or(e, b, d), "node"), function (f) { return Y("(" + f.code + " === null ? [] : [" + f.code + "])", { type: 0 }, f.H) }); default: return Hr("Unsupported code type to evaluate to nodes") } }) }
+			function Qr(a, b) { return Z(a, function (c) { return Z(b, function (d) { if (0 !== c.va.type || 0 !== d.va.type) throw Error("can only use emitAnd with value expressions"); return Y(c.code + " && " + d.code, { type: 0 }, [].concat(t(c.H), t(d.H))) }) }) }; function Rr(a, b, c, d) { return (a = N(a, [b, "*"])) ? d.h(a, c, d) : [Hr(b + " expression not found"), null] }; var Sr = {}, Tr = (Sr.equalOp = "eqOp", Sr.notEqualOp = "neOp", Sr.lessThanOrEqualOp = "leOp", Sr.lessThanOp = "ltOp", Sr.greaterThanOrEqualOp = "geOp", Sr.greaterThanOp = "gtOp", Sr), Ur = {}, Vr = (Ur.eqOp = "eqOp", Ur.neOp = "neOp", Ur.leOp = "geOp", Ur.ltOp = "gtOp", Ur.geOp = "leOp", Ur.gtOp = "ltOp", Ur);
+			function Wr(a, b, c, d) {
+				var e = M(N(a, ["firstOperand", "*"]), "type"), f = M(N(a, ["secondOperand", "*"]), "type"); if (!e || !f) return Hr("Can not generate code for value compare without both types"); var g = [47, 1]; if (!g.includes(e.type) || !g.includes(f.type)) return Hr("Unsupported types in compare: [" + mb[e.type] + ", " + mb[f.type] + "]"); g = new Map([["eqOp", "==="], ["neOp", "!=="]]); if (!g.has(b)) return Hr(b + " not yet implemented"); var k = g.get(b); b = p(Rr(a, "firstOperand", c, d)); g = b.next().value; b.next(); b = Jr(g, c, d); b = Mr(b, e,
+					d); return Z(Kr(d, b, "first"), function (l) { var m = p(Rr(a, "secondOperand", c, d)), q = m.next().value; m.next(); m = Jr(q, c, d); m = Mr(m, f, d); return Z(Kr(d, m, "second"), function (u) { var z = []; ed(e) && z.push(l.code + " === null"); ed(f) && z.push(u.code + " === null"); return Y("(" + (z.length ? z.join(" || ") + " ? null : " : "") + l.code + " " + k + " " + u.code + ")", { type: 0 }, [].concat(t(l.H), t(u.H))) }) })
+			}
+			function Xr(a, b, c, d, e, f) {
+				var g = M(N(a, [b, "*"]), "type"), k = M(N(a, [c, "*"]), "type"); if (!g || !k) return Hr("Can not generate code for general compare without both types"); var l = [47, 1]; if (!l.includes(g.type) || !l.includes(k.type)) return Hr("Unsupported types in compare: [" + mb[g.type] + ", " + mb[k.type] + "]"); l = new Map([["eqOp", "==="], ["neOp", "!=="]]); if (!l.has(d)) return Hr(d + " not yet implemented"); var m = l.get(d); b = p(Rr(a, b, e, f)); d = b.next().value; b.next(); b = Jr(d, e, f); g = Mr(b, g, f); return Z(Kr(f, g, "single"), function (q) {
+					var u =
+						p(Rr(a, c, e, f)), z = u.next().value; u.next(); return Z(Kr(f, z, "multiple"), function (A) {
+							if (1 !== A.va.type) return Hr("can only generate general compare for a single value and a generator"); var D = vu(f, wu(f, "n")), F = Mr(D, k, f); return Z(e, function (J) {
+								return Z(F, function (T) {
+									return Y("(function () {\n\t\t\t\t\t\t\t\t\tfor (const " + D.code + " of " + A.code + "(" + J.code + ")) {\n\t\t\t\t\t\t\t\t\t\t" + T.H.join("\n") + "\n\t\t\t\t\t\t\t\t\t\tif (" + T.code + " " + m + " " + q.code + ") {\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t})()",
+										{ type: 0 }, [].concat(t(q.H), t(D.H), t(J.H), t(A.H)))
+								})
+							})
+						})
+				})
+			}; function xu(a) { return JSON.stringify(a).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") }; var Du = { "false#0": yu, "local-name#0": zu, "local-name#1": zu, "name#0": Au, "name#1": Au, "not#1": Bu, "true#0": Cu }, Eu = {}, Fu = (Eu["http://fontoxml.com/fontoxpath"] = ["version#0"], Eu[""] = ["root#1", "path#1"], Eu);
+			function Gu(a, b, c, d) { var e = p(d.h(a, c, d)), f = e.next().value; e.next(); a = M(a, "type"); if (b ? 2 === b.g || 1 === b.g : 1) return Hr("Not supported: sequence arguments with multiple items"); if (B(b.type, 53)) return b = Jr(f, c, d), Or(b, a, d); switch (b.type) { case 59: return Jr(f, c, d); case 0: return Lr(f, a, c, d); case 1: return Nr(f, a, c, d) }return Hr("Argument types not supported: " + (a ? mb[a.type] : "unknown") + " -> " + mb[b.type]) }
+			function Hu(a, b, c, d) { if (a.length !== b.length || b.some(function (k) { return 4 === k })) return Hr("Not supported: variadic function or mismatch in argument count"); if (0 === a.length) return Y("", { type: 0 }, []); var e = p(a); a = e.next().value; var f = ja(e); b = p(b); e = b.next().value; var g = ja(b); a = Kr(d, Gu(a, e, c, d), "arg"); return 0 === f.length ? a : Z(a, function (k) { var l = Hu(f, g, c, d); return Z(l, function (m) { return Y(k.code + ", " + m.code, { type: 0 }, [].concat(t(k.H), t(m.H))) }) }) }
+			function Iu(a, b) { return Z(a, function (c) { return (b ? 2 === b.g || 1 === b.g : 1) || ![0, 1].includes(b.type) && !B(b.type, 53) ? Hr("Function return type " + mb[b.type] + " not supported") : c }) }
+			function Ju(a, b, c) {
+				var d = Ug(L(a, "functionName")), e = d.localName, f = d.namespaceURI; d = O(L(a, "arguments"), "*"); var g = d.length, k = e + "#" + g, l = f === c.B; if (l) { var m = Du[k]; if (void 0 !== m) return m(a, b, c) } if ((a = Fu[l ? "" : f]) && !a.includes(k)) return Hr("Not supported: built-in function not on allow list: " + k); a = vg(f, e, g); if (!a) return Hr("Unknown function / arity: " + k); if (a.I) return Hr("Not supported: updating functions"); b = Hu(d, a.j, b, c); b = Z(b, function (q) {
+					return Y("runtimeLib.callFunction(domFacade, " + xu(f) + ", " + xu(e) +
+						", [" + q.code + "], options)", { type: 0 }, q.H)
+				}); return Iu(b, a.i)
+			} function Ku(a, b) { return Z(Kr(b, a, "contextItem"), function (c) { return Y(c.code, { type: 0 }, [].concat(t(c.H), ["if (" + c.code + " === undefined || " + c.code + " === null) {\n\t\t\t\t\tthrow errXPDY0002('The function which was called depends on dynamic context, which is absent.');\n\t\t\t\t}"])) }) }
+			function Lu(a, b, c, d) { if ((a = N(a, ["arguments", "*"])) && "contextItemExpr" !== a[0]) { var e = M(a, "type"); if (!e || !B(e.type, 53)) return Hr("name function only implemented if arg is a node"); a = p(c.h(a, b, c)); e = a.next().value; a.next(); a = e } else a = Ku(b, c); b = Jr(a, b, c); return Z(Kr(c, b, "arg"), function (f) { return Y("(" + f.code + " ? " + d(f.code) + " : '')", { type: 0 }, f.H) }) }
+			function Au(a, b, c) { return Lu(a, b, c, function (d) { return "(((" + d + ".prefix || '').length !== 0 ? " + d + ".prefix + ':' : '')\n\t\t+ (" + d + ".localName || " + d + ".target || ''))" }) } function zu(a, b, c) { return Lu(a, b, c, function (d) { return "(" + d + ".localName || " + d + ".target || '')" }) } function Bu(a, b, c) { var d = N(a, ["arguments", "*"]); a = M(d, "type"); d = p(c.h(d, b, c)); var e = d.next().value; d.next(); b = Lr(e, a, b, c); return Z(b, function (f) { return Y("!" + f.code, { type: 0 }, f.H) }) } function yu() { return Y("false", { type: 0 }, []) }
+			function Cu() { return Y("true", { type: 0 }, []) }; function Mu(a, b, c, d) { var e = p(Rr(a, "firstOperand", c, d)), f = e.next().value; e = e.next().value; var g = M(N(a, ["firstOperand", "*"]), "type"); f = Lr(f, g, c, d); g = p(Rr(a, "secondOperand", c, d)); var k = g.next().value; g = g.next().value; f = Z(f, function (l) { var m = M(N(a, ["secondOperand", "*"]), "type"); m = Lr(k, m, c, d); return Z(m, function (q) { return Y("(" + l.code + " " + b + " " + q.code + ")", { type: 0 }, [].concat(t(l.H), t(q.H))) }) }); e = "&&" === b ? Qh(e, g) : e === g ? e : null; return [f, e] }; function Nu(a, b, c) { return Z(a, function (d) { return Z(b, function (e) { return Z(c, function (f) { return Y("for (" + d.code + ") {\n\t\t\t\t\t\t" + e.H.join("\n") + "\n\t\t\t\t\t\tif (!(" + e.code + ")) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t" + f.H.join("\n") + "\n\t\t\t\t\t\t" + f.code + "\n\t\t\t\t\t}", { type: 2 }, d.H) }) }) }) }
+			function Ou(a, b, c, d, e) { var f = b ? ', "' + b + '"' : ""; b = Z(d, function (g) { return Z(e, function (k) { return Y("let " + g.code + " = domFacade.getFirstChild(" + k.code + f + ");\n\t\t\t\t\t\t\t" + g.code + ";\n\t\t\t\t\t\t\t" + g.code + " = domFacade.getNextSibling(" + g.code + f + ")", { type: 2 }, [].concat(t(g.H), t(k.H))) }) }); return Nu(b, a, c) }
+			function Pu(a, b, c, d, e) { var f = Qh(b, "type-2"), g = Z(e, function (k) { return Y("(" + k.code + " && " + k.code + ".nodeType === /*ELEMENT_NODE*/ 1 ? domFacade.getAllAttributes(" + k.code + (f ? ', "' + f + '"' : "") + ") : [])", { type: 0 }, k.H) }); b = Z(d, function (k) { return Z(g, function (l) { return Y("const " + k.code + " of " + l.code, { type: 2 }, [].concat(t(k.H), t(l.H))) }) }); return Nu(b, a, c) } function Qu(a, b, c, d, e) { var f = b ? ', "' + b + '"' : ""; b = Z(e, function (g) { return Y("domFacade.getParentNode(" + g.code + f + ")", { type: 0 }, g.H) }); return Ru(d, b, a, c) }
+			function Ru(a, b, c, d) { var e = Qr(a, c); return Z(a, function (f) { return Z(b, function (g) { return Z(e, function (k) { return Z(d, function (l) { return Y("const " + f.code + " = " + g.code + ";\n\t\t\t\t\t\t" + k.H.join("\n") + "\n\t\t\t\t\t\tif (" + k.code + ") {\n\t\t\t\t\t\t\t" + l.H.join("\n") + "\n\t\t\t\t\t\t\t" + l.code + "\n\t\t\t\t\t\t}", { type: 2 }, [].concat(t(f.H), t(g.H))) }) }) }) }) }
+			function Su(a, b, c, d, e, f) { a = Tg(a); switch (a) { case "attribute": return [Pu(b, c, d, e, f), "type-1"]; case "child": return [Ou(b, c, d, e, f), null]; case "parent": return [Qu(b, c, d, e, f), null]; case "self": return [Ru(e, f, b, d), c]; default: return [Hr("Unsupported: the " + a + " axis"), null] } }; var Tu = { dc: "textTest", Vb: "elementTest", $b: "nameTest", ec: "Wildcard", Sb: "anyKindTest" }, Uu = Object.values(Tu); function Vu(a) { return [Z(a, function (b) { return Y(b.code + ".nodeType === /*TEXT_NODE*/ 3", { type: 0 }, []) }), "type-3"] } function Wu(a, b) { if (null === a.namespaceURI && "*" !== a.prefix) { b = b.aa(a.prefix || "") || null; if (!b && a.prefix) throw Error("XPST0081: The prefix " + a.prefix + " could not be resolved."); a.namespaceURI = b } }
+			function Xu(a, b, c, d) {
+				Wu(a, d); var e = a.prefix, f = a.namespaceURI, g = a.localName; return Ir(c, function (k) {
+					var l = b ? Y(k.code + ".nodeType\n\t\t\t\t\t\t&& (" + k.code + ".nodeType === /*ELEMENT_NODE*/ 1\n\t\t\t\t\t\t|| " + k.code + ".nodeType === /*ATTRIBUTE_NODE*/ 2)", { type: 0 }, []) : Y(k.code + ".nodeType\n\t\t\t\t\t\t&& " + k.code + ".nodeType === /*ELEMENT_NODE*/ 1", { type: 0 }, []); if ("*" === e) return "*" === g ? [l, b ? "type-1-or-type-2" : "type-1"] : [Qr(l, Y(k.code + ".localName === " + xu(g), { type: 0 }, [])), "name-" + g]; l = "*" === g ? l : Qr(l, Y(k.code +
+						".localName === " + xu(g), { type: 0 }, [])); var m = Y(xu(f), { type: 0 }, []); m = "" === e && b ? Z(m, function (q) { return Y(k.code + ".nodeType === /*ELEMENT_NODE*/ 1 ? " + q.code + " : null", { type: 0 }, q.H) }) : m; m = Z(m, function (q) { return Y("(" + k.code + ".namespaceURI || null) === ((" + q.code + ") || null)", { type: 0 }, q.H) }); return [Qr(l, m), "name-" + g]
+				})
+			}
+			function Yu(a, b, c) { var d = (a = L(a, "elementName")) && L(a, "star"); if (null === a || d) return [Z(b, function (e) { return Y(e.code + ".nodeType === /*ELEMENT_NODE*/ 1", { type: 0 }, []) }), "type-1"]; a = Ug(L(a, "QName")); return Xu(a, !1, b, c) } function Zu(a) { return [Z(a, function (b) { return Y("!!" + b.code + ".nodeType", { type: 0 }, []) }), null] }
+			function $u(a, b, c, d) {
+				var e = a[0]; switch (e) {
+					case Tu.Vb: return Yu(a, c, d); case Tu.dc: return Vu(c); case Tu.$b: return Xu(Ug(a), b, c, d); case Tu.ec: return L(a, "star") ? (e = L(a, "uri"), null !== e ? a = Xu({ localName: "*", namespaceURI: Tg(e), prefix: "" }, b, c, d) : (e = L(a, "NCName"), a = "star" === L(a, "*")[0] ? Xu({ localName: Tg(e), namespaceURI: null, prefix: "*" }, b, c, d) : Xu({ localName: "*", namespaceURI: null, prefix: Tg(e) }, b, c, d))) : a = Xu({ localName: "*", namespaceURI: null, prefix: "*" }, b, c, d), a; case Tu.Sb: return Zu(c); default: return [Hr("Test not implemented: '" +
+						e), null]
+				}
+			}; function av(a, b, c) { var d = p(c.h(a, b, c)), e = d.next().value; d = d.next().value; return [Lr(e, M(a, "type"), b, c), d] }
+			function bv(a, b, c) {
+				a = a ? O(a, "*") : []; var d = p(a.reduce(function (e, f) { e = p(e); var g = e.next().value, k = e.next().value; if (!g) return av(f, b, c); var l = k; return Ir(g, function (m) { var q = p(av(f, b, c)), u = q.next().value; q = q.next().value; l = Qh(k, q); return [Z(u, function (z) { return Y(m.code + " && " + z.code, { type: 0 }, [].concat(t(m.H), t(z.H))) }), l] }) }, [null, null])); a = d.next().value; d = d.next().value; return [a ? Z(a, function (e) {
+					return Y("(function () {\n\t\t\t\t\t\t\t" + e.H.join("\n") + "\n\t\t\t\t\t\t\treturn " + e.code + ";\n\t\t\t\t\t\t})()",
+						{ type: 0 }, [])
+				}) : null, d]
+			}
+			function cv(a, b, c, d) {
+				if (0 === a.length) return [Z(c, function (q) { return Y("yield " + q.code + ";", { type: 2 }, q.H) }), null]; a = p(a); var e = a.next().value, f = ja(a); if (0 < O(e, "lookup").length) return [Hr("Unsupported: lookups"), null]; var g = vu(d, wu(d, "contextItem")); a = L(e, "predicates"); a = p(bv(a, g, d)); var k = a.next().value, l = a.next().value; if (a = L(e, "xpathAxis")) {
+					e = L(e, Uu); if (!e) return [Hr("Unsupported test in step"), null]; var m = Tg(a); b = "attribute" === m || "self" === m && b; m = p($u(e, b, g, d)); e = m.next().value; m = m.next().value; e = null ===
+						k ? e : Qr(e, k); l = Qh(m, l); b = p(cv(f, b, g, d)); m = b.next().value; b.next(); return Su(a, e, l, m, g, c)
+				} a = N(e, ["filterExpr", "*"]); if (!a) return [Hr("Unsupported: unknown step type"), null]; l = p(d.h(a, c, d)); a = l.next().value; l = l.next().value; return [Z(a, function (q) {
+					var u = 0 === f.length ? Y("", { type: 2 }, []) : Y("if (" + g.code + " !== null && !" + g.code + ".nodeType) {\n\t\t\t\t\t\t\t\t\tthrow new Error('XPTY0019: The result of E1 in a path expression E1/E2 should evaluate to a sequence of nodes.');\n\t\t\t\t\t\t\t\t}", { type: 2 }, []), z =
+						p(cv(f, !0, g, d)), A = z.next().value; z.next(); z = null === k ? A : Z(k, function (D) { return Z(A, function (F) { return Y("if (" + D.code + ") {\n\t\t\t\t\t\t\t\t\t" + F.H.join("\n") + "\n\t\t\t\t\t\t\t\t\t" + F.code + "\n\t\t\t\t\t\t\t\t}", { type: 2 }, D.H) }) }); return Z(z, function (D) {
+							switch (q.va.type) {
+								case 1: return Z(c, function (F) { return Y("for (const " + g.code + " of " + q.code + "(" + F.code + ")) {\n\t\t\t\t\t\t\t\t\t" + D.H.join("\n") + "\n\t\t\t\t\t\t\t\t\t" + D.code + "\n\t\t\t\t\t\t\t\t}", { type: 2 }, [].concat(t(g.H), t(q.H), t(u.H))) }); case 0: return Y("const " +
+									g.code + " = " + q.code + ";\n\t\t\t\t\t\t\t" + u.code + "\n\t\t\t\t\t\t\tif (" + g.code + " !== null) {\n\t\t\t\t\t\t\t\t" + D.H.join("\n") + "\n\t\t\t\t\t\t\t\t" + D.code + "\n\t\t\t\t\t\t\t}", { type: 2 }, [].concat(t(g.H), t(q.H), t(u.H))); default: return Hr("Unsupported generated code type for filterExpr")
+							}
+						})
+				}), l]
+			}
+			function dv(a) { return Z(a, function (b) { return Y("(function () {\n\t\t\t\tlet n = " + b.code + ";\n\t\t\t\twhile (n.nodeType !== /*DOCUMENT_NODE*/9) {\n\t\t\t\t\tn = domFacade.getParentNode(n);\n\t\t\t\t\tif (n === null) {\n\t\t\t\t\t\tthrow new Error('XPDY0050: the root node of the context node is not a document node.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn n;\n\t\t\t})()", { type: 0 }, b.H) }) }
+			function ev(a, b, c) { return Ir(b, function (d) { if (0 < O(a, "lookup").length) return [Hr("Unsupported: lookups"), null]; var e = L(a, "predicates"), f = p(bv(e, d, c)); e = f.next().value; f = f.next().value; var g = L(a, Uu); if (!g) return [Hr("Unsupported test in step"), null]; var k = p($u(g, !0, d, c)); g = k.next().value; k = k.next().value; e = null === e ? g : Qr(g, e); f = Qh(k, f); return [Z(e, function (l) { return Y("((" + l.code + ") ? " + d.code + " : null)", { type: 0 }, [].concat(t(d.H), t(l.H))) }), f] }) }
+			function fv(a, b, c) { var d = O(a, "stepExpr"); if (1 === d.length) { var e = L(d[0], "xpathAxis"); if (e && "self" === Tg(e)) return ev(d[0], b, c) } var f = vu(c, wu(c, "contextItem")); b = (a = L(a, "rootExpr")) ? Kr(c, dv(f), "root") : f; d = p(cv(d, !a, b, c)); c = d.next().value; d = d.next().value; return [Z(c, function (g) { return Y("(function* (" + f.code + ") {\n\t\t\t" + g.H.join("\n") + "\n\t\t\t" + g.code + "\n\t\t})", { type: 1 }, []) }), d] }; function gv(a, b, c) {
+				var d = a[0]; switch (d) {
+					case "contextItemExpr": return [b, null]; case "pathExpr": return fv(a, b, c); case "andOp": return Mu(a, "&&", b, c); case "orOp": return Mu(a, "||", b, c); case "stringConstantExpr": return a = L(a, "value")[1] || "", a = xu(a), [Y(a, { type: 0 }, []), null]; case "equalOp": case "notEqualOp": case "lessThanOrEqualOp": case "lessThanOp": case "greaterThanOrEqualOp": case "greaterThanOp": case "eqOp": case "neOp": case "ltOp": case "leOp": case "gtOp": case "geOp": case "isOp": case "nodeBeforeOp": case "nodeAfterOp": a: switch (d) {
+						case "eqOp": case "neOp": case "ltOp": case "leOp": case "gtOp": case "geOp": case "isOp": a =
+							Wr(a, d, b, c); break a; case "equalOp": case "notEqualOp": case "lessThanOrEqualOp": case "lessThanOp": case "greaterThanOrEqualOp": case "greaterThanOp": var e = M(N(a, ["firstOperand", "*"]), "type"), f = M(N(a, ["secondOperand", "*"]), "type"); a = e && f ? 3 === e.g && 3 === f.g ? Wr(a, Tr[d], b, c) : 3 === e.g ? Xr(a, "firstOperand", "secondOperand", Tr[d], b, c) : 3 === f.g ? Xr(a, "secondOperand", "firstOperand", Vr[Tr[d]], b, c) : Hr("General comparison for sequences is not implemented") : Hr("types of compare are not known"); break a; default: a = Hr("Unsupported compare type: " +
+								d)
+					}return [a, null]; case "functionCallExpr": return [Ju(a, b, c), null]; default: return [Hr("Unsupported: the base expression '" + d + "'."), null]
+				}
+			}; function hv(a, b) { this.o = new Map; this.v = new Map; this.aa = a; this.B = b; this.h = gv } function Kr(a, b, c) { return Z(b, function (d) { var e = a.o.get(d); e || (e = wu(a, c), e = Y(e, d.va, [].concat(t(d.H), ["const " + e + " = " + d.code + ";"])), a.o.set(d, e), a.o.set(e, e)); return e }) } function vu(a, b) { b = Y(b, { type: 0 }, []); a.o.set(b, b); return b } function wu(a, b) { b = void 0 === b ? "v" : b; var c = a.v.get(b) || 0; a.v.set(b, c + 1); return b + c }; function iv(a) { var b = O(a, "*"); if ("pathExpr" === a[0]) return !0; a = p(b); for (b = a.next(); !b.done; b = a.next())if (iv(b.value)) return !0; return !1 }; function jv(a, b, c) {
+				c = c || {}; b = b || 0; if ("string" === typeof a) { a = hl(a); var d = { $: "XQuery3.1" === c.language || "XQueryUpdate3.1" === c.language, debug: !1 }; try { var e = Jq(a, d) } catch (k) { pg(a, k) } } else e = Rk(a); a = L(e, "mainModule"); if (!a) return Hr("Unsupported: XQuery Library modules are not supported."); if (L(a, "prolog")) return Hr("Unsupported: XQuery Prologs are not supported."); d = void 0 === c.defaultFunctionNamespaceURI ? "http://www.w3.org/2005/xpath-functions" : c.defaultFunctionNamespaceURI; a = new hv(c.namespaceResolver ||
+					er(null), d); c = new Jh(new Lg(new zg(a.aa, {}, d, c.functionNameResolver || fr("http://www.w3.org/2005/xpath-functions")))); oh(e, c); if (c = L(e, "mainModule")) if (L(c, "prolog")) a = Hr("Unsupported: XQuery."); else {
+						var f = N(c, ["queryBody", "*"]); c = vu(a, "contextItem"); var g = p(a.h(f, c, a)); d = g.next().value; g.next(); b: switch (f = M(f, "type"), b) { case 9: b = Jr(d, c, a); a = Or(b, f, a); break b; case 7: a = Pr(d, f, c, a); break b; case 3: a = Lr(d, f, c, a); break b; case 2: a = Nr(d, f, c, a); break b; default: a = Hr("Unsupported: the return type '" + b + "'.") }a.isAstAccepted &&
+							(a = "\n\t\t" + a.H.join("\n") + "\n\t\treturn " + a.code + ";", b = "\n\treturn (contextItem, domFacade, runtimeLib, options) => {\n\t\tconst {\n\t\t\terrXPDY0002,\n\t\t} = runtimeLib;", iv(e) && (b += '\n\t\tif (!contextItem) {\n\t\t\tthrow errXPDY0002("Context is needed to evaluate the given path expression.");\n\t\t}\n\n\t\tif (!contextItem.nodeType) {\n\t\t\tthrow new Error("Context item must be subtype of node().");\n\t\t}\n\t\t'), a = { code: b + (a + "}\n//# sourceURL=generated.js"), isAstAccepted: !0 })
+					} else a = Hr("Unsupported: Can not execute a library module.");
+				return a
+			}; function kv(a, b, c) { var d = a.stack; d && (d.includes(a.message) && (d = d.substr(d.indexOf(a.message) + a.message.length).trim()), d = d.split("\n"), d.splice(10), d = d.map(function (e) { return e.startsWith("    ") || e.startsWith("\t") ? e : "    " + e }), d = d.join("\n")); a = Error.call(this, "Custom XPath function Q{" + c + "}" + b + " raised:\n" + a.message + "\n" + d); this.message = a.message; "stack" in a && (this.stack = a.stack) } v(kv, Error);
+			function lv(a, b, c) { return 0 === b.g ? a.G() ? null : ir(a.first(), c).next(0).value : 2 === b.g || 1 === b.g ? a.O().map(function (d) { if (B(d.type, 47)) throw Error("Cannot pass attribute nodes to custom functions"); return ir(d, c).next(0).value }) : ir(a.first(), c).next(0).value }
+			function mv(a) { if ("object" === typeof a) return a; a = a.split(":"); if (2 !== a.length) throw Error("Do not register custom functions in the default function namespace"); var b = p(a); a = b.next().value; b = b.next().value; var c = yg[a]; if (!c) { c = "generated_namespace_uri_" + a; if (yg[a]) throw Error("Prefix already registered: Do not register the same prefix twice."); yg[a] = c } return { localName: b, namespaceURI: c } }
+			function nv(a, b, c, d) { a = mv(a); var e = a.namespaceURI, f = a.localName; if (!e) throw Eg(); var g = b.map(function (l) { return qb(l) }), k = qb(c); wg(e, f, g, k, function (l, m, q) { var u = Array.from(arguments); u.splice(0, 3); u = u.map(function (D, F) { return lv(D, g[F], m) }); var z = {}; z = (z.currentContext = m.l, z.domFacade = m.h.h, z); try { var A = d.apply(void 0, [z].concat(t(u))) } catch (D) { throw new kv(D, f, e); } return A && "object" === typeof A && Object.getOwnPropertySymbols(A).includes(cr) ? C.create(A.Hb) : Ec(m.h, A, k) }) }; var ov = { callFunction: function (a, b, c, d, e) { var f = vg(b, c, d.length); if (!f) throw Error("function not found for codegen function call"); b = new Hc({ N: null, Ka: 0, Da: C.empty(), Aa: {} }); var g = new Mb(a); a = new Oc(!1, !1, g, null, null, e ? e.currentContext : null, null); d = f.callFunction.apply(f, [b, a, null].concat(t(d.map(function (k, l) { return Ec(g, k, f.j[l]) })))); return lv(d, { type: 59, g: 0 }, a) }, errXPDY0002: Rc }; function pv(a, b, c, d) { c = c ? c : new Gb; return a()(null !== b && void 0 !== b ? b : null, c, ov, d) }; var qv = {}, rv = (qv["http://www.w3.org/2005/XQueryX"] = "xqx", qv["http://www.w3.org/2007/xquery-update-10"] = "xquf", qv["http://fontoxml.com/fontoxpath"] = "x", qv);
+			function sv(a, b) {
+				switch (a) {
+					case "copySource": case "insertAfter": case "insertAsFirst": case "insertAsLast": case "insertBefore": case "insertInto": case "modifyExpr": case "newNameExpr": case "replacementExpr": case "replaceValue": case "returnExpr": case "sourceExpr": case "targetExpr": case "transformCopies": case "transformCopy": return { localName: a, ub: b || "http://www.w3.org/2005/XQueryX" }; case "deleteExpr": case "insertExpr": case "renameExpr": case "replaceExpr": case "transformExpr": return { localName: a, ub: "http://www.w3.org/2007/xquery-update-10" };
+					case "x:stackTrace": return { localName: "stackTrace", ub: "http://fontoxml.com/fontoxpath" }; default: return { localName: a, ub: "http://www.w3.org/2005/XQueryX" }
+				}
+			}
+			function tv(a, b, c, d, e) {
+				if ("string" === typeof c) return 0 === c.length ? null : b.createTextNode(c); if (!Array.isArray(c)) throw new TypeError("JsonML element should be an array or string"); d = sv(c[0], d); var f = d.localName; d = d.ub; var g = b.createElementNS(d, rv[d] + ":" + f), k = c[1], l = 1; if ("object" === typeof k && !Array.isArray(k)) {
+					if (null !== k) {
+						l = p(Object.keys(k)); for (var m = l.next(); !m.done; m = l.next()) {
+							m = m.value; var q = k[m]; null !== q && ("type" === m ? void 0 !== q && a.setAttributeNS(g, d, "fontoxpath:" + m, ob(q)) : ("start" !== m && "end" !==
+								m || "stackTrace" !== f || (q = JSON.stringify(q)), e && "prefix" === m && "" === q || a.setAttributeNS(g, d, rv[d] + ":" + m, q)))
+						}
+					} l = 2
+				} f = l; for (k = c.length; f < k; ++f)l = tv(a, b, c[f], d, e), null !== l && a.insertBefore(g, l, null); return g
+			}
+			function uv(a, b, c, d) {
+				d = void 0 === d ? Ib : d; a = hl(a); try { var e = Jq(a, { $: "XQuery3.1" === b.language || "XQueryUpdate3.1" === b.language, debug: b.debug }) } catch (m) { pg(a, m) } var f = new zg(b.namespaceResolver || function () { return null }, {}, void 0 === b.defaultFunctionNamespaceURI ? "http://www.w3.org/2005/xpath-functions" : b.defaultFunctionNamespaceURI, b.functionNameResolver || function () { return null }); f = new Lg(f); var g = L(e, ["mainModule", "libraryModule"]), k = L(g, "moduleDecl"); if (k) {
+					var l = Tg(L(k, "prefix")); k = Tg(L(k, "uri")); Pg(f,
+						l, k)
+				} (g = L(g, "prolog")) && Mq(g, f, !1, a); !1 !== b.annotateAst && Bh(e, new Jh(f)); f = new Gb; b = tv(d, c, e, null, !1 === b.wc); d.insertBefore(b, c.createComment(a), f.getFirstChild(b)); return b
+			}; function vv(a) { return Promise.resolve(a) }; function wv(a, b) {
+				b = void 0 === b ? { debug: !1 } : b; b = Jq(a, { $: !0, debug: b.debug }); Bh(b, new Jh(void 0)); b = L(b, "libraryModule"); if (!b) throw Error("XQuery module must be declared in a library module."); var c = L(b, "moduleDecl"), d = L(c, "uri"), e = Tg(d); c = L(c, "prefix"); d = Tg(c); c = new Lg(new zg(function () { return null }, Object.create(null), "http://www.w3.org/2005/xpath-functions", fr("http://www.w3.org/2005/xpath-functions"))); Pg(c, d, e); b = L(b, "prolog"); if (null !== b) {
+					try { var f = Mq(b, c, !0, a) } catch (g) { pg(a, g) } f.Ma.forEach(function (g) {
+						if (e !==
+							g.namespaceURI) throw Error("XQST0048: Functions and variables declared in a module must reside in the module target namespace.");
+					}); Tk(e, f)
+				} else Tk(e, { Ma: [], Va: [], ra: null, source: a }); return e
+			}; var xv = new Map; function yv(a) { var b; a: { if (b = Nk.get(a)) for (var c = p(Object.keys(b)), d = c.next(); !d.done; d = c.next())if (d = d.value, b[d] && b[d].length) { b = b[d][0].h; break a } b = null } if (b) return b; if (xv.has(a)) return xv.get(a); b = "string" === typeof a ? Jq(a, { $: !1 }) : Rk(a); b = N(b, ["mainModule", "queryBody", "*"]); if (null === b) throw Error("Library modules do not have a specificity"); b = Mk(b, { ua: !1, $: !1 }); xv.set(a, b); return b } function zv(a) { return yv(a).B() } function Av(a, b) { return If(yv(a).o, yv(b).o) } var Bv = new Gb;
+			"undefined" !== typeof fontoxpathGlobal && (fontoxpathGlobal.compareSpecificity = Av, fontoxpathGlobal.compileXPathToJavaScript = jv, fontoxpathGlobal.domFacade = Bv, fontoxpathGlobal.evaluateXPath = rr, fontoxpathGlobal.evaluateXPathToArray = xr, fontoxpathGlobal.evaluateXPathToAsyncIterator = tr, fontoxpathGlobal.evaluateXPathToBoolean = yr, fontoxpathGlobal.evaluateXPathToFirstNode = zr, fontoxpathGlobal.evaluateXPathToMap = Ar, fontoxpathGlobal.evaluateXPathToNodes = Br, fontoxpathGlobal.evaluateXPathToNumber = Cr, fontoxpathGlobal.evaluateXPathToNumbers =
+				Dr, fontoxpathGlobal.evaluateXPathToString = Er, fontoxpathGlobal.evaluateXPathToStrings = Fr, fontoxpathGlobal.evaluateUpdatingExpression = vr, fontoxpathGlobal.evaluateUpdatingExpressionSync = wr, fontoxpathGlobal.executeJavaScriptCompiledXPath = pv, fontoxpathGlobal.executePendingUpdateList = Gr, fontoxpathGlobal.getBucketForSelector = zv, fontoxpathGlobal.getBucketsForNode = Fb, fontoxpathGlobal.precompileXPath = vv, fontoxpathGlobal.registerXQueryModule = wv, fontoxpathGlobal.registerCustomXPathFunction = nv, fontoxpathGlobal.parseScript =
+				uv, fontoxpathGlobal.profiler = or, fontoxpathGlobal.createTypedValueFactory = dr, fontoxpathGlobal.finalizeModuleRegistration = Vk, fontoxpathGlobal.Language = qr, fontoxpathGlobal.ReturnType = kr);
+			return fontoxpathGlobal;
+		})(xspattern, prsc);
+	});
+
+}
+/**! End hide-if-matches-xpath3 dependency !**/
diff --git a/components/adblock/core/resources/snippets/dist/isolated-first-all.source.jst b/components/adblock/core/resources/snippets/dist/isolated-first-all.source.jst
new file mode 100644
--- /dev/null
+++ b/components/adblock/core/resources/snippets/dist/isolated-first-all.source.jst
@@ -0,0 +1,5256 @@
+/*!
+ * snippets v2.0.0
+ * https://gitlab.com/eyeo/anti-cv/snippets/-/blob/v2.0.0/dist/isolated-first-all.source.jst?ref_type=heads
+ */
+(e, ...t) => {
+/*!
+ * This file is part of eyeo's Anti-Circumvention Snippets module (@eyeo/snippets),
+ * Copyright (C) 2006-present eyeo GmbH
+ *
+ * @eyeo/snippets is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * @eyeo/snippets is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with @eyeo/snippets.  If not, see <http://www.gnu.org/licenses/>.
+ */
+  ((environment, ...filters) => {
+  /*!
+   * This file is part of eyeo's Anti-Circumvention Snippets module (@eyeo/snippets),
+   * Copyright (C) 2006-present eyeo GmbH
+   *
+   * @eyeo/snippets is free software: you can redistribute it and/or modify
+   * it under the terms of the GNU General Public License version 3 as
+   * published by the Free Software Foundation.
+   *
+   * @eyeo/snippets is distributed in the hope that it will be useful,
+   * but WITHOUT ANY WARRANTY; without even the implied warranty of
+   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   * GNU General Public License for more details.
+   *
+   * You should have received a copy of the GNU General Public License
+   * along with @eyeo/snippets.  If not, see <http://www.gnu.org/licenses/>.
+   */
+  const $$1 = Proxy;
+
+  const {apply: a, bind: b, call: c} = Function;
+  const apply$2 = c.bind(a);
+  const bind = c.bind(b);
+  const call = c.bind(c);
+
+  const callerHandler = {
+    get(target, name) {
+      return bind(c, target[name]);
+    }
+  };
+  const caller = target => new $$1(target, callerHandler);
+
+  const handler$2 = {
+    get(target, name) {
+      return bind(target[name], target);
+    }
+  };
+  const bound = target => new $$1(target, handler$2);
+
+  const {
+    assign: assign$1,
+    defineProperties: defineProperties$1,
+    freeze: freeze$1,
+    getOwnPropertyDescriptor: getOwnPropertyDescriptor$2,
+    getOwnPropertyDescriptors: getOwnPropertyDescriptors$1,
+    getPrototypeOf
+  } = bound(Object);
+
+  const {hasOwnProperty} = caller({});
+
+  const {species} = Symbol;
+
+  const handler$1 = {
+    get(target, name) {
+      const Native = target[name];
+      class Secure extends Native {}
+
+      const proto = getOwnPropertyDescriptors$1(Native.prototype);
+      delete proto.constructor;
+      freeze$1(defineProperties$1(Secure.prototype, proto));
+
+      const statics = getOwnPropertyDescriptors$1(Native);
+      delete statics.length;
+      delete statics.prototype;
+      statics[species] = {value: Secure};
+      return freeze$1(defineProperties$1(Secure, statics));
+    }
+  };
+
+  const secure = target => new $$1(target, handler$1);
+
+  const libEnvironment = typeof environment !== "undefined" ? environment :
+                                                                     {};
+
+  if (typeof globalThis === "undefined")
+    window.globalThis = window;
+
+  const {apply: apply$1, ownKeys} = bound(Reflect);
+
+  const worldEnvDefined = "world" in libEnvironment;
+  const isIsolatedWorld = worldEnvDefined && libEnvironment.world === "ISOLATED";
+  const isMainWorld = worldEnvDefined && libEnvironment.world === "MAIN";
+  const isChrome = typeof chrome === "object" && !!chrome.runtime;
+  const isOtherThanChrome = typeof browser === "object" && !!browser.runtime;
+  const isExtensionContext$2 = !isMainWorld &&
+    (isIsolatedWorld || isChrome || isOtherThanChrome);
+  const copyIfExtension = value => isExtensionContext$2 ?
+    value :
+    create(value, getOwnPropertyDescriptors(value));
+
+  const {
+    create,
+    defineProperties,
+    defineProperty,
+    freeze,
+    getOwnPropertyDescriptor: getOwnPropertyDescriptor$1,
+    getOwnPropertyDescriptors
+  } = bound(Object);
+
+  const invokes = bound(globalThis);
+  const classes = isExtensionContext$2 ? globalThis : secure(globalThis);
+  const {Map: Map$6, RegExp: RegExp$1, Set, WeakMap: WeakMap$3, WeakSet: WeakSet$a} = classes;
+
+  const augment = (source, target, method = null) => {
+    const known = ownKeys(target);
+    for (const key of ownKeys(source)) {
+      if (known.includes(key))
+        continue;
+
+      const descriptor = getOwnPropertyDescriptor$1(source, key);
+      if (method && "value" in descriptor) {
+        const {value} = descriptor;
+        if (typeof value === "function")
+          descriptor.value = method(value);
+      }
+      defineProperty(target, key, descriptor);
+    }
+  };
+
+  const primitive = name => {
+    const Super = classes[name];
+    class Class extends Super {}
+    const {toString, valueOf} = Super.prototype;
+    defineProperties(Class.prototype, {
+      toString: {value: toString},
+      valueOf: {value: valueOf}
+    });
+    const type = name.toLowerCase();
+    const method = callback => function() {
+      const result = apply$1(callback, this, arguments);
+      return typeof result === type ? new Class(result) : result;
+    };
+    augment(Super, Class, method);
+    augment(Super.prototype, Class.prototype, method);
+    return Class;
+  };
+
+  const variables$1 = freeze({
+    frozen: new WeakMap$3(),
+    hidden: new WeakSet$a(),
+    iframePropertiesToAbort: {
+      read: new Set(),
+      write: new Set()
+    },
+    abortedIframes: new WeakMap$3()
+  });
+
+  const startsCapitalized = new RegExp$1("^[A-Z]");
+
+  var env = new Proxy(new Map$6([
+
+    ["chrome", (
+      isExtensionContext$2 && (
+        (isChrome && chrome) ||
+        (isOtherThanChrome && browser)
+      )
+    ) || void 0],
+    ["isExtensionContext", isExtensionContext$2],
+    ["variables", variables$1],
+
+    ["console", copyIfExtension(console)],
+    ["document", globalThis.document],
+    ["JSON", copyIfExtension(JSON)],
+    ["Map", Map$6],
+    ["Math", copyIfExtension(Math)],
+    ["Number", isExtensionContext$2 ? Number : primitive("Number")],
+    ["RegExp", RegExp$1],
+    ["Set", Set],
+    ["String", isExtensionContext$2 ? String : primitive("String")],
+    ["WeakMap", WeakMap$3],
+    ["WeakSet", WeakSet$a],
+
+    ["MouseEvent", MouseEvent]
+  ]), {
+    get(map, key) {
+      if (map.has(key))
+        return map.get(key);
+
+      let value = globalThis[key];
+      if (typeof value === "function")
+        value = (startsCapitalized.test(key) ? classes : invokes)[key];
+
+      map.set(key, value);
+      return value;
+    },
+    has(map, key) {
+      return map.has(key);
+    }
+  });
+
+  class WeakValue {
+    has() { return false; }
+    set() {}
+  }
+
+  const helpers = {WeakSet, WeakMap, WeakValue};
+  const {apply} = Reflect;
+
+  function transformOnce (callback) {  const {WeakSet, WeakMap, WeakValue} = (this || helpers);
+    const ws = new WeakSet;
+    const wm = new WeakMap;
+    const wv = new WeakValue;
+    return function (any) {
+      if (ws.has(any))
+        return any;
+
+      if (wm.has(any))
+        return wm.get(any);
+
+      if (wv.has(any))
+        return wv.get(any);
+
+      const value = apply(callback, this, arguments);
+      ws.add(value);
+      if (value !== any)
+        (typeof any === 'object' && any ? wm : wv).set(any, value);
+      return value;
+    };
+  }
+
+  const {Map: Map$5, WeakMap: WeakMap$2, WeakSet: WeakSet$9, setTimeout: setTimeout$3} = env;
+
+  let cleanup = true;
+  let cleanUpCallback = map => {
+    map.clear();
+    cleanup = !cleanup;
+  };
+
+  var transformer = transformOnce.bind({
+    WeakMap: WeakMap$2,
+    WeakSet: WeakSet$9,
+
+    WeakValue: class extends Map$5 {
+      set(key, value) {
+        if (cleanup) {
+          cleanup = !cleanup;
+          setTimeout$3(cleanUpCallback, 0, this);
+        }
+        return super.set(key, value);
+      }
+    }
+  });
+
+  const {concat, includes, join, reduce, unshift} = caller([]);
+
+  const {Map: Map$4, WeakMap: WeakMap$1} = secure(globalThis);
+
+  const map = new Map$4;
+  const descriptors = target => {
+    const chain = [];
+    let current = target;
+    while (current) {
+      if (map.has(current))
+        unshift(chain, map.get(current));
+      else {
+        const descriptors = getOwnPropertyDescriptors$1(current);
+        map.set(current, descriptors);
+        unshift(chain, descriptors);
+      }
+      current = getPrototypeOf(current);
+    }
+    unshift(chain, {});
+    return apply$2(assign$1, null, chain);
+  };
+
+  const chain = source => {
+    const target = typeof source === 'function' ? source.prototype : source;
+    const chained = descriptors(target);
+    const handler = {
+      get(target, key) {
+        if (key in chained) {
+          const {value, get} = chained[key];
+          if (get)
+            return call(get, target);
+          if (typeof value === 'function')
+            return bind(value, target);
+        }
+        return target[key];
+      },
+      set(target, key, value) {
+        if (key in chained) {
+          const {set} = chained[key];
+          if (set) {
+            call(set, target, value);
+            return true;
+          }
+        }
+        target[key] = value;
+        return true;
+      }
+    };
+    return target => new Proxy(target, handler);
+  };
+
+  const {
+    isExtensionContext: isExtensionContext$1,
+    Array: Array$3,
+    Number: Number$1,
+    String: String$1,
+    Object: Object$2
+  } = env;
+
+  const {isArray} = Array$3;
+  const {getOwnPropertyDescriptor, setPrototypeOf: setPrototypeOf$1} = Object$2;
+
+  const {toString} = Object$2.prototype;
+  const {slice} = String$1.prototype;
+  const getBrand = value => call(slice, call(toString, value), 8, -1);
+
+  const {get: nodeType} = getOwnPropertyDescriptor(Node.prototype, "nodeType");
+
+  const chained = isExtensionContext$1 ? {} : {
+    Attr: chain(Attr),
+    CanvasRenderingContext2D: chain(CanvasRenderingContext2D),
+    CSSStyleDeclaration: chain(CSSStyleDeclaration),
+    Document: chain(Document),
+    Element: chain(Element),
+    HTMLCanvasElement: chain(HTMLCanvasElement),
+    HTMLElement: chain(HTMLElement),
+    HTMLImageElement: chain(HTMLImageElement),
+    HTMLScriptElement: chain(HTMLScriptElement),
+    MutationRecord: chain(MutationRecord),
+    Node: chain(Node),
+    ShadowRoot: chain(ShadowRoot),
+
+    get CSS2Properties() {
+      return chained.CSSStyleDeclaration;
+    }
+  };
+
+  const upgrade = (value, hint) => {
+    if (hint !== "Element" && hint in chained)
+      return chained[hint](value);
+
+    if (isArray(value))
+      return setPrototypeOf$1(value, Array$3.prototype);
+
+    const brand = getBrand(value);
+    if (brand in chained)
+      return chained[brand](value);
+
+    if (brand in env)
+      return setPrototypeOf$1(value, env[brand].prototype);
+
+    if ("nodeType" in value) {
+      switch (call(nodeType, value)) {
+        case 1:
+          if (!(hint in chained))
+            throw new Error("unknown hint " + hint);
+          return chained[hint](value);
+        case 2:
+          return chained.Attr(value);
+        case 3:
+          return chained.Node(value);
+        case 9:
+          return chained.Document(value);
+      }
+    }
+
+    throw new Error("unknown brand " + brand);
+  };
+
+  var $ = isExtensionContext$1 ?
+    value => (value === window || value === globalThis ? env : value) :
+    transformer((value, hint = "Element") => {
+      if (value === window || value === globalThis)
+        return env;
+
+      switch (typeof value) {
+        case "object":
+          return value && upgrade(value, hint);
+
+        case "string":
+          return new String$1(value);
+
+        case "number":
+          return new Number$1(value);
+
+        default:
+          throw new Error("unsupported value");
+      }
+    });
+
+  let debugging = false;
+
+  function debug() {
+    return debugging;
+  }
+
+  function setDebug() {
+    debugging = true;
+  }
+
+  let {
+    console: console$2,
+    document: document$1,
+    getComputedStyle: getComputedStyle$5,
+    isExtensionContext,
+    variables,
+    Array: Array$2,
+    MutationObserver: MutationObserver$a,
+    Object: Object$1,
+    XPathEvaluator,
+    XPathExpression,
+    XPathResult
+  } = $(window);
+
+  const {querySelectorAll} = document$1;
+  const document$$ = querySelectorAll && bind(querySelectorAll, document$1);
+
+  function $openOrClosedShadowRoot(element, failSilently = false) {
+    try {
+      const shadowRoot = (navigator.userAgent.includes("Firefox")) ?
+        element.openOrClosedShadowRoot :
+        browser.dom.openOrClosedShadowRoot(element);
+      if (shadowRoot === null && ((debug() && !failSilently)))
+        console$2.log("Shadow root not found or not added in element yet", element);
+      return shadowRoot;
+    }
+    catch (error) {
+      if (debug() && !failSilently)
+        console$2.log("Error while accessing shadow root", element, error);
+      return null;
+    }
+  }
+
+  function $$(selector, returnRoots = false) {
+
+    return $$recursion(
+      selector,
+      document$$.bind(document$1),
+      document$1,
+      returnRoots
+    );
+  }
+
+  function isArrayEmptyStrings(arr) {
+    return !arr || arr.length === 0 || arr.every(item => item.trim() === "");
+  }
+
+  function executeSvgCommand(
+    nestedCommands,
+    rootParent,
+    resultNodes,
+    rootParents
+  ) {
+    const xlinkHref = rootParent.getAttribute("xlink:href") ||
+            rootParent.getAttribute("href");
+    if (xlinkHref) {
+      const matchingElement = document$$(xlinkHref)[0];
+      if (!matchingElement && debug()) {
+        console$2.log("No elements found matching", xlinkHref);
+        return false;
+      }
+
+      if (isArrayEmptyStrings(nestedCommands)) {
+        const oldRootParents = rootParents.length > 0 ? rootParents : [];
+        resultNodes.push({
+          element: matchingElement,
+          rootParents: [...oldRootParents, rootParent]
+        });
+        return false;
+      }
+      const next$$ = matchingElement.querySelectorAll.bind(matchingElement);
+      return {
+        nextBoundElement: matchingElement,
+        nestedSelectorsString: nestedCommands.join("^^"),
+        next$$
+      };
+    }
+  }
+
+  function executeShadowRootCommand(nestedCommands, rootParent) {
+    const shadowRoot = $openOrClosedShadowRoot(rootParent);
+    if (shadowRoot) {
+      const {querySelectorAll: shadowRootQuerySelectorAll} = shadowRoot;
+      const next$$ = shadowRootQuerySelectorAll &&
+        bind(shadowRootQuerySelectorAll, shadowRoot).bind(shadowRoot);
+      return {
+        nextBoundElement: rootParent,
+        nestedSelectorsString: ":host " + nestedCommands.join("^^"),
+        next$$
+      };
+    }
+
+    return false;
+  }
+
+  function $$recursion(
+    selector,
+    bound$$,
+    boundElement,
+    returnRoots,
+    rootParents = []
+  ) {
+    if (selector.includes("^^")) {
+      const [currentSelector, currentCommand, ...nestedCommands] =
+        selector.split("^^");
+      let newRootParents;
+
+      let commandFn;
+      switch (currentCommand) {
+        case "svg": {
+          commandFn = executeSvgCommand;
+          break;
+        }
+        case "sh": {
+          commandFn = executeShadowRootCommand;
+          break;
+        }
+        default: {
+          if (debug()) {
+            console$2.log(
+              currentCommand,
+              " is not supported. Supported commands are: \n^^sh^^\n^^svg^^"
+            );
+          }
+          return [];
+        }
+      }
+
+      if (currentSelector.trim() === "")
+        newRootParents = [boundElement];
+      else
+        newRootParents = bound$$(currentSelector);
+
+      const resultNodes = [];
+
+      for (const rootParent of newRootParents) {
+        const res =
+          commandFn(nestedCommands, rootParent, resultNodes, rootParents);
+        if (!res)
+          continue;
+        const {next$$, nestedSelectorsString, nextBoundElement} = res;
+        const nestedElements = $$recursion(
+          nestedSelectorsString,
+          next$$,
+          nextBoundElement,
+          returnRoots,
+          [...rootParents, rootParent]
+        );
+        if (nestedElements)
+          resultNodes.push(...nestedElements);
+      }
+      return resultNodes;
+    }
+    const foundElements = bound$$(selector);
+    if (returnRoots) {
+      return [...foundElements].map(element => (
+        {element, rootParents: rootParents.length > 0 ? rootParents : []})
+      );
+    }
+    return foundElements;
+  }
+
+  function $closest(element, selector, shadowRootParents = []) {
+    if (selector.includes("^^svg^^"))
+      selector = selector.split("^^svg^^")[0];
+
+    if (selector.includes("^^sh^^")) {
+
+      const splitSelector = selector.split("^^sh^^");
+      const numShadowRootsToCross = splitSelector.length - 1;
+      selector = `:host ${splitSelector[numShadowRootsToCross]}`;
+
+      if (numShadowRootsToCross === shadowRootParents.length) {
+
+        return element.closest(selector);
+      }
+
+      const shadowRootParent = shadowRootParents[numShadowRootsToCross];
+      return shadowRootParent.closest(selector);
+    }
+    if (shadowRootParents[0])
+      return shadowRootParents[0].closest(selector);
+    return element.closest(selector);
+  }
+
+  function $childNodes(element, failSilently = true) {
+    const shadowRoot = $openOrClosedShadowRoot(element, failSilently);
+    if (shadowRoot)
+      return shadowRoot.childNodes;
+
+    return $(element).childNodes;
+  }
+
+  const {assign, setPrototypeOf} = Object$1;
+
+  class $XPathExpression extends XPathExpression {
+    evaluate(...args) {
+      return setPrototypeOf(
+        apply$2(super.evaluate, this, args),
+        XPathResult.prototype
+      );
+    }
+  }
+
+  class $XPathEvaluator extends XPathEvaluator {
+    createExpression(...args) {
+      return setPrototypeOf(
+        apply$2(super.createExpression, this, args),
+        $XPathExpression.prototype
+      );
+    }
+  }
+
+  function hideElement(element) {
+    if (variables.hidden.has(element))
+      return false;
+
+    notifyElementHidden(element);
+
+    variables.hidden.add(element);
+
+    let {style} = $(element);
+    let $style = $(style, "CSSStyleDeclaration");
+    let properties = $([]);
+    let {debugCSSProperties} = libEnvironment;
+
+    for (let [key, value] of (debugCSSProperties || [["display", "none"]])) {
+      $style.setProperty(key, value, "important");
+      properties.push([key, $style.getPropertyValue(key)]);
+    }
+
+    new MutationObserver$a(() => {
+      for (let [key, value] of properties) {
+        let propertyValue = $style.getPropertyValue(key);
+        let propertyPriority = $style.getPropertyPriority(key);
+        if (propertyValue != value || propertyPriority != "important")
+          $style.setProperty(key, value, "important");
+      }
+    }).observe(element, {attributes: true,
+                         attributeFilter: ["style"]});
+    return true;
+  }
+
+  function notifyElementHidden(element) {
+    if (isExtensionContext && typeof checkElement === "function")
+      checkElement(element);
+  }
+
+  function initQueryAndApply(selector) {
+    let $selector = selector;
+    if ($selector.startsWith("xpath(") &&
+        $selector.endsWith(")")) {
+      let xpathQuery = $selector.slice(6, -1);
+      let evaluator = new $XPathEvaluator();
+      let expression = evaluator.createExpression(xpathQuery, null);
+
+      let flag = XPathResult.ORDERED_NODE_SNAPSHOT_TYPE;
+
+      return cb => {
+        if (!cb)
+          return;
+        let result = expression.evaluate(document$1, flag, null);
+        let {snapshotLength} = result;
+        for (let i = 0; i < snapshotLength; i++)
+          cb(result.snapshotItem(i));
+      };
+    }
+    return cb => $$(selector).forEach(cb);
+  }
+
+  function initQueryAll(selector) {
+    let $selector = selector;
+    if ($selector.startsWith("xpath(") &&
+        $selector.endsWith(")")) {
+      let queryAndApply = initQueryAndApply(selector);
+      return () => {
+        let elements = $([]);
+        queryAndApply(e => elements.push(e));
+        return elements;
+      };
+    }
+    return () => Array$2.from($$(selector));
+  }
+
+  function hideIfMatches(match, selector, searchSelector, onHideCallback) {
+    if (searchSelector == null)
+      searchSelector = selector;
+
+    let won;
+    const callback = () => {
+      for (const {element, rootParents} of $$(searchSelector, true)) {
+        const closest = $closest($(element), selector, rootParents);
+        if (closest && match(element, closest, rootParents)) {
+          won();
+          if (hideElement(closest) && typeof onHideCallback === "function")
+            onHideCallback(closest);
+        }
+      }
+    };
+    return assign(
+      new MutationObserver$a(callback),
+      {
+        race(win) {
+          won = win;
+          this.observe(document$1, {childList: true,
+                                  characterData: true,
+                                  subtree: true});
+          callback();
+        }
+      }
+    );
+  }
+
+  function isVisible(element, style, closest, shadowRootParents) {
+    let $style = $(style, "CSSStyleDeclaration");
+    if ($style.getPropertyValue("display") == "none")
+      return false;
+
+    let visibility = $style.getPropertyValue("visibility");
+    if (visibility == "hidden" || visibility == "collapse")
+      return false;
+
+    if (!closest || element == closest)
+      return true;
+
+    let parent = $(element).parentElement;
+    if (!parent) {
+
+      if (shadowRootParents && shadowRootParents.length) {
+        parent = shadowRootParents[shadowRootParents.length - 1];
+        shadowRootParents = shadowRootParents.slice(0, -1);
+      }
+      else {
+        return true;
+      }
+    }
+
+    return isVisible(
+      parent, getComputedStyle$5(parent), closest, shadowRootParents
+    );
+  }
+
+  function getComputedCSSText(element) {
+    let style = getComputedStyle$5(element);
+    let {cssText} = style;
+
+    if (cssText)
+      return cssText;
+
+    for (let property of style)
+      cssText += `${property}: ${style[property]}; `;
+
+    return $(cssText).trim();
+  }
+
+  let {Array: Array$1, Math: Math$4, RegExp} = $(window);
+
+  function regexEscape(string) {
+    return $(string).replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
+  }
+
+  function toRegExp(pattern) {
+    let {length} = pattern;
+
+    if (length > 1 && pattern[0] === "/") {
+      let isCaseSensitive = pattern[length - 1] === "/";
+
+      if (isCaseSensitive || (length > 2 && $(pattern).endsWith("/i"))) {
+        let args = [$(pattern).slice(1, isCaseSensitive ? -1 : -2)];
+        if (!isCaseSensitive)
+          args.push("i");
+
+        return new RegExp(...args);
+      }
+    }
+
+    return new RegExp(regexEscape(pattern));
+  }
+
+  function formatArguments(args) {
+    return $(Array$1.from(args)).map(arg => `'${arg}'`).join(" ");
+  }
+
+  let {Math: Math$3, setInterval: setInterval$1, performance} = $(window);
+
+  const noopProfile = {
+    mark() {},
+    end() {},
+    toString() {
+      return "{mark(){},end(){}}";
+    }
+  };
+
+  let inactive = true;
+
+  function setProfile() {
+    inactive = false;
+  }
+
+  function profile(id, rate = 10) {
+    if (inactive)
+      return noopProfile;
+    function processSamples() {
+      let samples = $([]);
+
+      for (let {name, duration} of performance.getEntriesByType("measure"))
+        samples.push({name, duration});
+
+      if (samples.length)
+        performance.clearMeasures();
+    }
+
+    if (!profile[id]) {
+      profile[id] = setInterval$1(processSamples,
+                                Math$3.round(60000 / Math$3.min(60, rate)));
+    }
+
+    return {
+      mark() {
+        performance.mark(id);
+      },
+      end(clear = false) {
+        const measureObj = performance.measure(id, id);
+        console.log("PROFILER:", measureObj);
+        performance.clearMarks(id);
+        if (clear) {
+          clearInterval(profile[id]);
+          delete profile[id];
+          processSamples();
+        }
+      }
+    };
+  }
+
+  const {console: console$1} = $(window);
+
+  const noop = () => {};
+
+  function log(...args) {
+    let {mark, end} = profile("log");
+    if (debug()) {
+      const logArgs = ["%c DEBUG", "font-weight: bold;"];
+
+      const isErrorIndex = args.indexOf("error");
+      const isWarnIndex = args.indexOf("warn");
+      const isSuccessIndex = args.indexOf("success");
+      const isInfoIndex = args.indexOf("info");
+
+      if (isErrorIndex !== -1) {
+        logArgs[0] += " - ERROR";
+        logArgs[1] += "color: red; border:2px solid red";
+        $(args).splice(isErrorIndex, 1);
+      }
+      else if (isWarnIndex !== -1) {
+        logArgs[0] += " - WARNING";
+        logArgs[1] += "color: orange; border:2px solid orange ";
+        $(args).splice(isWarnIndex, 1);
+      }
+      else if (isSuccessIndex !== -1) {
+        logArgs[0] += " - SUCCESS";
+        logArgs[1] += "color: green; border:2px solid green";
+        $(args).splice(isSuccessIndex, 1);
+      }
+      else if (isInfoIndex !== -1) {
+        logArgs[1] += "color: black;";
+        $(args).splice(isInfoIndex, 1);
+      }
+
+      $(args).unshift(...logArgs);
+    }
+    mark();
+    console$1.log(...args);
+    end();
+  }
+
+  function getDebugger(name) {
+    return bind(debug() ? log : noop, null, name);
+  }
+
+  let {Array, Error: Error$2, Map: Map$3, parseInt: parseInt$2} = $(window);
+
+  let stack = null;
+  let won = null;
+
+  function race(action, winners = "1") {
+    switch (action) {
+      case "start":
+        stack = {
+          winners: parseInt$2(winners, 10) || 1,
+          participants: new Map$3()
+        };
+        won = new Array();
+        break;
+      case "end":
+      case "finish":
+      case "stop":
+        stack = null;
+        for (let win of won)
+          win();
+        won = null;
+        break;
+      default:
+        throw new Error$2(`Invalid action: ${action}`);
+    }
+  }
+
+  function raceWinner(name, lose) {
+
+    if (stack === null)
+      return noop;
+
+    let current = stack;
+    let {participants} = current;
+    participants.set(win, lose);
+
+    return win;
+
+    function win() {
+
+      if (current.winners < 1)
+        return;
+
+      let debugLog = getDebugger("race");
+      debugLog("success", `${name} won the race`);
+
+      if (current === stack) {
+        won.push(win);
+      }
+      else {
+        participants.delete(win);
+        if (--current.winners < 1) {
+          for (let looser of participants.values())
+            looser();
+
+          participants.clear();
+        }
+      }
+    }
+  }
+
+  function hideIfContains(search, selector = "*", searchSelector = null) {
+    const formattedArguments = formatArguments(arguments);
+    const debugLog = getDebugger("hide-if-contains");
+    const {mark, end} = profile("hide-if-contains");
+    const onHideCallback = node => {
+      mark();
+      debugLog("success",
+               "Matched: ",
+               node,
+               "\nFILTER: hide-if-contains",
+               formattedArguments);
+      end();
+    };
+    let re = toRegExp(search);
+
+    const mo = hideIfMatches(element => re.test($(element).textContent),
+                             selector,
+                             searchSelector,
+                             onHideCallback);
+    mo.race(raceWinner(
+      "hide-if-contains",
+      () => {
+        mo.disconnect();
+      }
+    ));
+  }
+
+  const handler = {
+    get(target, name) {
+      const context = target;
+      while (!hasOwnProperty(target, name))
+        target = getPrototypeOf(target);
+      const {get, set} = getOwnPropertyDescriptor$2(target, name);
+      return function () {
+        return arguments.length ?
+                apply$2(set, context, arguments) :
+                call(get, context);
+      };
+    }
+  };
+
+  const accessor = target => new $$1(target, handler);
+
+  $(window);
+
+  accessor(window);
+
+  $(/^\d+$/);
+
+  function getPromiseFromEvent(item, event) {
+    return new Promise(
+      resolve => {
+        const listener = () => {
+          item.removeEventListener(event, listener);
+          resolve();
+        };
+        item.addEventListener(event, listener);
+      }
+    );
+  }
+
+  function waitUntilEvent(
+    debugLog,
+    mainLogic,
+    waitUntil) {
+    if (waitUntil) {
+
+      if (waitUntil === "load") {
+        debugLog("info", "Waiting until window.load");
+
+        window.addEventListener("load", () => {
+          debugLog("info", "Window.load fired.");
+          mainLogic();
+        });
+      }
+
+      else if (waitUntil === "loading" ||
+              waitUntil === "interactive" ||
+              waitUntil === "complete") {
+        debugLog("info", "Waiting document state until :", waitUntil);
+
+        document.addEventListener("readystatechange", () => {
+          debugLog("info", "Document state changed:", document.readyState);
+          if (document.readyState === waitUntil)
+            mainLogic();
+        });
+      }
+
+      else {
+        debugLog("info",
+                 "Waiting until ",
+                 waitUntil,
+                 " event is triggered on document");
+        getPromiseFromEvent(document, waitUntil).then(() => {
+          debugLog("info",
+                   waitUntil,
+                   " is triggered on document, starting the snippet");
+          mainLogic();
+        }).catch(err => {
+          debugLog("error",
+                   "There was an error while waiting for the event.",
+                   err);
+        });
+      }
+    }
+    else {
+
+      mainLogic();
+    }
+  }
+
+  let {MutationObserver: MutationObserver$9, WeakSet: WeakSet$8, getComputedStyle: getComputedStyle$4} = $(window);
+
+  function hideIfContainsAndMatchesStyle(search,
+                                                selector = "*",
+                                                searchSelector = null,
+                                                style = null,
+                                                searchStyle = null,
+                                                waitUntil,
+                                                windowWidthMin = null,
+                                                windowWidthMax = null
+  ) {
+    const formattedArguments = formatArguments(arguments);
+    const debugLog = getDebugger("hide-if-contains-and-matches-style");
+    const {mark, end} = profile("hide-if-contains-and-matches-style");
+    const hiddenMap = new WeakSet$8();
+    const logMap = debug() && new WeakSet$8();
+    if (searchSelector == null)
+      searchSelector = selector;
+
+    const searchRegExp = toRegExp(search);
+
+    const styleRegExp = style ? toRegExp(style) : null;
+    const searchStyleRegExp = searchStyle ? toRegExp(searchStyle) : null;
+    const mainLogic = () => {
+      const callback = () => {
+        mark();
+        if ((windowWidthMin && window.innerWidth < windowWidthMin) ||
+           (windowWidthMax && window.innerWidth > windowWidthMax)
+        )
+          return;
+        for (const {element, rootParents} of $$(searchSelector, true)) {
+          if (hiddenMap.has(element))
+            continue;
+          if (searchRegExp.test($(element).textContent)) {
+            if (!searchStyleRegExp ||
+              searchStyleRegExp.test(getComputedCSSText(element))) {
+              const closest = $closest($(element), selector, rootParents);
+              if (!closest)
+                continue;
+              if (!styleRegExp || styleRegExp.test(getComputedCSSText(closest))) {
+                win();
+                hideElement(closest);
+                hiddenMap.add(element);
+                debugLog("success",
+                         "Matched: ",
+                         closest,
+                         "which contains: ",
+                         element,
+                         "\nFILTER: hide-if-contains-and-matches-style",
+                         formattedArguments);
+              }
+              else {
+                if (!logMap || logMap.has(closest))
+                  continue;
+                debugLog("info",
+                         "In this element the searchStyle matched " +
+                         "but style didn't:\n",
+                         closest,
+                         getComputedStyle$4(closest),
+                         formattedArguments);
+                logMap.add(closest);
+              }
+            }
+            else {
+              if (!logMap || logMap.has(element))
+                continue;
+              debugLog("info",
+                       "In this element the searchStyle didn't match:\n",
+                       element,
+                       getComputedStyle$4(element),
+                       formattedArguments);
+              logMap.add(element);
+            }
+          }
+        }
+        end();
+      };
+
+      const mo = new MutationObserver$9(callback);
+      const win = raceWinner(
+        "hide-if-contains-and-matches-style",
+        () => mo.disconnect()
+      );
+      mo.observe(document, {childList: true, characterData: true, subtree: true});
+      callback();
+    };
+    waitUntilEvent(debugLog, mainLogic, waitUntil);
+  }
+
+  let {
+    clearTimeout,
+    fetch,
+    getComputedStyle: getComputedStyle$3,
+    setTimeout: setTimeout$2,
+    Map: Map$2,
+    MutationObserver: MutationObserver$8,
+    Uint8Array
+  } = $(window);
+
+  function hideIfContainsImage(search, selector, searchSelector) {
+    if (searchSelector == null)
+      searchSelector = selector;
+
+    let searchRegExp = toRegExp(search);
+
+    const formattedArguments = formatArguments(arguments);
+    const debugLog = getDebugger("hide-if-contains-image");
+    const {mark, end} = profile("hide-if-contains-image");
+
+    let callback = () => {
+      mark();
+      for (const {element, rootParents} of $$(searchSelector, true)) {
+        let style = getComputedStyle$3(element);
+        let match = $(style["background-image"]).match(/^url\("(.*)"\)$/);
+        if (match) {
+          fetchContent(match[1]).then(content => {
+            if (searchRegExp.test(uint8ArrayToHex(new Uint8Array(content)))) {
+              let closest = $closest($(element), selector, rootParents);
+              if (closest) {
+                win();
+                hideElement(closest);
+                debugLog("success",
+                         "Matched: ",
+                         closest,
+                         "\nFILTER: hide-if-contains-image",
+                         formattedArguments);
+              }
+            }
+          });
+        }
+      }
+      end();
+    };
+
+    let mo = new MutationObserver$8(callback);
+    let win = raceWinner(
+      "hide-if-contains-image",
+      () => mo.disconnect()
+    );
+    mo.observe(document, {childList: true, subtree: true});
+    callback();
+  }
+
+  let fetchContentMap = new Map$2();
+
+  function fetchContent(url, {as = "arrayBuffer", cleanup = 60000} = {}) {
+
+    let uid = as + ":" + url;
+    let details = fetchContentMap.get(uid) || {
+      remove: () => fetchContentMap.delete(uid),
+      result: null,
+      timer: 0
+    };
+    clearTimeout(details.timer);
+    details.timer = setTimeout$2(details.remove, cleanup);
+    if (!details.result) {
+      details.result = fetch(url).then(res => res[as]()).catch(details.remove);
+      fetchContentMap.set(uid, details);
+    }
+    return details.result;
+  }
+
+  function toHex(number, length = 2) {
+    let hex = $(number).toString(16);
+
+    if (hex.length < length)
+      hex = $("0").repeat(length - hex.length) + hex;
+
+    return hex;
+  }
+
+  function uint8ArrayToHex(uint8Array) {
+    return uint8Array.reduce((hex, byte) => hex + toHex(byte), "");
+  }
+
+  const {parseFloat: parseFloat$2, Math: Math$2, MutationObserver: MutationObserver$7, WeakSet: WeakSet$7} = $(window);
+  const {min} = Math$2;
+
+  const ld = (a, b) => {
+    const len1 = a.length + 1;
+    const len2 = b.length + 1;
+    const d = [[0]];
+    let i = 0;
+    let I = 0;
+
+    while (++i < len2)
+      d[0][i] = i;
+
+    i = 0;
+    while (++i < len1) {
+      const c = a[I];
+      let j = 0;
+      let J = 0;
+      d[i] = [i];
+      while (++j < len2) {
+        d[i][j] = min(d[I][j] + 1, d[i][J] + 1, d[I][J] + (c != b[J]));
+        ++J;
+      }
+      ++I;
+    }
+    return d[len1 - 1][len2 - 1];
+  };
+
+  function hideIfContainsSimilarText(
+    search, selector,
+    searchSelector = null,
+    ignoreChars = 0,
+    maxSearches = 0
+  ) {
+    const visitedNodes = new WeakSet$7();
+    const formattedArguments = formatArguments(arguments);
+    const debugLog = getDebugger("hide-if-contains-similar-text");
+    const {mark, end} = profile("hide-if-contains-similar-text");
+    const $search = $(search);
+    const {length} = $search;
+    const chars = length + parseFloat$2(ignoreChars) || 0;
+    const find = $([...$search]).sort();
+    const guard = parseFloat$2(maxSearches) || Infinity;
+
+    if (searchSelector == null)
+      searchSelector = selector;
+
+    debugLog("info", "Looking for similar text: " + $search);
+
+    const callback = () => {
+      mark();
+      for (const {element, rootParents} of $$(searchSelector, true)) {
+        if (visitedNodes.has(element))
+          continue;
+
+        visitedNodes.add(element);
+        const {innerText} = $(element);
+        const loop = min(guard, innerText.length - chars + 1);
+        for (let i = 0; i < loop; i++) {
+          const str = $(innerText).substr(i, chars);
+          const distance = ld(find, $([...str]).sort()) - ignoreChars;
+          if (distance <= 0) {
+            const closest = $closest($(element), selector, rootParents);
+            debugLog("success",
+                     "Found similar text: " + $search,
+                     closest,
+                     "\nFILTER: hide-if-contains-similar-text",
+                     formattedArguments);
+            if (closest) {
+              win();
+              hideElement(closest);
+              break;
+            }
+          }
+        }
+      }
+      end();
+    };
+
+    let mo = new MutationObserver$7(callback);
+    let win = raceWinner(
+      "hide-if-contains-similar-text",
+      () => mo.disconnect()
+    );
+    mo.observe(document, {childList: true, characterData: true, subtree: true});
+    callback();
+  }
+
+  let {getComputedStyle: getComputedStyle$2, Map: Map$1, WeakSet: WeakSet$6, parseFloat: parseFloat$1, DOMMatrix, Math: Math$1} = $(window);
+
+  const {ELEMENT_NODE: ELEMENT_NODE$3, TEXT_NODE} = Node;
+
+  function hideIfContainsVisibleText(search, selector,
+                                            searchSelector = null,
+                                            ...attributes) {
+    const {mark, end} = profile("hide-if-contains-visible-text");
+    const formattedArguments = formatArguments(arguments);
+    let entries = $([]);
+    const optionalParameters = new Map$1([
+      ["-snippet-box-margin", "2"],
+      ["-disable-bg-color-check", "false"],
+      ["-check-is-contained", "false"],
+      ["-pseudo-box-margin", "2"]
+    ]);
+
+    for (let attr of attributes) {
+      attr = $(attr);
+      let markerIndex = attr.indexOf(":");
+      if (markerIndex < 0)
+        continue;
+
+      let key = attr.slice(0, markerIndex).trim().toString();
+      let value = attr.slice(markerIndex + 1).trim().toString();
+
+      if (key && value) {
+        if (optionalParameters.has(key))
+          optionalParameters.set(key, value);
+        else
+          entries.push([key, value]);
+      }
+    }
+
+    let defaultEntries = $([
+      ["opacity", "0"],
+      ["font-size", "0px"],
+
+      ["color", "rgba(0, 0, 0, 0)"]
+    ]);
+
+    let attributesMap = new Map$1(defaultEntries.concat(entries));
+
+    function isTextVisible(element, style, {bgColorCheck = true} = {}) {
+      if (!style)
+        style = getComputedStyle$2(element);
+
+      style = $(style);
+
+      for (const [key, value] of attributesMap) {
+        let valueAsRegex = toRegExp(value);
+        if (valueAsRegex.test(style.getPropertyValue(key)))
+          return false;
+      }
+
+      let color = style.getPropertyValue("color");
+      if (bgColorCheck && style.getPropertyValue("background-color") == color)
+        return false;
+
+      return true;
+    }
+
+    function getTransformMatrix(element, pseudo = null) {
+      const style = getComputedStyle$2(element, pseudo);
+      let transform = style.transform;
+
+      if (transform === "none")
+        transform = "matrix(1, 0, 0, 1, 0, 0)";
+      return new DOMMatrix(transform);
+    }
+
+    function getPseudoContent(element, pseudo, parentMatrix,
+                              {bgColorCheck = true, translateThresh = 2} = {}) {
+      let style = getComputedStyle$2(element, pseudo);
+
+      if (!isVisible(element, style) ||
+       !isTextVisible(element, style, {bgColorCheck}))
+        return "";
+
+      let {content} = $(style);
+      if (content && content !== "none") {
+        let strings = $([]);
+
+        const domMatrix = getTransformMatrix(element, pseudo);
+        const resultMatrix = parentMatrix.multiply(domMatrix);
+
+        const angle = Math$1.atan2(resultMatrix.b, resultMatrix.a);
+        const angleDegrees = angle * (180 / Math$1.PI);
+        const rotated = Math$1.abs(angleDegrees) > 5;
+
+        if (rotated)
+          return "";
+
+        const translated = Math$1.abs(resultMatrix.e) > translateThresh ||
+                           Math$1.abs(resultMatrix.f) > translateThresh;
+        if (translated)
+          return "";
+
+        content = $(content).trim().replace(
+          /(["'])(?:(?=(\\?))\2.)*?\1/g,
+          value => `\x01${strings.push($(value).slice(1, -1)) - 1}`
+        );
+
+        content = content.replace(
+          /\s*attr\(\s*([^\s,)]+)[^)]*?\)\s*/g,
+          (_, name) => $(element).getAttribute(name) || ""
+        );
+
+        return content.replace(
+          /\x01(\d+)/g,
+          (_, index) => strings[index]);
+      }
+      return "";
+    }
+
+    function isContained(childNode, parentNode, {boxMargin = 2} = {}) {
+      const child = $(childNode).getBoundingClientRect();
+      const parent = $(parentNode).getBoundingClientRect();
+      const stretchedParent = {
+        left: parent.left - boxMargin,
+        right: parent.right + boxMargin,
+        top: parent.top - boxMargin,
+        bottom: parent.bottom + boxMargin
+      };
+      return (
+        (stretchedParent.left <= child.left &&
+           child.left <= stretchedParent.right &&
+          stretchedParent.top <= child.top &&
+           child.top <= stretchedParent.bottom) &&
+        (stretchedParent.top <= child.bottom &&
+           child.bottom <= stretchedParent.bottom &&
+          stretchedParent.left <= child.right &&
+           child.right <= stretchedParent.right)
+      );
+    }
+
+    function getVisibleContent(element,
+                               closest,
+                               style,
+                               parentOverflowNode,
+                               originalElement,
+                               shadowRootParents,
+                               domMatrix,
+                               {
+                                 boxMargin = 2,
+                                 bgColorCheck,
+                                 checkIsContained,
+                                 translateThresh
+                               } = {}) {
+      let checkClosest = !style;
+      if (checkClosest)
+        style = getComputedStyle$2(element);
+
+      if (!isVisible(element, style, checkClosest && closest, shadowRootParents))
+        return "";
+
+      if (!parentOverflowNode &&
+        (
+          $(style).getPropertyValue("overflow-x") === "hidden" ||
+          $(style).getPropertyValue("overflow-y") === "hidden"
+        )
+      )
+        parentOverflowNode = element;
+
+      if (!domMatrix)
+        domMatrix = getTransformMatrix(element);
+
+      else
+        domMatrix = domMatrix.multiply(getTransformMatrix(element));
+
+      let text = getPseudoContent(element,
+                                  ":before",
+                                  domMatrix,
+                                  {bgColorCheck, translateThresh});
+      for (let node of $childNodes($(element))) {
+        switch ($(node).nodeType) {
+          case ELEMENT_NODE$3:
+            text += getVisibleContent(node,
+                                      element,
+                                      getComputedStyle$2(node),
+                                      parentOverflowNode,
+                                      originalElement,
+                                      shadowRootParents,
+                                      domMatrix,
+                                      {
+                                        boxMargin,
+                                        bgColorCheck,
+                                        checkIsContained,
+                                        translateThresh
+                                      }
+            );
+            break;
+          case TEXT_NODE:
+
+            if (parentOverflowNode) {
+              if (isContained(element, parentOverflowNode, {boxMargin}) &&
+                isTextVisible(element, style, {bgColorCheck}))
+                text += $(node).nodeValue;
+            }
+            else if (isTextVisible(element, style, {bgColorCheck})) {
+              if (checkIsContained &&
+                 !isContained(element, originalElement, {boxMargin}))
+                continue;
+              text += $(node).nodeValue;
+            }
+            break;
+        }
+      }
+      text += getPseudoContent(element,
+                               ":after",
+                               domMatrix,
+                               {bgColorCheck, translateThresh});
+      return text;
+    }
+
+    const boxMarginStr = optionalParameters.get("-snippet-box-margin");
+    const boxMargin = parseFloat$1(boxMarginStr) || 0;
+
+    const bgColorCheckStr = optionalParameters.get("-disable-bg-color-check");
+    const bgColorCheck = !(bgColorCheckStr === "true");
+
+    const checkIsContainedStr = optionalParameters.get("-check-is-contained");
+    const checkIsContained = (checkIsContainedStr === "true");
+
+    const translateThreshStr = optionalParameters.get("-pseudo-box-margin");
+    const translateThresh = parseFloat$1(translateThreshStr) || 0;
+
+    let re = toRegExp(search);
+    let seen = new WeakSet$6();
+
+    const mo = hideIfMatches(
+      (element, closest, rootParents) => {
+        mark();
+        if (seen.has(element))
+          return false;
+
+        seen.add(element);
+        let text = getVisibleContent(
+          element, closest, null, null, element, rootParents, null, {
+            boxMargin,
+            bgColorCheck,
+            checkIsContained,
+            translateThresh
+          }
+        );
+        let result = re.test(text);
+        if (debug() && text.length) {
+          result ?
+
+          log("success", result, re, text, "\nFILTER: hide-if-contains-visible-text", formattedArguments) :
+          log("info", result, re, text);
+        }
+        end();
+        return result;
+      },
+      selector,
+      searchSelector
+    );
+    mo.race(raceWinner(
+      "hide-if-contains-visible-text",
+      () => {
+        mo.disconnect();
+      }
+    ));
+  }
+
+  let {MutationObserver: MutationObserver$6, WeakSet: WeakSet$5, getComputedStyle: getComputedStyle$1} = $(window);
+
+  function hideIfHasAndMatchesStyle(search,
+                                           selector = "*",
+                                           searchSelector = null,
+                                           style = null,
+                                           searchStyle = null,
+                                           waitUntil = null,
+                                           windowWidthMin = null,
+                                           windowWidthMax = null
+  ) {
+    const formattedArguments = formatArguments(arguments);
+    const debugLog = getDebugger("hide-if-has-and-matches-style");
+    const {mark, end} = profile("hide-if-has-and-matches-style");
+    const hiddenMap = new WeakSet$5();
+    const logMap = debug() && new WeakSet$5();
+    if (searchSelector == null)
+      searchSelector = selector;
+
+    const styleRegExp = style ? toRegExp(style) : null;
+    const searchStyleRegExp = searchStyle ? toRegExp(searchStyle) : null;
+    const mainLogic = () => {
+      const callback = () => {
+        mark();
+        if ((windowWidthMin && window.innerWidth < windowWidthMin) ||
+           (windowWidthMax && window.innerWidth > windowWidthMax)
+        )
+          return;
+        for (const {element, rootParents} of $$(searchSelector, true)) {
+          if (hiddenMap.has(element))
+            continue;
+          if ($(element).querySelector(search) &&
+              (!searchStyleRegExp ||
+              searchStyleRegExp.test(getComputedCSSText(element)))) {
+            const closest = $closest($(element), selector, rootParents);
+            if (closest && (!styleRegExp ||
+                            styleRegExp.test(getComputedCSSText(closest)))) {
+              win();
+              hideElement(closest);
+              hiddenMap.add(element);
+              debugLog("success",
+                       "Matched: ",
+                       closest,
+                       "which contains: ",
+                       element,
+                       "\nFILTER: hide-if-has-and-matches-style",
+                       formattedArguments);
+            }
+            else {
+              if (!logMap || logMap.has(closest))
+                continue;
+              debugLog("info",
+                       "In this element the searchStyle matched" +
+                       "but style didn't:\n",
+                       closest,
+                       getComputedStyle$1(closest),
+                       ...arguments);
+              logMap.add(closest);
+            }
+          }
+          else {
+            if (!logMap || logMap.has(element))
+              continue;
+            debugLog("info",
+                     "In this element the searchStyle didn't match:\n",
+                     element,
+                     getComputedStyle$1(element),
+                     ...arguments);
+            logMap.add(element);
+          }
+        }
+        end();
+      };
+
+      const mo = new MutationObserver$6(callback);
+      const win = raceWinner(
+        "hide-if-has-and-matches-style",
+        () => mo.disconnect()
+      );
+      mo.observe(document, {childList: true, subtree: true});
+      callback();
+    };
+    waitUntilEvent(debugLog, mainLogic, waitUntil);
+  }
+
+  let {getComputedStyle, MutationObserver: MutationObserver$5, WeakSet: WeakSet$4} = $(window);
+
+  function hideIfLabelledBy(search, selector, searchSelector = null) {
+    const {mark, end} = profile("hide-if-labelled-by");
+    let sameSelector = searchSelector == null;
+
+    let searchRegExp = toRegExp(search);
+
+    let matched = new WeakSet$4();
+
+    let callback = () => {
+      mark();
+      for (const {element, rootParents} of $$(selector, true)) {
+        let closest = sameSelector ?
+                      element :
+                      $closest($(element), searchSelector, rootParents);
+        if (!closest ||
+            !isVisible(element, getComputedStyle(element), closest))
+          continue;
+
+        let attr = $(element).getAttribute("aria-labelledby");
+        let fallback = () => {
+          if (matched.has(closest))
+            return;
+
+          if (searchRegExp.test(
+            $(element).getAttribute("aria-label") || ""
+          )) {
+            win();
+            matched.add(closest);
+            hideElement(closest);
+          }
+        };
+
+        if (attr) {
+          for (let label of $(attr).split(/\s+/)) {
+            let target = $(document).getElementById(label);
+            if (target) {
+              if (!matched.has(target) && searchRegExp.test(target.innerText)) {
+                win();
+                matched.add(target);
+                hideElement(closest);
+              }
+            }
+            else {
+              fallback();
+            }
+          }
+        }
+        else {
+          fallback();
+        }
+      }
+      end();
+    };
+
+    let mo = new MutationObserver$5(callback);
+    let win = raceWinner(
+      "hide-if-labelled-by",
+      () => mo.disconnect()
+    );
+    mo.observe(document, {characterData: true, childList: true, subtree: true});
+    callback();
+  }
+
+  let {MutationObserver: MutationObserver$4, WeakSet: WeakSet$3} = $(window);
+
+  const {ELEMENT_NODE: ELEMENT_NODE$2} = Node;
+
+  function hideIfMatchesXPath(query, scopeQuery, waitUntil) {
+    const {mark, end} = profile("hide-if-matches-xpath");
+    const formattedArguments = formatArguments(arguments);
+    const debugLog = getDebugger("hide-if-matches-xpath");
+
+    const mainLogic = () => {
+      const startHidingMutationObserver = scopeNode => {
+        const queryAndApply = initQueryAndApply(`xpath(${query})`);
+        const seenMap = new WeakSet$3();
+        const hideNode = node => {
+          seenMap.add(node);
+          win();
+
+          if ($(node).nodeType === ELEMENT_NODE$2)
+            hideElement(node);
+          else
+            $(node).textContent = "";
+          debugLog("success",
+                   "Matched: ",
+                   node,
+                   "\nFILTER: hide-if-matches-xpath",
+                   formattedArguments);
+        };
+
+        const callback = () => {
+          mark();
+          queryAndApply(node => {
+            if (seenMap.has(node))
+              return false;
+
+            if (scopeQuery) {
+              const scopeQueryAndApply = initQueryAndApply(`xpath(${scopeQuery})`);
+              scopeQueryAndApply(matchingScopeNode => {
+                if (matchingScopeNode.contains(node)) {
+
+                  hideNode(node);
+                }
+                else {
+
+                  return false;
+                }
+              });
+            }
+            else {
+              hideNode(node);
+            }
+          });
+          end();
+        };
+        const mo = new MutationObserver$4(callback);
+        const win = raceWinner(
+          "hide-if-matches-xpath",
+          () => mo.disconnect()
+        );
+        mo.observe(
+          scopeNode, {characterData: true, childList: true, subtree: true});
+        callback();
+      };
+
+      if (scopeQuery) {
+
+        let count = 0;
+        let scopeMutationObserver;
+        const scopeQueryAndApply = initQueryAndApply(`xpath(${scopeQuery})`);
+        const findMutationScopeNodes = () => {
+          scopeQueryAndApply(scopeNode => {
+
+            startHidingMutationObserver(scopeNode);
+            count++;
+          });
+          if (count > 0)
+            scopeMutationObserver.disconnect();
+        };
+        scopeMutationObserver = new MutationObserver$4(findMutationScopeNodes);
+        scopeMutationObserver.observe(
+          document, {characterData: true, childList: true, subtree: true}
+        );
+        findMutationScopeNodes();
+      }
+      else {
+
+        startHidingMutationObserver(document);
+      }
+    };
+
+    waitUntilEvent(debugLog, mainLogic, waitUntil);
+  }
+
+  let {MutationObserver: MutationObserver$3, WeakSet: WeakSet$2} = $(window);
+
+  const {ELEMENT_NODE: ELEMENT_NODE$1} = Node;
+
+  function hideIfMatchesComputedXPath(query, searchQuery, searchRegex,
+                                             waitUntil) {
+    const {mark, end} = profile("hide-if-matches-computed-xpath");
+    const formattedArguments = formatArguments(arguments);
+    const debugLog = getDebugger("hide-if-matches-computed-xpath");
+
+    if (!searchQuery || !query) {
+      debugLog("error", "No query or searchQuery provided.");
+      return;
+    }
+
+    const computeQuery = foundText => query.replace("{{}}", foundText);
+
+    const startHidingMutationObserver = foundText => {
+      const computedQuery = computeQuery(foundText);
+      debugLog("info",
+               "Starting hiding elements that match query: ",
+               computedQuery);
+      const queryAndApply = initQueryAndApply(`xpath(${computedQuery})`);
+      const seenMap = new WeakSet$2();
+      const callback = () => {
+        mark();
+        queryAndApply(node => {
+          if (seenMap.has(node))
+            return false;
+          seenMap.add(node);
+          win();
+          if ($(node).nodeType === ELEMENT_NODE$1)
+            hideElement(node);
+          else
+            $(node).textContent = "";
+          debugLog("success",
+                   "Matched: ",
+                   node,
+                   "\nFILTER: hide-if-matches-computed-xpath",
+                   formattedArguments);
+        });
+        end();
+      };
+      const mo = new MutationObserver$3(callback);
+      const win = raceWinner(
+        "hide-if-matches-computed-xpath",
+        () => mo.disconnect()
+      );
+      mo.observe(
+        document, {characterData: true, childList: true, subtree: true});
+      callback();
+    };
+
+    const re = toRegExp(searchRegex);
+
+    const mainLogic = () => {
+      if (searchQuery) {
+        debugLog("info", "Started searching for: ", searchQuery);
+        const seenMap = new WeakSet$2();
+        let searchMO;
+        const searchQueryAndApply = initQueryAndApply(`xpath(${searchQuery})`);
+        const findMutationSearchNodes = () => {
+          searchQueryAndApply(searchNode => {
+            if (seenMap.has(searchNode))
+              return false;
+            seenMap.add(searchNode);
+            debugLog("info", "Found node: ", searchNode);
+            if (searchNode.innerHTML) {
+              debugLog("info", "Searching in: ", searchNode.innerHTML);
+              const foundTextArr = searchNode.innerHTML.match(re);
+              if (foundTextArr && foundTextArr.length) {
+                let foundText = "";
+
+                foundTextArr[1] ? foundText = foundTextArr[1] :
+                  foundText = foundTextArr[0];
+                debugLog("info", "Matched search query: ", foundText);
+                startHidingMutationObserver(foundText);
+              }
+            }
+          });
+        };
+
+        searchMO = new MutationObserver$3(findMutationSearchNodes);
+        searchMO.observe(
+          document, {characterData: true, childList: true, subtree: true}
+        );
+        findMutationSearchNodes();
+      }
+    };
+
+    waitUntilEvent(debugLog, mainLogic, waitUntil);
+  }
+
+  let {
+    parseInt: parseInt$1,
+    setTimeout: setTimeout$1,
+    Error: Error$1,
+    MouseEvent: MouseEvent$1,
+    MutationObserver: MutationObserver$2,
+    WeakSet: WeakSet$1
+  } = $(window);
+
+  const VALID_TYPES = ["auxclick", "click", "dblclick",	"gotpointercapture",
+                       "lostpointercapture", "mouseenter", "mousedown",
+                       "mouseleave", "mousemove", "mouseout", "mouseover",
+                       "mouseup",	"pointerdown", "pointerenter",
+                       "pointermove", "pointerover", "pointerout",
+                       "pointerup", "pointercancel", "pointerleave"];
+
+  function simulateMouseEvent(...selectors) {
+    const formattedArguments = formatArguments(arguments);
+    const debugLog = getDebugger("simulate-mouse-event");
+    const {mark, end} = profile("simulate-mouse-event");
+    const MAX_ARGS = 7;
+    if (selectors.length < 1)
+      throw new Error$1("[simulate-mouse-event snippet]: No selector provided.");
+
+    if (selectors.length > MAX_ARGS) {
+
+      selectors = selectors.slice(0, MAX_ARGS);
+    }
+    function parseArg(theRule) {
+      if (!theRule)
+        return null;
+
+      const result = {
+        selector: "",
+        continue: false,
+        trigger: false,
+        event: "click",
+        delay: "500",
+        clicked: false,
+        found: false
+      };
+      const textArr = theRule.split("$");
+      let options = [];
+      if (textArr.length >= 2)
+        options = textArr[1].toLowerCase().split(",");
+
+      [result.selector] = textArr;
+
+      for (const option of options) {
+        if (option === "trigger") {
+          result.trigger = true;
+        }
+        else if (option === "continue") {
+          result.continue = true;
+        }
+        else if (option.startsWith("event")) {
+          const event = option.toLowerCase().split("=");
+          event[1] ? result.event = event[1] : result.event = "click";
+        }
+        else if (option.startsWith("delay")) {
+          const delay = option.toLowerCase().split("=");
+          delay[1] ? result.delay = delay[1] : result.delay = "500";
+        }
+      }
+      if (!VALID_TYPES.includes(result.event)) {
+        debugLog("warn",
+                 result.event,
+                 " might be misspelled, check for typos.\n",
+                 "These are the supported events:",
+                 VALID_TYPES);
+      }
+      return result;
+    }
+
+    const parsedArgs = $([]);
+
+    $(selectors).forEach(rule => {
+      const parsedRule = parseArg(rule);
+      parsedArgs.push(parsedRule);
+    });
+
+    function checkIfAllSelectorsFound() {
+      parsedArgs.forEach(arg => {
+        if (!arg.found) {
+          const queryAll = initQueryAll(arg.selector);
+          const elems = queryAll();
+          if (elems.length > 0)
+            arg.found = true;
+        }
+      });
+      return parsedArgs.every(arg => arg.found);
+    }
+
+    function triggerEvent(node, event, delay) {
+
+      if (!node || !event)
+        return;
+
+      if (event === "click" && node.click) {
+        node.click();
+        debugLog("success",
+                 "Clicked on this node:\n",
+                 node,
+                 "\nwith a delay of",
+                 delay,
+                 "ms",
+                 `n\nFILTER: simulate-mouse-event ${formattedArguments}`
+        );
+      }
+      else {
+        node.dispatchEvent(
+          new MouseEvent$1(event, {bubbles: true, cancelable: true})
+        );
+        debugLog("success",
+                 "A",
+                 event,
+                 "event was dispatched with a delay of",
+                 delay,
+                 "ms on this node:\n",
+                 node,
+                 `n\nFILTER: simulate-mouse-event ${formattedArguments}`
+        );
+      }
+    }
+    let allFound = false;
+
+    const [last] = parsedArgs.slice(-1);
+    last.trigger = true;
+
+    let dispatchedNodes = new WeakSet$1();
+
+    let observer = new MutationObserver$2(findNodesAndDispatchEvents);
+    observer.observe(document, {childList: true, subtree: true});
+    findNodesAndDispatchEvents();
+
+    function findNodesAndDispatchEvents() {
+      mark();
+
+      if (!allFound)
+        allFound = checkIfAllSelectorsFound();
+      if (allFound) {
+        for (const parsedRule of parsedArgs) {
+          const queryAndApply = initQueryAndApply(parsedRule.selector);
+          const delayInMiliseconds = parseInt$1(parsedRule.delay, 10);
+          if (parsedRule.trigger) {
+            queryAndApply(node => {
+              if (!dispatchedNodes.has(node)) {
+                dispatchedNodes.add(node);
+                if (parsedRule.continue) {
+                  setInterval(() => {
+                    triggerEvent(node, parsedRule.event, parsedRule.delay);
+                  }, delayInMiliseconds);
+                }
+                else {
+                  setTimeout$1(() => {
+                    triggerEvent(node, parsedRule.event, parsedRule.delay);
+                  }, delayInMiliseconds);
+                }
+              }
+            });
+          }
+        }
+      }
+      end();
+    }
+  }
+
+  let {isNaN, MutationObserver: MutationObserver$1, parseInt, parseFloat, setTimeout} = $(window);
+
+  function skipVideo(playerSelector, xpathCondition, ...attributes) {
+    const formattedArguments = formatArguments(arguments);
+    const optionalParameters = new Map([
+      ["-max-attempts", "10"],
+      ["-retry-ms", "10"],
+      ["-run-once", "false"],
+      ["-wait-until", ""],
+      ["-skip-to", "-0.1"],
+      ["-stop-on-video-end", "false"],
+      ["-start-from", "0"],
+      ["-mute-video-when-skipping", "true"]
+    ]);
+
+    for (let attr of attributes) {
+      attr = $(attr);
+      let markerIndex = attr.indexOf(":");
+      if (markerIndex < 0)
+        continue;
+
+      let key = attr.slice(0, markerIndex).trim().toString();
+      let value = attr.slice(markerIndex + 1).trim().toString();
+
+      if (key && value && optionalParameters.has(key))
+        optionalParameters.set(key, value);
+    }
+
+    const maxAttemptsStr = optionalParameters.get("-max-attempts");
+    const maxAttemptsNum = parseInt(maxAttemptsStr || 10, 10);
+
+    const retryMsStr = optionalParameters.get("-retry-ms");
+    const retryMsNum = parseInt(retryMsStr || 10, 10);
+
+    const runOnceStr = optionalParameters.get("-run-once");
+    const runOnceFlag = (runOnceStr === "true");
+
+    const skipToStr = optionalParameters.get("-skip-to");
+    const skipToNum = parseFloat(skipToStr || -0.1);
+
+    const startFromStr = optionalParameters.get("-start-from");
+    const startFrom = parseInt(startFromStr || 0, 10);
+
+    const waitUntil = optionalParameters.get("-wait-until");
+
+    const stopOnVideoEndStr = optionalParameters.get("-stop-on-video-end");
+    const stopOnVideoEndFlag = (stopOnVideoEndStr === "true");
+
+    const muteVideoStr = optionalParameters.get("-mute-video-when-skipping");
+    const muteVideo = !(muteVideoStr === "false");
+
+    const debugLog = getDebugger("skip-video");
+    const {mark, end} = profile("skip-video");
+    const queryAndApply = initQueryAndApply(`xpath(${xpathCondition})`);
+    let skippedOnce = false;
+
+    const mainLogic = () => {
+      mark();
+      const seenMap = new WeakSet();
+      const callback = (retryCounter = 0) => {
+        if (skippedOnce && runOnceFlag) {
+          if (mo)
+            mo.disconnect();
+          return;
+        }
+        queryAndApply(node => {
+          let nodeAlreadySeen = seenMap.has(node);
+          let lastSkippedVideoDuration;
+          if (!nodeAlreadySeen) {
+            debugLog("info", "Matched:", node, " for selector: ", xpathCondition);
+            debugLog("info", "Running video skipping logic.");
+          }
+          const videos = $$(playerSelector);
+          let foundValidVideo = false;
+          for (const video of videos) {
+            if (!video || isNaN(video.duration) || isNaN(video.currentTime))
+              continue;
+            foundValidVideo = true;
+            const videoNearEnd = (video.duration - video.currentTime) < 0.5;
+            if ((video.duration > 0) && (video.currentTime < video.duration) &&
+                !(stopOnVideoEndFlag && videoNearEnd)) {
+              if (muteVideo) {
+                video.muted = true;
+                if (!nodeAlreadySeen)
+                  debugLog("success", "Muted video...");
+              }
+              if (startFrom <= video.currentTime * 1000) {
+
+                skipToNum <= 0 ?
+                  video.currentTime = video.duration + skipToNum :
+                  video.currentTime += skipToNum;
+                if (lastSkippedVideoDuration !== video.duration) {
+                  debugLog("success",
+                           "Skipped video, currentTime: ",
+                           video.currentTime,
+                           "s.",
+                           "\nFILTER: skip-video",
+                           formattedArguments);
+                  seenMap.add(node);
+                  lastSkippedVideoDuration = video.duration;
+                }
+                video.paused && video.play();
+                skippedOnce = true;
+                win();
+              }
+            }
+          }
+          if (!foundValidVideo && retryCounter < maxAttemptsNum) {
+            setTimeout(() => {
+              const attempt = retryCounter + 1;
+              debugLog("info",
+                       "Running video skipping logic. Attempt: ",
+                       attempt);
+              callback(attempt);
+            }, retryMsNum);
+          }
+        });
+      };
+      const mo = new MutationObserver$1(callback);
+      const win = raceWinner(
+        "skip-video",
+        () => mo.disconnect()
+      );
+      mo.observe(
+        document, {characterData: true, childList: true, subtree: true});
+      callback();
+      end();
+    };
+
+    waitUntilEvent(debugLog, mainLogic, waitUntil);
+  }
+
+  const snippets = {
+    log,
+    race,
+    "debug": setDebug,
+    "profile": setProfile,
+    "hide-if-matches-xpath": hideIfMatchesXPath,
+    "hide-if-matches-computed-xpath": hideIfMatchesComputedXPath,
+    "hide-if-contains": hideIfContains,
+    "hide-if-contains-similar-text": hideIfContainsSimilarText,
+    "hide-if-contains-visible-text": hideIfContainsVisibleText,
+    "hide-if-contains-and-matches-style": hideIfContainsAndMatchesStyle,
+    "hide-if-has-and-matches-style": hideIfHasAndMatchesStyle,
+    "hide-if-labelled-by": hideIfLabelledBy,
+    "hide-if-contains-image": hideIfContainsImage,
+    "simulate-mouse-event": simulateMouseEvent,
+    "skip-video": skipVideo
+  };
+
+  let {MutationObserver} = $(window);
+
+  const {ELEMENT_NODE} = Node;
+
+  function hideIfMatchesXPath3(query, scopeQuery) {
+    let {mark, end} = profile("hide-if-matches-xpath3");
+
+    const namespaceResolver = prefix => {
+      switch (prefix) {
+        case "": return "http://www.w3.org/1999/xhtml";
+        default: return false;
+      }
+    };
+    function queryNodes(nodeQuery) {
+      return fontoxpath.evaluateXPathToNodes(nodeQuery, document, null, null, {
+        language: fontoxpath.evaluateXPath.XQUERY_3_1_LANGUAGE,
+        namespaceResolver
+      });
+    }
+
+    const formattedArguments = formatArguments(arguments);
+    let debugLog = getDebugger("hide-if-matches-xpath3");
+
+    const startHidingMutationObserver = scopeNode => {
+      const seenMap = new WeakSet();
+      const callback = () => {
+        mark();
+
+        const nodes = queryNodes(query);
+        for (const node of $(nodes)) {
+          if (seenMap.has(node))
+            return false;
+          seenMap.add(node);
+          win();
+          if ($(node).nodeType === ELEMENT_NODE)
+            hideElement(node);
+          else
+            $(node).textContent = "";
+          debugLog("success",
+                   "Matched: ",
+                   node,
+                   "\nFILTER: hide-if-matches-xpath3",
+                   formattedArguments);
+        }
+        end();
+      };
+
+      const mo = new MutationObserver(callback);
+      const win = raceWinner(
+        "hide-if-matches-xpath3",
+        () => mo.disconnect()
+      );
+      mo.observe(
+        scopeNode, {characterData: true, childList: true, subtree: true});
+      callback();
+    };
+
+    if (scopeQuery) {
+
+      let count = 0;
+      let scopeMutationObserver;
+      const scopeNodes = queryNodes(scopeQuery);
+      const findMutationScopeNodes = () => {
+        for (const scopeNode of $(scopeNodes)) {
+
+          startHidingMutationObserver(scopeNode);
+          count++;
+        }
+        if (count > 0)
+          scopeMutationObserver.disconnect();
+      };
+
+      scopeMutationObserver = new MutationObserver(findMutationScopeNodes);
+      scopeMutationObserver.observe(
+        document, {characterData: true, childList: true, subtree: true}
+      );
+      findMutationScopeNodes();
+    }
+    else {
+
+      startHidingMutationObserver(document);
+    }
+  }
+
+  snippets["hide-if-matches-xpath3"] = hideIfMatchesXPath3;
+  let context;
+  for (const [name, ...args] of filters) {
+    if (snippets.hasOwnProperty(name)) {
+      try { context = snippets[name].apply(context, args); }
+      catch (error) { console.error(error); }
+    }
+  }
+  context = void 0;
+})(e, ...t);
+
+const callback = (environment, ...filters) => {
+  /*!
+   * This file is part of eyeo's Anti-Circumvention Snippets module (@eyeo/snippets),
+   * Copyright (C) 2006-present eyeo GmbH
+   *
+   * @eyeo/snippets is free software: you can redistribute it and/or modify
+   * it under the terms of the GNU General Public License version 3 as
+   * published by the Free Software Foundation.
+   *
+   * @eyeo/snippets is distributed in the hope that it will be useful,
+   * but WITHOUT ANY WARRANTY; without even the implied warranty of
+   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   * GNU General Public License for more details.
+   *
+   * You should have received a copy of the GNU General Public License
+   * along with @eyeo/snippets.  If not, see <http://www.gnu.org/licenses/>.
+   */
+  const $$1 = Proxy;
+
+  const {apply: a, bind: b, call: c} = Function;
+  const apply$2 = c.bind(a);
+  const bind = c.bind(b);
+  const call = c.bind(c);
+
+  const callerHandler = {
+    get(target, name) {
+      return bind(c, target[name]);
+    }
+  };
+  const caller = target => new $$1(target, callerHandler);
+
+  const proxy = (source, target) => new $$1(source, {
+    apply: (_, self, args) => apply$2(target, self, args)
+  });
+
+  const handler$2 = {
+    get(target, name) {
+      return bind(target[name], target);
+    }
+  };
+  const bound = target => new $$1(target, handler$2);
+
+  const {
+    assign: assign$1,
+    defineProperties: defineProperties$1,
+    freeze: freeze$1,
+    getOwnPropertyDescriptor: getOwnPropertyDescriptor$3,
+    getOwnPropertyDescriptors: getOwnPropertyDescriptors$1,
+    getPrototypeOf
+  } = bound(Object);
+
+  const {hasOwnProperty} = caller({});
+
+  const {species} = Symbol;
+
+  const handler$1 = {
+    get(target, name) {
+      const Native = target[name];
+      class Secure extends Native {}
+
+      const proto = getOwnPropertyDescriptors$1(Native.prototype);
+      delete proto.constructor;
+      freeze$1(defineProperties$1(Secure.prototype, proto));
+
+      const statics = getOwnPropertyDescriptors$1(Native);
+      delete statics.length;
+      delete statics.prototype;
+      statics[species] = {value: Secure};
+      return freeze$1(defineProperties$1(Secure, statics));
+    }
+  };
+
+  const secure = target => new $$1(target, handler$1);
+
+  const libEnvironment = typeof environment !== "undefined" ? environment :
+                                                                     {};
+
+  if (typeof globalThis === "undefined")
+    window.globalThis = window;
+
+  const {apply: apply$1, ownKeys} = bound(Reflect);
+
+  const worldEnvDefined = "world" in libEnvironment;
+  const isIsolatedWorld = worldEnvDefined && libEnvironment.world === "ISOLATED";
+  const isMainWorld = worldEnvDefined && libEnvironment.world === "MAIN";
+  const isChrome = typeof chrome === "object" && !!chrome.runtime;
+  const isOtherThanChrome = typeof browser === "object" && !!browser.runtime;
+  const isExtensionContext$2 = !isMainWorld &&
+    (isIsolatedWorld || isChrome || isOtherThanChrome);
+  const copyIfExtension = value => isExtensionContext$2 ?
+    value :
+    create(value, getOwnPropertyDescriptors(value));
+
+  const {
+    create,
+    defineProperties,
+    defineProperty,
+    freeze,
+    getOwnPropertyDescriptor: getOwnPropertyDescriptor$2,
+    getOwnPropertyDescriptors
+  } = bound(Object);
+
+  const invokes = bound(globalThis);
+  const classes = isExtensionContext$2 ? globalThis : secure(globalThis);
+  const {Map: Map$b, RegExp: RegExp$3, Set: Set$3, WeakMap: WeakMap$5, WeakSet: WeakSet$4} = classes;
+
+  const augment = (source, target, method = null) => {
+    const known = ownKeys(target);
+    for (const key of ownKeys(source)) {
+      if (known.includes(key))
+        continue;
+
+      const descriptor = getOwnPropertyDescriptor$2(source, key);
+      if (method && "value" in descriptor) {
+        const {value} = descriptor;
+        if (typeof value === "function")
+          descriptor.value = method(value);
+      }
+      defineProperty(target, key, descriptor);
+    }
+  };
+
+  const primitive = name => {
+    const Super = classes[name];
+    class Class extends Super {}
+    const {toString, valueOf} = Super.prototype;
+    defineProperties(Class.prototype, {
+      toString: {value: toString},
+      valueOf: {value: valueOf}
+    });
+    const type = name.toLowerCase();
+    const method = callback => function() {
+      const result = apply$1(callback, this, arguments);
+      return typeof result === type ? new Class(result) : result;
+    };
+    augment(Super, Class, method);
+    augment(Super.prototype, Class.prototype, method);
+    return Class;
+  };
+
+  const variables$3 = freeze({
+    frozen: new WeakMap$5(),
+    hidden: new WeakSet$4(),
+    iframePropertiesToAbort: {
+      read: new Set$3(),
+      write: new Set$3()
+    },
+    abortedIframes: new WeakMap$5()
+  });
+
+  const startsCapitalized = new RegExp$3("^[A-Z]");
+
+  var env = new Proxy(new Map$b([
+
+    ["chrome", (
+      isExtensionContext$2 && (
+        (isChrome && chrome) ||
+        (isOtherThanChrome && browser)
+      )
+    ) || void 0],
+    ["isExtensionContext", isExtensionContext$2],
+    ["variables", variables$3],
+
+    ["console", copyIfExtension(console)],
+    ["document", globalThis.document],
+    ["JSON", copyIfExtension(JSON)],
+    ["Map", Map$b],
+    ["Math", copyIfExtension(Math)],
+    ["Number", isExtensionContext$2 ? Number : primitive("Number")],
+    ["RegExp", RegExp$3],
+    ["Set", Set$3],
+    ["String", isExtensionContext$2 ? String : primitive("String")],
+    ["WeakMap", WeakMap$5],
+    ["WeakSet", WeakSet$4],
+
+    ["MouseEvent", MouseEvent]
+  ]), {
+    get(map, key) {
+      if (map.has(key))
+        return map.get(key);
+
+      let value = globalThis[key];
+      if (typeof value === "function")
+        value = (startsCapitalized.test(key) ? classes : invokes)[key];
+
+      map.set(key, value);
+      return value;
+    },
+    has(map, key) {
+      return map.has(key);
+    }
+  });
+
+  class WeakValue {
+    has() { return false; }
+    set() {}
+  }
+
+  const helpers = {WeakSet, WeakMap, WeakValue};
+  const {apply} = Reflect;
+
+  function transformOnce (callback) {  const {WeakSet, WeakMap, WeakValue} = (this || helpers);
+    const ws = new WeakSet;
+    const wm = new WeakMap;
+    const wv = new WeakValue;
+    return function (any) {
+      if (ws.has(any))
+        return any;
+
+      if (wm.has(any))
+        return wm.get(any);
+
+      if (wv.has(any))
+        return wv.get(any);
+
+      const value = apply(callback, this, arguments);
+      ws.add(value);
+      if (value !== any)
+        (typeof any === 'object' && any ? wm : wv).set(any, value);
+      return value;
+    };
+  }
+
+  const {Map: Map$a, WeakMap: WeakMap$4, WeakSet: WeakSet$3, setTimeout} = env;
+
+  let cleanup = true;
+  let cleanUpCallback = map => {
+    map.clear();
+    cleanup = !cleanup;
+  };
+
+  var transformer = transformOnce.bind({
+    WeakMap: WeakMap$4,
+    WeakSet: WeakSet$3,
+
+    WeakValue: class extends Map$a {
+      set(key, value) {
+        if (cleanup) {
+          cleanup = !cleanup;
+          setTimeout(cleanUpCallback, 0, this);
+        }
+        return super.set(key, value);
+      }
+    }
+  });
+
+  const {concat, includes, join, reduce, unshift} = caller([]);
+
+  const {Map: Map$9, WeakMap: WeakMap$3} = secure(globalThis);
+
+  const map = new Map$9;
+  const descriptors = target => {
+    const chain = [];
+    let current = target;
+    while (current) {
+      if (map.has(current))
+        unshift(chain, map.get(current));
+      else {
+        const descriptors = getOwnPropertyDescriptors$1(current);
+        map.set(current, descriptors);
+        unshift(chain, descriptors);
+      }
+      current = getPrototypeOf(current);
+    }
+    unshift(chain, {});
+    return apply$2(assign$1, null, chain);
+  };
+
+  const chain = source => {
+    const target = typeof source === 'function' ? source.prototype : source;
+    const chained = descriptors(target);
+    const handler = {
+      get(target, key) {
+        if (key in chained) {
+          const {value, get} = chained[key];
+          if (get)
+            return call(get, target);
+          if (typeof value === 'function')
+            return bind(value, target);
+        }
+        return target[key];
+      },
+      set(target, key, value) {
+        if (key in chained) {
+          const {set} = chained[key];
+          if (set) {
+            call(set, target, value);
+            return true;
+          }
+        }
+        target[key] = value;
+        return true;
+      }
+    };
+    return target => new Proxy(target, handler);
+  };
+
+  const {
+    isExtensionContext: isExtensionContext$1,
+    Array: Array$6,
+    Number: Number$1,
+    String: String$1,
+    Object: Object$c
+  } = env;
+
+  const {isArray} = Array$6;
+  const {getOwnPropertyDescriptor: getOwnPropertyDescriptor$1, setPrototypeOf: setPrototypeOf$1} = Object$c;
+
+  const {toString: toString$1} = Object$c.prototype;
+  const {slice} = String$1.prototype;
+  const getBrand = value => call(slice, call(toString$1, value), 8, -1);
+
+  const {get: nodeType} = getOwnPropertyDescriptor$1(Node.prototype, "nodeType");
+
+  const chained = isExtensionContext$1 ? {} : {
+    Attr: chain(Attr),
+    CanvasRenderingContext2D: chain(CanvasRenderingContext2D),
+    CSSStyleDeclaration: chain(CSSStyleDeclaration),
+    Document: chain(Document),
+    Element: chain(Element),
+    HTMLCanvasElement: chain(HTMLCanvasElement),
+    HTMLElement: chain(HTMLElement),
+    HTMLImageElement: chain(HTMLImageElement),
+    HTMLScriptElement: chain(HTMLScriptElement),
+    MutationRecord: chain(MutationRecord),
+    Node: chain(Node),
+    ShadowRoot: chain(ShadowRoot),
+
+    get CSS2Properties() {
+      return chained.CSSStyleDeclaration;
+    }
+  };
+
+  const upgrade = (value, hint) => {
+    if (hint !== "Element" && hint in chained)
+      return chained[hint](value);
+
+    if (isArray(value))
+      return setPrototypeOf$1(value, Array$6.prototype);
+
+    const brand = getBrand(value);
+    if (brand in chained)
+      return chained[brand](value);
+
+    if (brand in env)
+      return setPrototypeOf$1(value, env[brand].prototype);
+
+    if ("nodeType" in value) {
+      switch (call(nodeType, value)) {
+        case 1:
+          if (!(hint in chained))
+            throw new Error("unknown hint " + hint);
+          return chained[hint](value);
+        case 2:
+          return chained.Attr(value);
+        case 3:
+          return chained.Node(value);
+        case 9:
+          return chained.Document(value);
+      }
+    }
+
+    throw new Error("unknown brand " + brand);
+  };
+
+  var $ = isExtensionContext$1 ?
+    value => (value === window || value === globalThis ? env : value) :
+    transformer((value, hint = "Element") => {
+      if (value === window || value === globalThis)
+        return env;
+
+      switch (typeof value) {
+        case "object":
+          return value && upgrade(value, hint);
+
+        case "string":
+          return new String$1(value);
+
+        case "number":
+          return new Number$1(value);
+
+        default:
+          throw new Error("unsupported value");
+      }
+    });
+
+  const handler = {
+    get(target, name) {
+      const context = target;
+      while (!hasOwnProperty(target, name))
+        target = getPrototypeOf(target);
+      const {get, set} = getOwnPropertyDescriptor$3(target, name);
+      return function () {
+        return arguments.length ?
+                apply$2(set, context, arguments) :
+                call(get, context);
+      };
+    }
+  };
+
+  const accessor = target => new $$1(target, handler);
+
+  let {Math: Math$2, setInterval: setInterval$1, performance} = $(window);
+
+  const noopProfile = {
+    mark() {},
+    end() {},
+    toString() {
+      return "{mark(){},end(){}}";
+    }
+  };
+
+  let inactive = true;
+
+  function setProfile() {
+    inactive = false;
+  }
+
+  function profile(id, rate = 10) {
+    if (inactive)
+      return noopProfile;
+    function processSamples() {
+      let samples = $([]);
+
+      for (let {name, duration} of performance.getEntriesByType("measure"))
+        samples.push({name, duration});
+
+      if (samples.length)
+        performance.clearMeasures();
+    }
+
+    if (!profile[id]) {
+      profile[id] = setInterval$1(processSamples,
+                                Math$2.round(60000 / Math$2.min(60, rate)));
+    }
+
+    return {
+      mark() {
+        performance.mark(id);
+      },
+      end(clear = false) {
+        const measureObj = performance.measure(id, id);
+        console.log("PROFILER:", measureObj);
+        performance.clearMarks(id);
+        if (clear) {
+          clearInterval(profile[id]);
+          delete profile[id];
+          processSamples();
+        }
+      }
+    };
+  }
+
+  let debugging = false;
+
+  function debug() {
+    return debugging;
+  }
+
+  function setDebug() {
+    debugging = true;
+  }
+
+  const {console: console$4} = $(window);
+
+  const noop = () => {};
+
+  function log(...args) {
+    let {mark, end} = profile("log");
+    if (debug()) {
+      const logArgs = ["%c DEBUG", "font-weight: bold;"];
+
+      const isErrorIndex = args.indexOf("error");
+      const isWarnIndex = args.indexOf("warn");
+      const isSuccessIndex = args.indexOf("success");
+      const isInfoIndex = args.indexOf("info");
+
+      if (isErrorIndex !== -1) {
+        logArgs[0] += " - ERROR";
+        logArgs[1] += "color: red; border:2px solid red";
+        $(args).splice(isErrorIndex, 1);
+      }
+      else if (isWarnIndex !== -1) {
+        logArgs[0] += " - WARNING";
+        logArgs[1] += "color: orange; border:2px solid orange ";
+        $(args).splice(isWarnIndex, 1);
+      }
+      else if (isSuccessIndex !== -1) {
+        logArgs[0] += " - SUCCESS";
+        logArgs[1] += "color: green; border:2px solid green";
+        $(args).splice(isSuccessIndex, 1);
+      }
+      else if (isInfoIndex !== -1) {
+        logArgs[1] += "color: black;";
+        $(args).splice(isInfoIndex, 1);
+      }
+
+      $(args).unshift(...logArgs);
+    }
+    mark();
+    console$4.log(...args);
+    end();
+  }
+
+  function getDebugger(name) {
+    return bind(debug() ? log : noop, null, name);
+  }
+
+  let {Array: Array$5, Math: Math$1, RegExp: RegExp$2} = $(window);
+
+  function regexEscape(string) {
+    return $(string).replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
+  }
+
+  function toRegExp(pattern) {
+    let {length} = pattern;
+
+    if (length > 1 && pattern[0] === "/") {
+      let isCaseSensitive = pattern[length - 1] === "/";
+
+      if (isCaseSensitive || (length > 2 && $(pattern).endsWith("/i"))) {
+        let args = [$(pattern).slice(1, isCaseSensitive ? -1 : -2)];
+        if (!isCaseSensitive)
+          args.push("i");
+
+        return new RegExp$2(...args);
+      }
+    }
+
+    return new RegExp$2(regexEscape(pattern));
+  }
+
+  function randomId() {
+
+    return $(Math$1.floor(Math$1.random() * 2116316160 + 60466176)).toString(36);
+  }
+
+  function formatArguments(args) {
+    return $(Array$5.from(args)).map(arg => `'${arg}'`).join(" ");
+  }
+
+  let {
+    parseFloat,
+    variables: variables$2,
+    Array: Array$4,
+    Error: Error$8,
+    Map: Map$8,
+    Object: Object$b,
+    ReferenceError: ReferenceError$2,
+    Set: Set$2,
+    WeakMap: WeakMap$2
+  } = $(window);
+
+  let {onerror} = accessor(window);
+
+  let NodeProto$1 = Node.prototype;
+  let ElementProto$2 = Element.prototype;
+
+  let propertyAccessors = null;
+
+  function wrapPropertyAccess(object, property, descriptor,
+                                     setConfigurable = true) {
+    let $property = $(property);
+    let dotIndex = $property.indexOf(".");
+    if (dotIndex == -1) {
+
+      let currentDescriptor = Object$b.getOwnPropertyDescriptor(object, property);
+      if (currentDescriptor && !currentDescriptor.configurable)
+        return;
+
+      let newDescriptor = Object$b.assign({}, descriptor, {
+        configurable: setConfigurable
+      });
+
+      if (!currentDescriptor && !newDescriptor.get && newDescriptor.set) {
+        let propertyValue = object[property];
+        newDescriptor.get = () => propertyValue;
+      }
+
+      Object$b.defineProperty(object, property, newDescriptor);
+      return;
+    }
+
+    let name = $property.slice(0, dotIndex).toString();
+    property = $property.slice(dotIndex + 1).toString();
+    let value = object[name];
+    if (value && (typeof value == "object" || typeof value == "function"))
+      wrapPropertyAccess(value, property, descriptor);
+
+    let currentDescriptor = Object$b.getOwnPropertyDescriptor(object, name);
+    if (currentDescriptor && !currentDescriptor.configurable)
+      return;
+
+    if (!propertyAccessors)
+      propertyAccessors = new WeakMap$2();
+
+    if (!propertyAccessors.has(object))
+      propertyAccessors.set(object, new Map$8());
+
+    let properties = propertyAccessors.get(object);
+    if (properties.has(name)) {
+      properties.get(name).set(property, descriptor);
+      return;
+    }
+
+    let toBeWrapped = new Map$8([[property, descriptor]]);
+    properties.set(name, toBeWrapped);
+    Object$b.defineProperty(object, name, {
+      get: () => value,
+      set(newValue) {
+        value = newValue;
+        if (value && (typeof value == "object" || typeof value == "function")) {
+
+          for (let [prop, desc] of toBeWrapped)
+            wrapPropertyAccess(value, prop, desc);
+        }
+      },
+      configurable: setConfigurable
+    });
+  }
+
+  function overrideOnError(magic) {
+    let prev = onerror();
+    onerror((...args) => {
+      let message = args.length && args[0];
+      if (typeof message == "string" && $(message).includes(magic))
+        return true;
+      if (typeof prev == "function")
+        return apply$2(prev, this, args);
+    });
+  }
+
+  function abortOnRead(loggingPrefix, context,
+                              property, formattedProperties = "",
+                              setConfigurable = true) {
+    let debugLog = getDebugger(loggingPrefix);
+
+    if (!property) {
+      debugLog("error", "no property to abort on read");
+      return;
+    }
+
+    let rid = randomId();
+
+    function abort() {
+      debugLog("success", `${property} access aborted`, `\nFILTER: ${loggingPrefix} ${formattedProperties}`);
+      throw new ReferenceError$2(rid);
+    }
+
+    debugLog("info", `aborting on ${property} access`);
+
+    wrapPropertyAccess(context,
+                       property,
+                       {get: abort, set() {}},
+                       setConfigurable);
+    overrideOnError(rid);
+  }
+
+  function abortOnWrite(loggingPrefix,
+                               context, property,
+                               formattedProperties = "",
+                               setConfigurable = true) {
+    let debugLog = getDebugger(loggingPrefix);
+
+    if (!property) {
+      debugLog("error", "no property to abort on write");
+      return;
+    }
+
+    let rid = randomId();
+
+    function abort() {
+      debugLog("success", `setting ${property} aborted`, `\nFILTER: ${loggingPrefix} ${formattedProperties}`);
+      throw new ReferenceError$2(rid);
+    }
+
+    debugLog("info", `aborting when setting ${property}`);
+
+    wrapPropertyAccess(context, property, {set: abort}, setConfigurable);
+    overrideOnError(rid);
+  }
+
+  function abortOnIframe(
+    properties,
+    abortRead = false,
+    abortWrite = false
+  ) {
+    let abortedIframes = variables$2.abortedIframes;
+    let iframePropertiesToAbort = variables$2.iframePropertiesToAbort;
+
+    const formattedPropertiesToLog = formatArguments(properties);
+
+    for (let frame of Array$4.from(window.frames)) {
+      if (abortedIframes.has(frame)) {
+        for (let property of properties) {
+          if (abortRead)
+
+            abortedIframes.get(frame).read.add({property, formattedProperties: formattedPropertiesToLog});
+          if (abortWrite)
+
+            abortedIframes.get(frame).write.add({property, formattedProperties: formattedPropertiesToLog});
+        }
+      }
+    }
+
+    for (let property of properties) {
+      if (abortRead)
+
+        iframePropertiesToAbort.read.add({property, formattedProperties: formattedPropertiesToLog});
+      if (abortWrite)
+
+        iframePropertiesToAbort.write.add({property, formattedProperties: formattedPropertiesToLog});
+    }
+
+    queryAndProxyIframe();
+    if (!abortedIframes.has(document)) {
+      abortedIframes.set(document, true);
+      addHooksOnDomAdditions(queryAndProxyIframe);
+    }
+
+    function queryAndProxyIframe() {
+      for (let frame of Array$4.from(window.frames)) {
+
+        if (!abortedIframes.has(frame)) {
+          abortedIframes.set(frame, {
+            read: new Set$2(iframePropertiesToAbort.read),
+            write: new Set$2(iframePropertiesToAbort.write)
+          });
+        }
+
+        let readProps = abortedIframes.get(frame).read;
+        if (readProps.size > 0) {
+          let props = Array$4.from(readProps);
+          readProps.clear();
+          for (let {property, formattedProperties} of props) {
+            abortOnRead("abort-on-iframe-property-read",
+                        frame,
+                        property,
+                        formattedProperties);
+          }
+        }
+
+        let writeProps = abortedIframes.get(frame).write;
+        if (writeProps.size > 0) {
+          let props = Array$4.from(writeProps);
+          writeProps.clear();
+          for (let {property, formattedProperties} of props) {
+            abortOnWrite("abort-on-iframe-property-write",
+                         frame,
+                         property,
+                         formattedProperties);
+          }
+        }
+      }
+    }
+  }
+
+  function addHooksOnDomAdditions(endCallback) {
+    let descriptor;
+
+    wrapAccess(NodeProto$1, ["appendChild", "insertBefore", "replaceChild"]);
+    wrapAccess(ElementProto$2, ["append", "prepend", "replaceWith", "after",
+                              "before", "insertAdjacentElement",
+                              "insertAdjacentHTML"]);
+
+    descriptor = getInnerHTMLDescriptor(ElementProto$2, "innerHTML");
+    wrapPropertyAccess(ElementProto$2, "innerHTML", descriptor);
+
+    descriptor = getInnerHTMLDescriptor(ElementProto$2, "outerHTML");
+    wrapPropertyAccess(ElementProto$2, "outerHTML", descriptor);
+
+    function wrapAccess(prototype, names) {
+      for (let name of names) {
+        let desc = getAppendChildDescriptor(prototype, name);
+        wrapPropertyAccess(prototype, name, desc);
+      }
+    }
+
+    function getAppendChildDescriptor(target, property) {
+      let currentValue = target[property];
+      return {
+        get() {
+          return function(...args) {
+            let result;
+            result = apply$2(currentValue, this, args);
+            endCallback && endCallback();
+            return result;
+          };
+        }
+      };
+    }
+
+    function getInnerHTMLDescriptor(target, property) {
+      let desc = Object$b.getOwnPropertyDescriptor(target, property);
+      let {set: prevSetter} = desc || {};
+      return {
+        set(val) {
+          let result;
+          result = call(prevSetter, this, val);
+          endCallback && endCallback();
+          return result;
+        }
+      };
+    }
+  }
+
+  let {Object: NativeObject} = window;
+  function findOwner(root, path) {
+    if (!(root instanceof NativeObject))
+      return;
+
+    let object = root;
+    let chain = $(path).split(".");
+
+    if (chain.length === 0)
+      return;
+
+    for (let i = 0; i < chain.length - 1; i++) {
+      let prop = chain[i];
+
+      if (!hasOwnProperty(object, prop))
+        return;
+
+      object = object[prop];
+
+      if (!(object instanceof NativeObject))
+        return;
+    }
+
+    let prop = chain[chain.length - 1];
+
+    if (hasOwnProperty(object, prop))
+      return [object, prop];
+  }
+
+  const decimals = $(/^\d+$/);
+
+  function overrideValue(value) {
+    switch (value) {
+      case "false":
+        return false;
+      case "true":
+        return true;
+      case "null":
+        return null;
+      case "noopFunc":
+        return () => {};
+      case "trueFunc":
+        return () => true;
+      case "falseFunc":
+        return () => false;
+      case "emptyArray":
+        return [];
+      case "emptyObj":
+        return {};
+      case "undefined":
+        return void 0;
+      case "":
+        return value;
+      default:
+        if (decimals.test(value))
+          return parseFloat(value);
+
+        throw new Error$8("[override-property-read snippet]: " +
+                        `Value "${value}" is not valid.`);
+    }
+  }
+
+  let {HTMLScriptElement: HTMLScriptElement$1, Object: Object$a, ReferenceError: ReferenceError$1} = $(window);
+  let Script = Object$a.getPrototypeOf(HTMLScriptElement$1);
+
+  function abortCurrentInlineScript(api, search = null) {
+    const formattedArguments = formatArguments(arguments);
+    const debugLog = getDebugger("abort-current-inline-script");
+    const {mark, end} = profile("abort-current-inline-script");
+    const re = search ? toRegExp(search) : null;
+
+    const rid = randomId();
+    const us = $(document).currentScript;
+
+    let object = window;
+    const path = $(api).split(".");
+    const name = $(path).pop();
+
+    for (let node of $(path)) {
+      object = object[node];
+      if (
+        !object || !(typeof object == "object" || typeof object == "function")) {
+        debugLog("warn", path, " is not found");
+        return;
+      }
+    }
+
+    const {get: prevGetter, set: prevSetter} =
+      Object$a.getOwnPropertyDescriptor(object, name) || {};
+
+    let currentValue = object[name];
+    if (typeof currentValue === "undefined")
+      debugLog("warn", "The property", name, "doesn't exist yet. Check typos.");
+
+    const abort = () => {
+      const element = $(document).currentScript;
+      if (element instanceof Script &&
+          $(element, "HTMLScriptElement").src == "" &&
+          element != us &&
+          (!re || re.test($(element).textContent))) {
+        debugLog("success",
+                 path,
+                 " is aborted \n",
+                 element,
+                 "\nFILTER: abort-current-inline-script",
+                 formattedArguments);
+        throw new ReferenceError$1(rid);
+      }
+    };
+
+    const descriptor = {
+      get() {
+        abort();
+
+        if (prevGetter)
+          return call(prevGetter, this);
+
+        return currentValue;
+      },
+      set(value) {
+        abort();
+
+        if (prevSetter)
+          call(prevSetter, this, value);
+        else
+          currentValue = value;
+      }
+    };
+
+    mark();
+    wrapPropertyAccess(object,
+                       name,
+                       descriptor);
+    end();
+
+    overrideOnError(rid);
+  }
+
+  function abortOnIframePropertyRead(...properties) {
+    const {mark, end} = profile("abort-on-iframe-property-read");
+    mark();
+    abortOnIframe(properties, true, false);
+    end();
+  }
+
+  function abortOnIframePropertyWrite(...properties) {
+    const {mark, end} = profile("abort-on-iframe-property-write");
+    mark();
+    abortOnIframe(properties, false, true);
+    end();
+  }
+
+  function abortOnPropertyRead(property, setConfigurable) {
+    const configurableFlag = !(setConfigurable === "false");
+    const formattedArguments = formatArguments(arguments);
+    const {mark, end} = profile("abort-on-property-read");
+    mark();
+    abortOnRead("abort-on-property-read",
+                window,
+                property,
+                formattedArguments,
+                configurableFlag);
+    end();
+  }
+
+  function abortOnPropertyWrite(property, setConfigurable) {
+    const formattedArguments = formatArguments(arguments);
+    const {mark, end} = profile("abort-on-property-write");
+    const configurableFlag = !(setConfigurable === "false");
+    mark();
+    abortOnWrite("abort-on-property-write",
+                 window,
+                 property,
+                 formattedArguments,
+                 configurableFlag);
+    end();
+  }
+
+  const {Error: Error$7, Object: Object$9, Array: Array$3, Map: Map$7} = $(window);
+
+  let arrayValues = null;
+
+  function arrayOverride(method, needle, returnValue = "false") {
+    if (!method)
+      throw new Error$7("[array-override snippet]: Missing method to override.");
+
+    if (!needle)
+      throw new Error$7("[array-override snippet]: Missing needle.");
+
+    if (!arrayValues)
+      arrayValues = new Map$7();
+
+    let debugLog = getDebugger("array-override");
+    const {mark, end} = profile("array-override");
+    const formattedArgsToLog = formatArguments(arguments);
+
+    if (method === "push" && !arrayValues.has("push")) {
+      mark();
+      const {push} = Array$3.prototype;
+      arrayValues.set("push", $([]));
+
+      Object$9.defineProperty(window.Array.prototype, "push", {
+        value: proxy(push, function(val) {
+
+          if (!(typeof val === "string" || typeof val === "number"))
+            return apply$2(push, this, arguments);
+
+          const valStr = val.toString();
+          const overrideVals = arrayValues.get("push");
+          for (const {needleRegex} of overrideVals) {
+            if (valStr.match && valStr.match(needleRegex)) {
+              debugLog("success", `Array.push is ignored for needle: ${needleRegex}\nFILTER: array-override ${formattedArgsToLog}`);
+              return;
+            }
+          }
+          return apply$2(push, this, arguments);
+        })
+      });
+      debugLog("info", "Wrapped Array.prototype.push");
+      end();
+    }
+
+    else if (method === "includes" && !arrayValues.has("includes")) {
+      mark();
+      const {includes} = Array$3.prototype;
+      arrayValues.set("includes", $([]));
+
+      Object$9.defineProperty(window.Array.prototype, "includes", {
+        value: proxy(includes, function(val) {
+
+          if (!(typeof val === "string" || typeof val === "number"))
+            return apply$2(includes, this, arguments);
+
+          const valStr = val.toString();
+          const overrideVals = arrayValues.get("includes");
+          for (const {needleRegex, retVal} of overrideVals) {
+            if (valStr.match && valStr.match(needleRegex)) {
+              debugLog("success", `Array.includes returned ${retVal} for ${needleRegex}\nFILTER: array-override ${formattedArgsToLog}`);
+              return retVal;
+            }
+          }
+          return apply$2(includes, this, arguments);
+        })
+      });
+      debugLog("info", "Wrapped Array.prototype.includes");
+      end();
+    }
+
+    const needleRegex = toRegExp(needle);
+    const overrideVals = arrayValues.get(method);
+    const retVal = returnValue === "true";
+    overrideVals.push({needleRegex, retVal});
+    arrayValues.set(method, overrideVals);
+  }
+
+  let {Error: Error$6, URL: URL$2} = $(window);
+  let {cookie: documentCookies} = accessor(document);
+
+  function cookieRemover(cookie, autoRemoveCookie = false) {
+    if (!cookie)
+      throw new Error$6("[cookie-remover snippet]: No cookie to remove.");
+
+    const formattedArguments = formatArguments(arguments);
+    let debugLog = getDebugger("cookie-remover");
+    const {mark, end} = profile("cookie-remover");
+    let re = toRegExp(cookie);
+
+    if (!$(/^http|^about/).test(location.protocol)) {
+      debugLog("warn", "Snippet only works for http or https and about.");
+      return;
+    }
+
+    function getCookieMatches() {
+      const arr = $(documentCookies()).split(";");
+      return arr.filter(str => re.test($(str).split("=")[0]));
+    }
+
+    const mainLogic = () => {
+      debugLog("info", "Parsing cookies for matches");
+      mark();
+      for (const pair of $(getCookieMatches())) {
+        let $hostname = $(location.hostname);
+
+        if (!$hostname &&
+          $(location.ancestorOrigins) && $(location.ancestorOrigins[0]))
+          $hostname = new URL$2($(location.ancestorOrigins[0])).hostname;
+        const name = $(pair).split("=")[0];
+        const expires = "expires=Thu, 01 Jan 1970 00:00:00 GMT";
+        const path = "path=/";
+        const domainParts = $hostname.split(".");
+
+        for (let numDomainParts = domainParts.length;
+          numDomainParts > 0; numDomainParts--) {
+          const domain =
+            domainParts.slice(domainParts.length - numDomainParts).join(".");
+          documentCookies(`${$(name).trim()}=;${expires};${path};domain=${domain}`);
+          documentCookies(`${$(name).trim()}=;${expires};${path};domain=.${domain}`);
+          debugLog("success", `Set expiration date on ${name}`, "\nFILTER: cookie-remover", formattedArguments);
+        }
+      }
+      end();
+    };
+
+    mainLogic();
+
+    if (autoRemoveCookie) {
+
+      let lastCookie = getCookieMatches();
+      setInterval(() => {
+        let newCookie = getCookieMatches();
+        if (newCookie !== lastCookie) {
+          try {
+            mainLogic();
+          }
+          finally {
+            lastCookie = newCookie;
+          }
+        }
+      }, 1000);
+    }
+  }
+
+  let {
+    console: console$3,
+    document: document$2,
+    getComputedStyle,
+    isExtensionContext,
+    variables: variables$1,
+    Array: Array$2,
+    MutationObserver: MutationObserver$3,
+    Object: Object$8,
+    XPathEvaluator,
+    XPathExpression,
+    XPathResult
+  } = $(window);
+
+  const {querySelectorAll} = document$2;
+  const document$$ = querySelectorAll && bind(querySelectorAll, document$2);
+
+  function $openOrClosedShadowRoot(element, failSilently = false) {
+    try {
+      const shadowRoot = (navigator.userAgent.includes("Firefox")) ?
+        element.openOrClosedShadowRoot :
+        browser.dom.openOrClosedShadowRoot(element);
+      if (shadowRoot === null && ((debug() && !failSilently)))
+        console$3.log("Shadow root not found or not added in element yet", element);
+      return shadowRoot;
+    }
+    catch (error) {
+      if (debug() && !failSilently)
+        console$3.log("Error while accessing shadow root", element, error);
+      return null;
+    }
+  }
+
+  function $$(selector, returnRoots = false) {
+
+    return $$recursion(
+      selector,
+      document$$.bind(document$2),
+      document$2,
+      returnRoots
+    );
+  }
+
+  function isArrayEmptyStrings(arr) {
+    return !arr || arr.length === 0 || arr.every(item => item.trim() === "");
+  }
+
+  function executeSvgCommand(
+    nestedCommands,
+    rootParent,
+    resultNodes,
+    rootParents
+  ) {
+    const xlinkHref = rootParent.getAttribute("xlink:href") ||
+            rootParent.getAttribute("href");
+    if (xlinkHref) {
+      const matchingElement = document$$(xlinkHref)[0];
+      if (!matchingElement && debug()) {
+        console$3.log("No elements found matching", xlinkHref);
+        return false;
+      }
+
+      if (isArrayEmptyStrings(nestedCommands)) {
+        const oldRootParents = rootParents.length > 0 ? rootParents : [];
+        resultNodes.push({
+          element: matchingElement,
+          rootParents: [...oldRootParents, rootParent]
+        });
+        return false;
+      }
+      const next$$ = matchingElement.querySelectorAll.bind(matchingElement);
+      return {
+        nextBoundElement: matchingElement,
+        nestedSelectorsString: nestedCommands.join("^^"),
+        next$$
+      };
+    }
+  }
+
+  function executeShadowRootCommand(nestedCommands, rootParent) {
+    const shadowRoot = $openOrClosedShadowRoot(rootParent);
+    if (shadowRoot) {
+      const {querySelectorAll: shadowRootQuerySelectorAll} = shadowRoot;
+      const next$$ = shadowRootQuerySelectorAll &&
+        bind(shadowRootQuerySelectorAll, shadowRoot).bind(shadowRoot);
+      return {
+        nextBoundElement: rootParent,
+        nestedSelectorsString: ":host " + nestedCommands.join("^^"),
+        next$$
+      };
+    }
+
+    return false;
+  }
+
+  function $$recursion(
+    selector,
+    bound$$,
+    boundElement,
+    returnRoots,
+    rootParents = []
+  ) {
+    if (selector.includes("^^")) {
+      const [currentSelector, currentCommand, ...nestedCommands] =
+        selector.split("^^");
+      let newRootParents;
+
+      let commandFn;
+      switch (currentCommand) {
+        case "svg": {
+          commandFn = executeSvgCommand;
+          break;
+        }
+        case "sh": {
+          commandFn = executeShadowRootCommand;
+          break;
+        }
+        default: {
+          if (debug()) {
+            console$3.log(
+              currentCommand,
+              " is not supported. Supported commands are: \n^^sh^^\n^^svg^^"
+            );
+          }
+          return [];
+        }
+      }
+
+      if (currentSelector.trim() === "")
+        newRootParents = [boundElement];
+      else
+        newRootParents = bound$$(currentSelector);
+
+      const resultNodes = [];
+
+      for (const rootParent of newRootParents) {
+        const res =
+          commandFn(nestedCommands, rootParent, resultNodes, rootParents);
+        if (!res)
+          continue;
+        const {next$$, nestedSelectorsString, nextBoundElement} = res;
+        const nestedElements = $$recursion(
+          nestedSelectorsString,
+          next$$,
+          nextBoundElement,
+          returnRoots,
+          [...rootParents, rootParent]
+        );
+        if (nestedElements)
+          resultNodes.push(...nestedElements);
+      }
+      return resultNodes;
+    }
+    const foundElements = bound$$(selector);
+    if (returnRoots) {
+      return [...foundElements].map(element => (
+        {element, rootParents: rootParents.length > 0 ? rootParents : []})
+      );
+    }
+    return foundElements;
+  }
+
+  const {assign, setPrototypeOf} = Object$8;
+
+  class $XPathExpression extends XPathExpression {
+    evaluate(...args) {
+      return setPrototypeOf(
+        apply$2(super.evaluate, this, args),
+        XPathResult.prototype
+      );
+    }
+  }
+
+  class $XPathEvaluator extends XPathEvaluator {
+    createExpression(...args) {
+      return setPrototypeOf(
+        apply$2(super.createExpression, this, args),
+        $XPathExpression.prototype
+      );
+    }
+  }
+
+  function hideElement(element) {
+    if (variables$1.hidden.has(element))
+      return false;
+
+    notifyElementHidden(element);
+
+    variables$1.hidden.add(element);
+
+    let {style} = $(element);
+    let $style = $(style, "CSSStyleDeclaration");
+    let properties = $([]);
+    let {debugCSSProperties} = libEnvironment;
+
+    for (let [key, value] of (debugCSSProperties || [["display", "none"]])) {
+      $style.setProperty(key, value, "important");
+      properties.push([key, $style.getPropertyValue(key)]);
+    }
+
+    new MutationObserver$3(() => {
+      for (let [key, value] of properties) {
+        let propertyValue = $style.getPropertyValue(key);
+        let propertyPriority = $style.getPropertyPriority(key);
+        if (propertyValue != value || propertyPriority != "important")
+          $style.setProperty(key, value, "important");
+      }
+    }).observe(element, {attributes: true,
+                         attributeFilter: ["style"]});
+    return true;
+  }
+
+  function notifyElementHidden(element) {
+    if (isExtensionContext && typeof checkElement === "function")
+      checkElement(element);
+  }
+
+  function initQueryAndApply(selector) {
+    let $selector = selector;
+    if ($selector.startsWith("xpath(") &&
+        $selector.endsWith(")")) {
+      let xpathQuery = $selector.slice(6, -1);
+      let evaluator = new $XPathEvaluator();
+      let expression = evaluator.createExpression(xpathQuery, null);
+
+      let flag = XPathResult.ORDERED_NODE_SNAPSHOT_TYPE;
+
+      return cb => {
+        if (!cb)
+          return;
+        let result = expression.evaluate(document$2, flag, null);
+        let {snapshotLength} = result;
+        for (let i = 0; i < snapshotLength; i++)
+          cb(result.snapshotItem(i));
+      };
+    }
+    return cb => $$(selector).forEach(cb);
+  }
+
+  function initQueryAll(selector) {
+    let $selector = selector;
+    if ($selector.startsWith("xpath(") &&
+        $selector.endsWith(")")) {
+      let queryAndApply = initQueryAndApply(selector);
+      return () => {
+        let elements = $([]);
+        queryAndApply(e => elements.push(e));
+        return elements;
+      };
+    }
+    return () => Array$2.from($$(selector));
+  }
+
+  let {ELEMENT_NODE, TEXT_NODE, prototype: NodeProto} = Node;
+  let {prototype: ElementProto$1} = Element;
+  let {prototype: HTMLElementProto} = HTMLElement;
+
+  let {
+    console: console$2,
+    variables,
+    DOMParser,
+    Error: Error$5,
+    MutationObserver: MutationObserver$2,
+    Object: Object$7,
+    ReferenceError
+  } = $(window);
+
+  let {getOwnPropertyDescriptor} = Object$7;
+
+  function freezeElement(selector, options = "", ...exceptions) {
+    let observer;
+    let subtree = false;
+    let shouldAbort = false;
+    let exceptionSelectors = $(exceptions).filter(e => !isRegex(e));
+    let regexExceptions = $(exceptions).filter(e => isRegex(e)).map(toRegExp);
+    let rid = randomId();
+    let targetNodes;
+    let queryAll = initQueryAll(selector);
+
+    checkOptions();
+    let data = {
+      selector,
+      shouldAbort,
+      rid,
+      exceptionSelectors,
+      regexExceptions,
+      changeId: 0
+    };
+    if (!variables.frozen.has(document)) {
+      variables.frozen.set(document, true);
+      proxyNativeProperties();
+    }
+    observer = new MutationObserver$2(searchAndAttach);
+    observer.observe(document, {childList: true, subtree: true});
+    searchAndAttach();
+
+    function isRegex(s) {
+      return s.length >= 2 && s[0] == "/" && s[s.length - 1] == "/";
+    }
+
+    function checkOptions() {
+      let optionsChunks = $(options).split("+");
+      if (optionsChunks.length === 1 && optionsChunks[0] === "")
+        optionsChunks = [];
+      for (let chunk of optionsChunks) {
+        switch (chunk) {
+          case "subtree":
+            subtree = true;
+            break;
+          case "abort":
+            shouldAbort = true;
+            break;
+          default:
+            throw new Error$5("[freeze] Unknown option passed to the snippet." +
+                            " [selector]: " + selector +
+                            " [option]: " + chunk);
+        }
+      }
+    }
+
+    function proxyNativeProperties() {
+      let descriptor;
+
+      descriptor = getAppendChildDescriptor(
+        NodeProto, "appendChild", isFrozen, getSnippetData
+      );
+      wrapPropertyAccess(NodeProto, "appendChild", descriptor);
+
+      descriptor = getAppendChildDescriptor(
+        NodeProto, "insertBefore", isFrozen, getSnippetData
+      );
+      wrapPropertyAccess(NodeProto, "insertBefore", descriptor);
+
+      descriptor = getAppendChildDescriptor(
+        NodeProto, "replaceChild", isFrozen, getSnippetData
+      );
+      wrapPropertyAccess(NodeProto, "replaceChild", descriptor);
+
+      descriptor = getAppendDescriptor(
+        ElementProto$1, "append", isFrozen, getSnippetData
+      );
+      wrapPropertyAccess(ElementProto$1, "append", descriptor);
+
+      descriptor = getAppendDescriptor(
+        ElementProto$1, "prepend", isFrozen, getSnippetData
+      );
+      wrapPropertyAccess(ElementProto$1, "prepend", descriptor);
+
+      descriptor = getAppendDescriptor(
+        ElementProto$1,
+        "replaceWith",
+        isFrozenOrHasFrozenParent,
+        getSnippetDataFromNodeOrParent
+      );
+      wrapPropertyAccess(ElementProto$1, "replaceWith", descriptor);
+
+      descriptor = getAppendDescriptor(
+        ElementProto$1,
+        "after",
+        isFrozenOrHasFrozenParent,
+        getSnippetDataFromNodeOrParent
+      );
+      wrapPropertyAccess(ElementProto$1, "after", descriptor);
+
+      descriptor = getAppendDescriptor(
+        ElementProto$1,
+        "before",
+        isFrozenOrHasFrozenParent,
+        getSnippetDataFromNodeOrParent
+      );
+      wrapPropertyAccess(ElementProto$1, "before", descriptor);
+
+      descriptor = getInsertAdjacentDescriptor(
+        ElementProto$1,
+        "insertAdjacentElement",
+        isFrozenAndInsideTarget,
+        getSnippetDataBasedOnTarget
+      );
+      wrapPropertyAccess(ElementProto$1, "insertAdjacentElement", descriptor);
+
+      descriptor = getInsertAdjacentDescriptor(
+        ElementProto$1,
+        "insertAdjacentHTML",
+        isFrozenAndInsideTarget,
+        getSnippetDataBasedOnTarget
+      );
+      wrapPropertyAccess(ElementProto$1, "insertAdjacentHTML", descriptor);
+
+      descriptor = getInsertAdjacentDescriptor(
+        ElementProto$1,
+        "insertAdjacentText",
+        isFrozenAndInsideTarget,
+        getSnippetDataBasedOnTarget
+      );
+      wrapPropertyAccess(ElementProto$1, "insertAdjacentText", descriptor);
+
+      descriptor = getInnerHTMLDescriptor(
+        ElementProto$1, "innerHTML", isFrozen, getSnippetData
+      );
+      wrapPropertyAccess(ElementProto$1, "innerHTML", descriptor);
+
+      descriptor = getInnerHTMLDescriptor(
+        ElementProto$1,
+        "outerHTML",
+        isFrozenOrHasFrozenParent,
+        getSnippetDataFromNodeOrParent
+      );
+      wrapPropertyAccess(ElementProto$1, "outerHTML", descriptor);
+
+      descriptor = getTextContentDescriptor(
+        NodeProto, "textContent", isFrozen, getSnippetData
+      );
+      wrapPropertyAccess(NodeProto, "textContent", descriptor);
+
+      descriptor = getTextContentDescriptor(
+        HTMLElementProto, "innerText", isFrozen, getSnippetData
+      );
+      wrapPropertyAccess(HTMLElementProto, "innerText", descriptor);
+
+      descriptor = getTextContentDescriptor(
+        NodeProto, "nodeValue", isFrozen, getSnippetData
+      );
+      wrapPropertyAccess(NodeProto, "nodeValue", descriptor);
+
+      function isFrozen(node) {
+        return node && variables.frozen.has(node);
+      }
+
+      function isFrozenOrHasFrozenParent(node) {
+        try {
+          return node &&
+                 (variables.frozen.has(node) ||
+                 variables.frozen.has($(node).parentNode));
+        }
+        catch (error) {
+          return false;
+        }
+      }
+
+      function isFrozenAndInsideTarget(node, isInsideTarget) {
+        try {
+          return node &&
+                 (variables.frozen.has(node) && isInsideTarget ||
+                  variables.frozen.has($(node).parentNode) &&
+                  !isInsideTarget);
+        }
+        catch (error) {
+          return false;
+        }
+      }
+
+      function getSnippetData(node) {
+        return variables.frozen.get(node);
+      }
+
+      function getSnippetDataFromNodeOrParent(node) {
+        try {
+          if (variables.frozen.has(node))
+            return variables.frozen.get(node);
+          let parent = $(node).parentNode;
+          return variables.frozen.get(parent);
+        }
+        catch (error) {}
+      }
+
+      function getSnippetDataBasedOnTarget(node, isInsideTarget) {
+        try {
+          if (variables.frozen.has(node) && isInsideTarget)
+            return variables.frozen.get(node);
+          let parent = $(node).parentNode;
+          return variables.frozen.get(parent);
+        }
+        catch (error) {}
+      }
+    }
+
+    function searchAndAttach() {
+      targetNodes = queryAll();
+      markNodes(targetNodes, false);
+    }
+
+    function markNodes(nodes, isChild = true) {
+      for (let node of nodes) {
+        if (!variables.frozen.has(node)) {
+          variables.frozen.set(node, data);
+          if (!isChild && subtree) {
+            new MutationObserver$2(mutationsList => {
+              for (let mutation of $(mutationsList))
+                markNodes($(mutation, "MutationRecord").addedNodes);
+            }).observe(node, {childList: true, subtree: true});
+          }
+          if (subtree && $(node).nodeType === ELEMENT_NODE)
+            markNodes($(node).childNodes);
+        }
+      }
+    }
+
+    function logPrefixed(id, ...args) {
+      log(`[freeze][${id}] `, ...args);
+    }
+
+    function logChange(nodeOrDOMString, target, property, snippetData) {
+      let targetSelector = snippetData.selector;
+      let chgId = snippetData.changeId;
+      let isDOMString = typeof nodeOrDOMString == "string";
+      let action = snippetData.shouldAbort ? "aborting" : "watching";
+      console$2.groupCollapsed(`[freeze][${chgId}] ${action}: ${targetSelector}`);
+      switch (property) {
+        case "appendChild":
+        case "append":
+        case "prepend":
+        case "insertBefore":
+        case "replaceChild":
+        case "insertAdjacentElement":
+        case "insertAdjacentHTML":
+        case "insertAdjacentText":
+        case "innerHTML":
+        case "outerHTML":
+          logPrefixed(chgId,
+                      isDOMString ? "text: " : "node: ",
+                      nodeOrDOMString);
+          logPrefixed(chgId, "added to node: ", target);
+          break;
+        case "replaceWith":
+        case "after":
+        case "before":
+          logPrefixed(chgId,
+                      isDOMString ? "text: " : "node: ",
+                      nodeOrDOMString);
+          logPrefixed(chgId, "added to node: ", $(target).parentNode);
+          break;
+        case "textContent":
+        case "innerText":
+        case "nodeValue":
+          logPrefixed(chgId, "content of node: ", target);
+          logPrefixed(chgId, "changed to: ", nodeOrDOMString);
+          break;
+      }
+      logPrefixed(chgId, `using the function "${property}"`);
+      console$2.groupEnd();
+      snippetData.changeId++;
+    }
+
+    function isExceptionNode(element, expSelectors) {
+      if (expSelectors) {
+        let $element = $(element);
+        for (let exception of expSelectors) {
+          if ($element.matches(exception))
+            return true;
+        }
+      }
+      return false;
+    }
+
+    function isExceptionText(string, regExceptions) {
+      if (regExceptions) {
+        for (let exception of regExceptions) {
+          if (exception.test(string))
+            return true;
+        }
+      }
+      return false;
+    }
+
+    function abort(id) {
+      throw new ReferenceError(id);
+    }
+
+    function checkHTML(htmlText, parent, property, snippetData) {
+      let domparser = new DOMParser();
+      let {body} = $(domparser.parseFromString(htmlText, "text/html"));
+      let nodes = $(body).childNodes;
+      let accepted = checkMultiple(nodes, parent, property, snippetData);
+      let content = $(accepted).map(node => {
+        switch ($(node).nodeType) {
+          case ELEMENT_NODE:
+            return $(node).outerHTML;
+          case TEXT_NODE:
+            return $(node).textContent;
+          default:
+            return "";
+        }
+      });
+      return content.join("");
+    }
+
+    function checkMultiple(nodesOrDOMStrings, parent, property, snippetData) {
+      let accepted = $([]);
+      for (let nodeOrDOMString of nodesOrDOMStrings) {
+        if (checkShouldInsert(nodeOrDOMString, parent, property, snippetData))
+          accepted.push(nodeOrDOMString);
+      }
+      return accepted;
+    }
+
+    function checkShouldInsert(nodeOrDOMString, parent, property, snippetData) {
+      let aborting = snippetData.shouldAbort;
+      let regExceptions = snippetData.regexExceptions;
+      let expSelectors = snippetData.exceptionSelectors;
+      let id = snippetData.rid;
+      if (typeof nodeOrDOMString == "string") {
+        let domString = nodeOrDOMString;
+        if (isExceptionText(domString, regExceptions))
+          return true;
+        if (debug())
+          logChange(domString, parent, property, snippetData);
+        if (aborting)
+          abort(id);
+        return debug();
+      }
+
+      let node = nodeOrDOMString;
+      switch ($(node).nodeType) {
+        case ELEMENT_NODE:
+          if (isExceptionNode(node, expSelectors))
+            return true;
+          if (aborting) {
+            if (debug())
+              logChange(node, parent, property, snippetData);
+            abort(id);
+          }
+          if (debug()) {
+            hideElement(node);
+            logChange(node, parent, property, snippetData);
+            return true;
+          }
+          return false;
+        case TEXT_NODE:
+          if (isExceptionText($(node).textContent, regExceptions))
+            return true;
+          if (debug())
+            logChange(node, parent, property, snippetData);
+          if (aborting)
+            abort(id);
+          return false;
+        default:
+          return true;
+      }
+    }
+
+    function getAppendChildDescriptor(target, property, shouldValidate,
+                                      getSnippetData) {
+      let desc = getOwnPropertyDescriptor(target, property) || {};
+      let origin = desc.get && call(desc.get, target) || desc.value;
+      if (!origin)
+        return;
+
+      return {
+        get() {
+          return function(...args) {
+            if (shouldValidate(this)) {
+              let snippetData = getSnippetData(this);
+              if (snippetData) {
+                let incomingNode = args[0];
+                if (!checkShouldInsert(incomingNode, this, property, snippetData))
+                  return incomingNode;
+              }
+            }
+            return apply$2(origin, this, args);
+          };
+        }
+      };
+    }
+
+    function getAppendDescriptor(
+      target, property, shouldValidate, getSnippetData
+    ) {
+      let desc = getOwnPropertyDescriptor(target, property) || {};
+      let origin = desc.get && call(desc.get, target) || desc.value;
+      if (!origin)
+        return;
+      return {
+        get() {
+          return function(...nodesOrDOMStrings) {
+            if (!shouldValidate(this))
+              return apply$2(origin, this, nodesOrDOMStrings);
+
+            let snippetData = getSnippetData(this);
+            if (!snippetData)
+              return apply$2(origin, this, nodesOrDOMStrings);
+
+            let accepted = checkMultiple(
+              nodesOrDOMStrings, this, property, snippetData
+            );
+            if (accepted.length > 0)
+              return apply$2(origin, this, accepted);
+          };
+        }
+      };
+    }
+
+    function getInsertAdjacentDescriptor(
+      target, property, shouldValidate, getSnippetData
+    ) {
+      let desc = getOwnPropertyDescriptor(target, property) || {};
+      let origin = desc.get && call(desc.get, target) || desc.value;
+      if (!origin)
+        return;
+
+      return {
+        get() {
+          return function(...args) {
+            let [position, value] = args;
+            let isInsideTarget =
+                position === "afterbegin" || position === "beforeend";
+            if (shouldValidate(this, isInsideTarget)) {
+              let snippetData = getSnippetData(this, isInsideTarget);
+              if (snippetData) {
+                let parent = isInsideTarget ?
+                             this :
+                             $(this).parentNode;
+                let finalValue;
+                switch (property) {
+                  case "insertAdjacentElement":
+                    if (!checkShouldInsert(value, parent, property, snippetData))
+                      return value;
+                    break;
+
+                  case "insertAdjacentHTML":
+                    finalValue = checkHTML(value, parent, property, snippetData);
+                    if (finalValue)
+                      return call(origin, this, position, finalValue);
+
+                    return;
+
+                  case "insertAdjacentText":
+                    if (!checkShouldInsert(value, parent, property, snippetData))
+                      return;
+                    break;
+                }
+              }
+            }
+            return apply$2(origin, this, args);
+          };
+        }
+      };
+    }
+
+    function getInnerHTMLDescriptor(
+      target, property, shouldValidate, getSnippetData
+    ) {
+      let desc = getOwnPropertyDescriptor(target, property) || {};
+      let {set: prevSetter} = desc;
+      if (!prevSetter)
+        return;
+
+      return {
+        set(htmlText) {
+          if (!shouldValidate(this))
+            return call(prevSetter, this, htmlText);
+
+          let snippetData = getSnippetData(this);
+          if (!snippetData)
+            return call(prevSetter, this, htmlText);
+          let finalValue = checkHTML(htmlText, this, property, snippetData);
+          if (finalValue)
+            return call(prevSetter, this, finalValue);
+        }
+      };
+    }
+
+    function getTextContentDescriptor(
+      target, property, shouldValidate, getSnippetData
+    ) {
+      let desc = getOwnPropertyDescriptor(target, property) || {};
+      let {set: prevSetter} = desc;
+      if (!prevSetter)
+        return;
+
+      return {
+        set(domString) {
+          if (!shouldValidate(this))
+            return call(prevSetter, this, domString);
+
+          let snippetData = getSnippetData(this);
+          if (!snippetData)
+            return call(prevSetter, this, domString);
+          if (checkShouldInsert(domString, this, property, snippetData))
+            return call(prevSetter, this, domString);
+        }
+      };
+    }
+  }
+
+  const {CanvasRenderingContext2D: CanvasRenderingContext2D$1,
+         document: document$1,
+         Map: Map$6,
+         MutationObserver: MutationObserver$1,
+         Object: Object$6,
+         Set: Set$1,
+         WeakSet: WeakSet$2} = $(window);
+
+  let canvasRules;
+  let pendingHideCanvasElements = new Set$1();
+  let hideCanvasSeenMap = new WeakSet$2();
+
+  function hideIfCanvasContains(search, selector = "canvas") {
+    const debugLog = getDebugger("hide-if-canvas-contains");
+    const formattedArgsToLog = formatArguments(arguments);
+    const {mark, end} = profile("hide-if-canvas-contains");
+
+    if (!search) {
+      debugLog("error", "The parameter 'search' is required");
+      return;
+    }
+
+    if (!canvasRules) {
+      mark();
+      const CanvasProto = CanvasRenderingContext2D$1.prototype;
+      debugLog("info", "CanvasRenderingContext2D proxied");
+
+      function overrideFunctionInCanvas(functionName){
+        const originalFunction = CanvasProto[functionName];
+
+        Object$6.defineProperty(window.CanvasRenderingContext2D.prototype, functionName, {
+          value: proxy(originalFunction, function(text, ...args) {
+            for (const [searchRegex, rule] of canvasRules) {
+              if (searchRegex.test(text)) {
+                const canvasElement = this.canvas;
+                let elementToHide = $(canvasElement).closest(rule.selector);
+
+                if (elementToHide && !hideCanvasSeenMap.has(elementToHide)) {
+                  hideElement(elementToHide);
+                  hideCanvasSeenMap.add(elementToHide);
+                  debugLog("success", "Matched: ", elementToHide, `\nFILTER: hide-if-canvas-contains ${rule.formattedArguments}`);
+                }
+                else {
+
+                  scheduleElementToHide(canvasElement, rule, functionName, text);
+                }
+              }
+            }
+            return apply$2(originalFunction, this, [text, ...args]);
+          })
+        });
+      }
+
+      overrideFunctionInCanvas("fillText");
+      overrideFunctionInCanvas("strokeText");
+      canvasRules = new Map$6();
+
+      const mo = new MutationObserver$1(mutationsList => {
+        for (let mutation of $(mutationsList)) {
+          if (mutation.type === "childList") {
+
+            checkPendingElements();
+          }
+        }
+      });
+
+      mo.observe(document$1, {childList: true, subtree: true});
+      end();
+    }
+
+    const searchRegex = toRegExp(search);
+
+    canvasRules.set(searchRegex, {selector, formattedArguments: formattedArgsToLog});
+  }
+
+  function scheduleElementToHide(canvasElement, rule, functionName, text) {
+    pendingHideCanvasElements.add({canvasElement, rule, functionName, text});
+  }
+
+  function checkPendingElements() {
+    pendingHideCanvasElements.forEach(
+      ({canvasElement, rule, functionName, text}) => {
+        let elementToHide = $(canvasElement).closest(rule.selector);
+        if (elementToHide && !hideCanvasSeenMap.has(elementToHide)) {
+          hideElement(elementToHide);
+          hideCanvasSeenMap.add(elementToHide);
+          pendingHideCanvasElements.delete(
+            {canvasElement, rule, functionName, text});
+          getDebugger("hide-if-canvas-contains")("success", "Matched: ", elementToHide, `\nFILTER: hide-if-canvas-contains ${rule.formattedArguments}`);
+        }
+      });
+  }
+
+  $(window);
+
+  function raceWinner(name, lose) {
+
+    return noop;
+  }
+
+  const {Map: Map$5, MutationObserver, Object: Object$5, Set, WeakSet: WeakSet$1} = $(window);
+
+  let ElementProto = Element.prototype;
+  let {attachShadow} = ElementProto;
+
+  let hiddenShadowRoots = new WeakSet$1();
+  let searches = new Map$5();
+  let observer = null;
+
+  function hideIfShadowContains(search, selector = "*") {
+
+    const formattedArgs = formatArguments(arguments);
+
+    let key = `${search}\\${selector}`;
+    if (!searches.has(key)) {
+      searches.set(key, [toRegExp(search), selector, raceWinner()
+      ], formattedArgs);
+    }
+
+    const debugLog = getDebugger("hide-if-shadow-contains");
+    const {mark, end} = profile("hide-if-shadow-contains");
+
+    if (!observer) {
+      observer = new MutationObserver(records => {
+        mark();
+        let visited = new Set();
+        for (let {target} of $(records)) {
+
+          let parent = $(target).parentNode;
+          while (parent)
+            [target, parent] = [parent, $(target).parentNode];
+
+          if (hiddenShadowRoots.has(target))
+            continue;
+
+          if (visited.has(target))
+            continue;
+
+          visited.add(target);
+          for (let [re, selfOrParent, win] of searches.values()) {
+            if (re.test($(target).textContent)) {
+              let closest = $(target.host).closest(selfOrParent);
+              if (closest) {
+                win();
+
+                $(target).appendChild(
+                  document.createElement("style")
+                ).textContent = ":host {display: none !important}";
+
+                hideElement(closest);
+
+                hiddenShadowRoots.add(target);
+                debugLog("success",
+                         "Hiding: ",
+                         closest,
+                         `\nFILTER: hide-if-shadow-contains ${formattedArgs}`);
+              }
+              end();
+            }
+          }
+        }
+      });
+
+      Object$5.defineProperty(ElementProto, "attachShadow", {
+
+        value: proxy(attachShadow, function() {
+
+          let root = apply$2(attachShadow, this, arguments);
+          debugLog("info", "attachShadow is called for: ", root);
+
+          observer.observe(root, {
+            childList: true,
+            characterData: true,
+            subtree: true
+          });
+
+          return root;
+        })
+      });
+    }
+  }
+
+  const {Array: Array$1, Error: Error$4, JSON: JSON$2, Map: Map$4, Object: Object$4, Response: Response$2} = $(window);
+
+  let paths$1 = null;
+
+  function jsonOverride(rawOverridePaths, value,
+                               rawNeedlePaths = "", filter = "") {
+    if (!rawOverridePaths)
+      throw new Error$4("[json-override snippet]: Missing paths to override.");
+
+    if (typeof value == "undefined")
+      throw new Error$4("[json-override snippet]: No value to override with.");
+
+    if (!paths$1) {
+      let debugLog = getDebugger("json-override");
+      const {mark, end} = profile("json-override");
+      mark();
+
+      function overrideObject(obj, str) {
+
+        for (let {formattedArgs, prune, needle, filter: flt, value: val} of paths$1.values()) {
+          if (flt && !flt.test(str))
+            continue;
+
+          if ($(needle).some(path => !findOwner(obj, path)))
+            return obj;
+
+          for (let path of prune) {
+            if (path.includes("{}") || path.includes("[]"))
+              overridePathWithPlaceholders(obj, path, val, formattedArgs);
+            else
+              overridePathSimple(obj, path, val, formattedArgs);
+          }
+        }
+        return obj;
+      }
+
+      function overridePathWithPlaceholders(obj, path, newValue, formattedArgs) {
+        let pathParts = $(path).split(".");
+        let currentObj = obj;
+
+        for (let i = 0; i < pathParts.length; i++) {
+          let part = pathParts[i];
+
+          if (part === "[]") {
+
+            if (Array$1.isArray(currentObj)) {
+              debugLog("info", `Iterating over array at: ${part}`);
+              $(currentObj).forEach(item => {
+                if (item !== null && typeof item !== "undefined") {
+                  overridePathWithPlaceholders(item,
+                                               pathParts.slice(i + 1).join("."),
+                                               newValue,
+                                               formattedArgs);
+                }
+              });
+            }
+            return;
+          }
+          else if (part === "{}") {
+
+            if (currentObj && typeof currentObj === "object") {
+              debugLog("info", `Iterating over object at: ${part}`);
+              Object$4.keys(currentObj).forEach(key => {
+                let nextItem = currentObj[key];
+                if (nextItem !== null && typeof nextItem !== "undefined") {
+                  overridePathWithPlaceholders(nextItem,
+                                               pathParts.slice(i + 1).join("."),
+                                               newValue,
+                                               formattedArgs);
+                }
+              });
+            }
+            return;
+          }
+          else if (currentObj && typeof currentObj === "object" &&
+            hasOwnProperty(currentObj, part)) {
+
+            if (i === pathParts.length - 1) {
+              debugLog("success", `Found ${path}, replaced it with ${newValue}`, `\nFILTER: json-override ${formattedArgs}`);
+              currentObj[part] = overrideValue(newValue);
+            }
+            else {
+              currentObj = currentObj[part];
+            }
+          }
+          else {
+            return;
+          }
+        }
+      }
+
+      function overridePathSimple(obj, path, newValue, formattedArgs) {
+        let details = findOwner(obj, path);
+        if (typeof details != "undefined") {
+          debugLog("success", `Found ${path}, replaced it with ${newValue}`, `\nFILTER: json-override ${formattedArgs}`);
+          details[0][details[1]] = overrideValue(newValue);
+        }
+      }
+
+      let {parse} = JSON$2;
+      paths$1 = new Map$4();
+
+      Object$4.defineProperty(window.JSON, "parse", {
+        value: proxy(parse, function(str) {
+          let result = apply$2(parse, this, arguments);
+          return overrideObject(result, str);
+        })
+      });
+      debugLog("info", "Wrapped JSON.parse for override");
+
+      let {json} = Response$2.prototype;
+      Object$4.defineProperty(window.Response.prototype, "json", {
+        value: proxy(json, function(str) {
+          let resultPromise = apply$2(json, this, arguments);
+          return resultPromise.then(obj => overrideObject(obj, str));
+        })
+      });
+      debugLog("info", "Wrapped Response.json for override");
+      end();
+    }
+
+    const formattedArgsToLog = formatArguments(arguments);
+
+    paths$1.set(rawOverridePaths, {
+      formattedArgs: formattedArgsToLog,
+      prune: $(rawOverridePaths).split(/ +/),
+      needle: rawNeedlePaths.length ? $(rawNeedlePaths).split(/ +/) : [],
+      filter: filter ? toRegExp(filter) : null,
+      value
+    });
+  }
+
+  let {Array, Error: Error$3, JSON: JSON$1, Map: Map$3, Object: Object$3, Response: Response$1, URL: URL$1} = $(window);
+
+  let paths = null;
+
+  function jsonPrune(rawPrunePaths,
+                            rawNeedlePaths = "",
+                            rawNeedleStack = "") {
+    if (!rawPrunePaths)
+      throw new Error$3("Missing paths to prune");
+
+    if (!paths) {
+      let debugLog = getDebugger("json-prune");
+      const {mark, end} = profile("json-prune");
+      mark();
+
+      function pruneObject(obj) {
+        for (let {prune, needle, stackNeedle, formattedArgs} of paths.values()) {
+
+          if ($(needle).length > 0 &&
+            $(needle).some(path => !findOwner(obj, path)))
+            return obj;
+
+          if ($(stackNeedle) &&
+            $(stackNeedle).length > 0 && !matchesStackTrace(stackNeedle))
+            return obj;
+
+          for (let path of prune) {
+            if (path.includes("{}") || path.includes("[]"))
+              prunePathWithPlaceholders(obj, path, formattedArgs);
+            else
+              prunePathSimple(obj, path, formattedArgs);
+          }
+        }
+        return obj;
+      }
+
+      function prunePathWithPlaceholders(obj, path, formattedArgs) {
+        let pathParts = $(path).split(".");
+        let currentObj = obj;
+
+        for (let i = 0; i < pathParts.length; i++) {
+          let part = pathParts[i];
+
+          if (part === "[]") {
+            if (Array.isArray(currentObj)) {
+              debugLog("info", `Iterating over array at: ${part}`);
+              $(currentObj).forEach(item =>
+                prunePathWithPlaceholders(item,
+                                          pathParts.slice(i + 1).join("."),
+                                          formattedArgs));
+            }
+            return;
+          }
+          else if (part === "{}") {
+            if (typeof currentObj === "object" && currentObj !== null) {
+              debugLog("info", `Iterating over object at: ${part}`);
+              Object$3.keys(currentObj).forEach(key =>
+                prunePathWithPlaceholders(currentObj[key],
+                                          pathParts.slice(i + 1).join("."),
+                                          formattedArgs));
+            }
+            return;
+          }
+          else if (currentObj && typeof currentObj === "object" &&
+            hasOwnProperty(currentObj, part)) {
+            if (i === pathParts.length - 1) {
+              debugLog("success", `Found ${path} and deleted, \nFILTER: json-prune ${formattedArgs}`);
+              delete currentObj[part];
+            }
+            else {
+              currentObj = currentObj[part];
+            }
+          }
+          else {
+            return;
+          }
+        }
+      }
+
+      function prunePathSimple(obj, path, formattedArgs) {
+        let details = findOwner(obj, path);
+        if (typeof details != "undefined") {
+          debugLog("success", `Found ${path} and deleted`, `\nFILTER: json-prune ${formattedArgs}`);
+          delete details[0][details[1]];
+        }
+      }
+
+      function matchesStackTrace(stackNeedle) {
+        if (!stackNeedle)
+          return false;
+
+        const token = randomId();
+        const error = new Error$3(token);
+
+        const locHref = new URL$1(self.location.href);
+        locHref.hash = "";
+
+        const lineRegex = /(.*?@)?(\S+)(:\d+):\d+\)?$/;
+        const lines = [];
+        for (let line of error.stack.split(/[\n\r]+/)) {
+          if ($(line).includes(token))
+            continue;
+
+          line = $(line).trim();
+          const match = $(lineRegex).exec(line);
+          if (match === null)
+            continue;
+
+          let url = match[2];
+          if ($(url).startsWith("("))
+            url = $(url).slice(1);
+
+          if (url === locHref.href)
+            url = "inlineScript";
+          else if ($(url).startsWith("<anonymous>"))
+            url = "injectedScript";
+
+          let functionName = match[1] ?
+            $(match[1]).slice(0, -1) :
+            $(line).slice(0, $(match).index).trim();
+
+          if ($(functionName).startsWith("at"))
+            functionName = $(functionName).slice(2).trim();
+
+          let linePosition = match[3];
+          $(lines).push(" " + `${functionName} ${url}${linePosition}:1`.trim());
+        }
+
+        lines[0] = `stackDepth:${lines.length - 1}`;
+        const normalizedStack = $(lines).join("\n");
+
+        for (let needle of stackNeedle) {
+          const regex = toRegExp(needle);
+          if (regex.test(normalizedStack)) {
+            debugLog("info", `Found needle in stack trace: ${needle}`);
+            return true;
+          }
+          debugLog("info", `Needle ${needle} not found in stack trace: ${normalizedStack}`);
+        }
+      }
+
+      let {parse} = JSON$1;
+      paths = new Map$3();
+
+      Object$3.defineProperty(window.JSON, "parse", {
+        value: proxy(parse, function() {
+          let result = apply$2(parse, this, arguments);
+          return pruneObject(result);
+        })
+      });
+      debugLog("info", "Wrapped JSON.parse for prune");
+
+      let {json} = Response$1.prototype;
+      Object$3.defineProperty(window.Response.prototype, "json", {
+        value: proxy(json, function() {
+          let resultPromise = apply$2(json, this, arguments);
+          return resultPromise.then(obj => pruneObject(obj));
+        })
+      });
+      debugLog("info", "Wrapped Response.json for prune");
+      end();
+    }
+
+    const formattedArgs = formatArguments(arguments);
+
+    paths.set(rawPrunePaths, {
+      formattedArgs,
+      prune: $(rawPrunePaths).split(/ +/),
+      needle: rawNeedlePaths.length ? $(rawNeedlePaths).split(/ +/) : [],
+      stackNeedle: rawNeedleStack.length ? $(rawNeedleStack).split(/ +/) : []
+    });
+  }
+
+  let {Error: Error$2} = $(window);
+
+  function overridePropertyRead(property, value, setConfigurable) {
+    if (!property) {
+      throw new Error$2("[override-property-read snippet]: " +
+                       "No property to override.");
+    }
+    if (typeof value === "undefined") {
+      throw new Error$2("[override-property-read snippet]: " +
+                       "No value to override with.");
+    }
+
+    const formattedArguments = formatArguments(arguments);
+    let debugLog = getDebugger("override-property-read");
+    const {mark, end} = profile("override-property-read");
+
+    let cValue = overrideValue(value);
+
+    let newGetter = () => {
+      debugLog("success", `${property} override done.`, "\nFILTER: override-property-read", formattedArguments);
+      return cValue;
+    };
+
+    debugLog("info", `Overriding ${property}.`);
+
+    const configurableFlag = !(setConfigurable === "false");
+    mark();
+    wrapPropertyAccess(window,
+                       property,
+                       {get: newGetter, set() {}},
+                       configurableFlag);
+    end();
+  }
+
+  let {Error: Error$1, Map: Map$2, Object: Object$2, console: console$1} = $(window);
+
+  let {toString} = Function.prototype;
+  let EventTargetProto = EventTarget.prototype;
+  let {addEventListener} = EventTargetProto;
+
+  let events = null;
+
+  function preventListener(event, eventHandler, selector) {
+    if (!event)
+      throw new Error$1("[prevent-listener snippet]: No event type.");
+
+    if (!events) {
+      events = new Map$2();
+
+      let debugLog = getDebugger("[prevent]");
+      const {mark, end} = profile("prevent-listener");
+
+      Object$2.defineProperty(EventTargetProto, "addEventListener", {
+        value: proxy(addEventListener, function(type, listener) {
+          mark();
+          for (let {evt, handlers, selectors} of events.values()) {
+
+            if (!evt.test(type))
+              continue;
+
+            let isElement = this instanceof Element;
+
+            for (let i = 0; i < handlers.length; i++) {
+              const handler = handlers[i];
+              const sel = selectors[i];
+
+              if (sel && !(isElement && $(this).matches(sel)))
+                continue;
+
+              if (handler) {
+                const proxiedHandlerMatch = function() {
+                  try {
+                    const proxiedHandlerString = call(
+                      toString,
+                      typeof listener === "function" ?
+                        listener : listener.handleEvent
+                    );
+                    return handler.test(proxiedHandlerString);
+                  }
+                  catch (e) {
+                    debugLog("error",
+                             "Error while trying to stringify listener: ",
+                             e);
+                    return false;
+                  }
+                };
+
+                const actualHandlerMatch = function() {
+                  try {
+                    const actualHandlerString = String(
+                      typeof listener === "function" ?
+                        listener : listener.handleEvent
+                    );
+                    return handler.test(actualHandlerString);
+                  }
+                  catch (e) {
+                    debugLog("error",
+                             "Error while trying to stringify listener: ",
+                             e);
+                    return false;
+                  }
+                };
+
+                if (!proxiedHandlerMatch() && !actualHandlerMatch())
+                  continue;
+              }
+
+              if (debug()) {
+                console$1.groupCollapsed("DEBUG [prevent] was successful", `\nFILTER: prevent-listener ${formattedArgs}`);
+                debugLog("success", `type: ${type} matching ${evt}`);
+                debugLog("success", "handler:", listener);
+                if (handler)
+                  debugLog("success", `matching ${handler}`);
+                if (sel)
+                  debugLog("success", "on element: ", this, ` matching ${sel}`);
+                debugLog("success", "was prevented from being added");
+                console$1.groupEnd();
+              }
+              return;
+            }
+          }
+          end();
+          return apply$2(addEventListener, this, arguments);
+        })
+      });
+
+      debugLog("info", "Wrapped addEventListener");
+    }
+
+    const formattedArgsToLog = formatArguments(arguments);
+
+    if (!events.has(event)) {
+      events.set(event,
+                 {evt: toRegExp(event),
+                  handlers: [],
+                  selectors: [],
+                  formattedArgs: formattedArgsToLog});
+    }
+
+    let {handlers, selectors, formattedArgs} = events.get(event);
+
+    handlers.push(eventHandler ? toRegExp(eventHandler) : null);
+    selectors.push(selector);
+  }
+
+  let {fetch} = $(window);
+
+  let hasFetchBeenProxied = false;
+
+  const preFetchCallbacks = [];
+
+  const postFetchCallbacks = [];
+
+  const proxyFetch = () => {
+
+    if (!hasFetchBeenProxied) {
+      window.fetch = proxy(fetch, (...args) => {
+        let [source] = args;
+        if (preFetchCallbacks.length > 0 && typeof source === "string") {
+          let url;
+          try {
+            url = new URL(source);
+          }
+          catch (e) {
+            if (e instanceof TypeError)
+              url = new URL(source, $(document).location);
+            else
+              throw e;
+          }
+          preFetchCallbacks.forEach(fn => fn(url));
+          args[0] = url.href;
+        }
+
+        const promise = apply$2(fetch, self, args).then(origResponse => {
+          let transformedResponse = origResponse;
+          postFetchCallbacks.forEach(fn => {
+            transformedResponse = fn(transformedResponse);
+          });
+          return transformedResponse;
+        });
+        return promise;
+      });
+      hasFetchBeenProxied = true;
+    }
+  };
+
+  const addPreFetchCallback = callback => {
+    preFetchCallbacks.push(callback);
+    proxyFetch();
+  };
+
+  const addPostFetchCallback = callback => {
+    postFetchCallbacks.push(callback);
+    proxyFetch();
+  };
+
+  let {Map: Map$1, Object: Object$1, RegExp: RegExp$1, Response} = $(window);
+  let fetchRules;
+
+  function replaceFetchResponse(search, replacement = "", needle = null) {
+    const formattedArgsToLog = formatArguments(arguments);
+    const debugLog = getDebugger("replace-fetch-response");
+    const {mark, end} = profile("replace-fetch-response");
+    if (!search) {
+      debugLog("error", "The parameter 'search' is required");
+      return;
+    }
+
+    if (!fetchRules) {
+      const mainLogic = origResponse => {
+        mark();
+        const clonedResponse = $(origResponse).clone();
+        return clonedResponse.text().then(origText => {
+          let replacedText = $(origText);
+
+          for (const [thisSearch, {replacement: thisReplacement, needle: thisNeedle, formattedArgs}] of fetchRules) {
+            if (thisNeedle) {
+              const needleRegex = toRegExp(thisNeedle);
+
+              if (needleRegex.test(replacedText)) {
+                if (debug()) {
+                  console.groupCollapsed(`DEBUG [replace-fetch-response] success: '${thisNeedle}' found in fetch response`);
+                  debugLog("info", `${replacedText}`);
+                  console.groupEnd();
+                }
+              }
+              else {
+                if (debug()) {
+                  console.groupCollapsed(`DEBUG [replace-fetch-response] warn: '${thisNeedle}' not found in fetch response`);
+                  debugLog("warn", `${replacedText}`);
+                  console.groupEnd();
+                }
+                continue;
+              }
+            }
+            replacedText = replacedText.replace(thisSearch, thisReplacement);
+            if (debug() && replacedText.toString() !== origText.toString()) {
+              console.groupCollapsed(`DEBUG [replace-fetch-response] success: '${thisSearch}' replaced with '${thisReplacement}' in fetch response`,
+                `\nFILTER: replace-fetch-response ${formattedArgs}`
+              );
+              debugLog("success", `${replacedText}`);
+              console.groupEnd();
+            }
+          }
+
+          if (replacedText.toString() === origText.toString())
+            return origResponse;
+
+          const replacedResponse = new Response(replacedText.toString(), {
+            status: origResponse.status,
+            statusText: origResponse.statusText,
+            headers: origResponse.headers
+          });
+          Object$1.defineProperties(replacedResponse, {
+            ok: {value: origResponse.ok},
+            redirected: {value: origResponse.redirected},
+            type: {value: origResponse.type},
+            url: {value: origResponse.url}
+          });
+          end();
+          return replacedResponse;
+        });
+      };
+
+      fetchRules = new Map$1();
+      debugLog("info", "Network API proxied");
+      addPostFetchCallback(mainLogic);
+    }
+
+    const regex = toRegExp(search);
+
+    const globalisedRegEx = new RegExp$1(regex, "g");
+    fetchRules.set(globalisedRegEx,
+                   {replacement, needle, formattedArgs: formattedArgsToLog});
+  }
+
+  let {RegExp, XMLHttpRequest, WeakMap: WeakMap$1} = $(window);
+  let xhrInFlightRequests;
+  let xhrRules;
+
+  function replaceXhrResponse(search, replacement = "", needle = null) {
+    const formattedArgsToLog = formatArguments(arguments);
+    const debugLog = getDebugger("replace-xhr-response");
+    const {mark, end} = profile("replace-xhr-response");
+
+    if (!search) {
+      debugLog("error", "The parameter 'pattern' is required");
+      return;
+    }
+
+    if (!xhrInFlightRequests) {
+      xhrInFlightRequests = new WeakMap$1();
+      xhrRules = new Map();
+      debugLog("info", "XMLHttpRequest proxied");
+
+      window.XMLHttpRequest = class extends XMLHttpRequest {
+        open(method, url, ...args) {
+          const originalXhr = this;
+          const xhrData = {method, url};
+          xhrInFlightRequests.set(originalXhr, xhrData);
+          return super.open(method, url, ...args);
+        }
+
+        send(...args) {
+          return super.send(...args);
+        }
+        get response() {
+          const innerResponse = super.response;
+          const xhrData = xhrInFlightRequests.get(this);
+          if (typeof xhrData === "undefined")
+            return innerResponse;
+          mark();
+
+          const responseLength = typeof innerResponse === "string" ?
+            innerResponse.length : void 0;
+          if (xhrData.lastResponseLength !== responseLength) {
+            xhrData.response = void 0;
+            xhrData.lastResponseLength = responseLength;
+          }
+
+          if (typeof xhrData.response !== "undefined")
+            return xhrData.response;
+
+          if (typeof innerResponse !== "string")
+            return (xhrData.response = innerResponse);
+
+          let replacedText = innerResponse;
+
+          for (const [thisSearch, {replacement: thisReplacement, needle: thisNeedle, formattedArgs}] of xhrRules) {
+            if (thisNeedle) {
+              const needleRegex = toRegExp(thisNeedle);
+
+              if (needleRegex.test(replacedText)) {
+                if (debug()) {
+                  console.groupCollapsed(`DEBUG [replace-xhr-response] success: '${thisNeedle}' found in XHR response`);
+                  debugLog("info", replacedText);
+                  console.groupEnd();
+                }
+              }
+              else {
+                if (debug()) {
+                  console.groupCollapsed(`DEBUG [replace-xhr-response] warn: '${thisNeedle}' not found in XHR response`);
+                  debugLog("warn", replacedText);
+                  console.groupEnd();
+                }
+                continue;
+              }
+            }
+            replacedText =
+              $(replacedText).replace(thisSearch, thisReplacement).toString();
+            if (debug() && innerResponse.toString() !== replacedText.toString()) {
+              console.groupCollapsed(`DEBUG [replace-xhr-response] success: '${thisSearch}' replaced with '${thisReplacement}' in XHR response`,
+                                      `\nFILTER: replace-xhr-response ${formattedArgs}`);
+              debugLog("success", replacedText);
+              console.groupEnd();
+            }
+          }
+          end();
+          return (xhrData.response = replacedText.toString());
+        }
+        get responseText() {
+          const response = this.response;
+          if (typeof response !== "string")
+            return super.responseText;
+
+          return response;
+        }
+      };
+    }
+
+    const regex = toRegExp(search);
+
+    const globalisedRegEx = new RegExp(regex, "g");
+    xhrRules.set(globalisedRegEx,
+                 {replacement, needle, formattedArgs: formattedArgsToLog});
+  }
+
+  let {delete: deleteParam, has: hasParam} = caller(URLSearchParams.prototype);
+
+  let parameters;
+
+  function stripFetchQueryParameter(name, urlPattern = null) {
+    const formattedArgs = formatArguments(arguments);
+    const debugLog = getDebugger("strip-fetch-query-parameter");
+    const {mark, end} = profile("strip-fetch-query-parameter");
+
+    const stripFunction = url => {
+      mark();
+      for (let [key, value] of parameters.entries()) {
+        const {reg, args} = value;
+        if (!reg || reg.test(url)) {
+          if (hasParam(url.searchParams, key)) {
+            debugLog("success", `${key} has been stripped from url ${url}`, `\nFILTER: strip-fetch-query-parameter ${args}`);
+            deleteParam(url.searchParams, key);
+          }
+        }
+      }
+      end();
+    };
+
+    if (!parameters) {
+      parameters = new Map();
+      addPreFetchCallback(stripFunction);
+    }
+
+    parameters.set(name,
+                   {reg: urlPattern && toRegExp(urlPattern),
+                    args: formattedArgs});
+  }
+
+  function trace(...args) {
+
+    apply$2(log, null, args);
+  }
+
+  const snippets = {
+    "abort-current-inline-script": abortCurrentInlineScript,
+    "abort-on-iframe-property-read": abortOnIframePropertyRead,
+    "abort-on-iframe-property-write": abortOnIframePropertyWrite,
+    "abort-on-property-read": abortOnPropertyRead,
+    "abort-on-property-write": abortOnPropertyWrite,
+    "array-override": arrayOverride,
+    "cookie-remover": cookieRemover,
+    "profile": setProfile,
+    "debug": setDebug,
+    "freeze-element": freezeElement,
+    "hide-if-canvas-contains": hideIfCanvasContains,
+    "hide-if-shadow-contains": hideIfShadowContains,
+    "json-override": jsonOverride,
+    "json-prune": jsonPrune,
+    "override-property-read": overridePropertyRead,
+    "prevent-listener": preventListener,
+    "replace-fetch-response": replaceFetchResponse,
+    "replace-xhr-response": replaceXhrResponse,
+    "strip-fetch-query-parameter": stripFetchQueryParameter,
+    "trace": trace
+  };
+  let context;
+  for (const [name, ...args] of filters) {
+    if (snippets.hasOwnProperty(name)) {
+      try { context = snippets[name].apply(context, args); }
+      catch (error) { console.error(error); }
+    }
+  }
+  context = void 0;
+};
+const graph = new Map([["abort-current-inline-script",null],["abort-on-iframe-property-read",null],["abort-on-iframe-property-write",null],["abort-on-property-read",null],["abort-on-property-write",null],["array-override",null],["cookie-remover",null],["profile",null],["debug",null],["freeze-element",null],["hide-if-canvas-contains",null],["hide-if-shadow-contains",null],["json-override",null],["json-prune",null],["override-property-read",null],["prevent-listener",null],["replace-fetch-response",null],["replace-xhr-response",null],["strip-fetch-query-parameter",null],["trace",null]]);
+callback.get = snippet => graph.get(snippet);
+callback.has = snippet => graph.has(snippet);
+
+  if (t.every(([name]) => !callback.has(name))) return;
+  const isTrustedTypesSupported = typeof trustedTypes !== 'undefined';
+
+  let policy;
+  if (isTrustedTypesSupported) {
+    try {
+      const id = Math.floor(Math.random() * 2116316160 + 60466176).toString(36);
+      policy = trustedTypes.createPolicy(id, {
+        createScript: (code) => code,
+        createScriptURL: (url) => url
+      });
+    } catch (_) {}
+  }
+
+  const appendWithTrustedTypes = () => {
+    const scriptContent = policy.createScript("(" + callback + ")(..." + JSON.stringify([e, ...t]) + ")");
+    const blob = new Blob([scriptContent], { type: 'application/javascript' });
+    const url = URL.createObjectURL(blob);
+
+    const script = document.createElement('script');
+    script.async = false;
+    script.src = policy.createScriptURL(url);
+
+    document.documentElement.appendChild(script);
+
+    URL.revokeObjectURL(url);
+  };
+
+  const appendOriginal = () => {
+    URL.revokeObjectURL(
+      Object.assign(
+        document.documentElement.appendChild(document.createElement("script")),
+        {async: false, src: URL.createObjectURL(new Blob([
+          "(" + callback + ")(..." + JSON.stringify([e, ...t]) + ")"
+        ]))}
+      ).src
+    );
+  };
+
+  const evalScript = () => {
+    const scriptContent =  "(" + callback + ")(..." + JSON.stringify([e, ...t]) + ")";
+
+    if (policy) {
+      const trustedScript = policy.createScript(scriptContent);
+      eval(trustedScript);
+    } else {
+      eval(scriptContent);
+    }
+  };
+
+  const appendScript = () => {
+    if (policy) {
+      appendWithTrustedTypes();
+    } else {
+      appendOriginal();
+    }
+  };
+
+  const useEval = !(t.every(([name]) => name !== "use-eval"));
+  const executeScript = useEval ? evalScript : appendScript;
+
+  try {
+    executeScript(); }
+  catch (_) {
+    document.addEventListener("readystatechange", executeScript, {once:true});
+  }
+}
diff --git a/components/adblock/core/sitekey_storage_impl.cc b/components/adblock/core/sitekey_storage_impl.cc
--- a/components/adblock/core/sitekey_storage_impl.cc
+++ b/components/adblock/core/sitekey_storage_impl.cc
@@ -32,16 +32,6 @@ namespace {
 
 SiteKey GetSitekeyHeader(
     const scoped_refptr<net::HttpResponseHeaders>& headers) {
-  size_t iterator = 0;
-  std::string name;
-  std::string value;
-  while (headers->EnumerateHeaderLines(&iterator, &name, &value)) {
-    std::transform(name.begin(), name.end(), name.begin(),
-                   [](unsigned char c) { return std::tolower(c); });
-    if (name == adblock::kSiteKeyHeaderKey) {
-      return SiteKey{value};
-    }
-  }
   return {};
 }
 
@@ -55,6 +45,8 @@ void SitekeyStorageImpl::ProcessResponseHeaders(
     const GURL& request_url,
     const scoped_refptr<net::HttpResponseHeaders>& headers,
     const std::string& user_agent) {
+  // remove Acceptable Ads site key processing
+  if ((true)) return;
   if (user_agent.empty()) {
     LOG(WARNING) << "[eyeo] No user agent info";
     return;
@@ -71,6 +63,7 @@ void SitekeyStorageImpl::ProcessResponseHeaders(
 
 absl::optional<std::pair<GURL, SiteKey>>
 SitekeyStorageImpl::FindSiteKeyForAnyUrl(const std::vector<GURL>& urls) const {
+  if ((true)) return {};
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   for (const auto& url : urls) {
     auto elem = url_to_sitekey_map_.find(url);
@@ -84,6 +77,8 @@ SitekeyStorageImpl::FindSiteKeyForAnyUrl(const std::vector<GURL>& urls) const {
 void SitekeyStorageImpl::ProcessSiteKey(const GURL& request_url,
                                         const SiteKey& site_key,
                                         const std::string& user_agent) {
+  // remove Acceptable Ads site key processing
+  if ((true)) return; // simple caution, never invoked being private
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   DCHECK(!site_key.value().empty());
   auto site_key_pair = FindSiteKeyForAnyUrl({request_url});
@@ -134,6 +129,8 @@ bool SitekeyStorageImpl::IsSitekeySignatureValid(
     const std::string& public_key_b64,
     const std::string& signature_b64,
     const std::string& data) const {
+  // remove Acceptable Ads site key
+  if ((true)) return false; // simple caution, never invoked being private
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   std::string signature;
   if (!base::Base64Decode(signature_b64, &signature,
diff --git a/components/adblock/core/subscription/conversion_executors.h b/components/adblock/core/subscription/conversion_executors.h
--- a/components/adblock/core/subscription/conversion_executors.h
+++ b/components/adblock/core/subscription/conversion_executors.h
@@ -40,6 +40,7 @@ class ConversionExecutors {
   virtual void ConvertFilterListFile(
       const GURL& subscription_url,
       const base::FilePath& path,
+      bool allow_privileged_filter,
       base::OnceCallback<void(ConversionResult)> result_callback) const = 0;
 
   virtual ~ConversionExecutors() = default;
diff --git a/components/adblock/core/subscription/filtering_configuration_maintainer.h b/components/adblock/core/subscription/filtering_configuration_maintainer.h
--- a/components/adblock/core/subscription/filtering_configuration_maintainer.h
+++ b/components/adblock/core/subscription/filtering_configuration_maintainer.h
@@ -24,6 +24,7 @@
 #include "base/memory/scoped_refptr.h"
 #include "components/adblock/core/subscription/subscription.h"
 #include "components/adblock/core/subscription/subscription_collection.h"
+#include "components/adblock/core/subscription/subscription_persistent_metadata.h"
 
 namespace adblock {
 
@@ -41,6 +42,9 @@ class FilteringConfigurationMaintainer {
   virtual std::unique_ptr<SubscriptionCollection> GetSubscriptionCollection()
       const = 0;
 
+  virtual void StartUpdate() = 0;
+  virtual raw_ptr<SubscriptionPersistentMetadata> GetMetadata() = 0;
+
   // Allows inspecting what Subscriptions are currently in use. This includes
   // ongoing downloads, preloaded subscriptions and installed subscriptions.
   virtual std::vector<scoped_refptr<Subscription>> GetCurrentSubscriptions()
diff --git a/components/adblock/core/subscription/filtering_configuration_maintainer_impl.cc b/components/adblock/core/subscription/filtering_configuration_maintainer_impl.cc
--- a/components/adblock/core/subscription/filtering_configuration_maintainer_impl.cc
+++ b/components/adblock/core/subscription/filtering_configuration_maintainer_impl.cc
@@ -19,6 +19,7 @@
 
 #include "base/functional/bind.h"
 #include "base/logging.h"
+#include "base/strings/string_util.h"
 #include "base/trace_event/common/trace_event_common.h"
 #include "base/trace_event/trace_event.h"
 #include "components/adblock/core/subscription/subscription_collection_impl.h"
@@ -273,9 +274,22 @@ void FilteringConfigurationMaintainerImpl::RemoveDuplicateSubscriptions() {
                         unique_subscriptions.end());
 }
 
+void FilteringConfigurationMaintainerImpl::StartUpdate() {
+  LOG(INFO) << "[eyeo] Running forced update";
+  for (auto& subscription : current_state_) {
+    const auto& url = subscription->GetSourceUrl();
+    DownloadAndInstallSubscription(url);
+  }
+}
+
+raw_ptr<SubscriptionPersistentMetadata>
+      FilteringConfigurationMaintainerImpl::GetMetadata() {
+  return persistent_metadata_;
+}
+
 void FilteringConfigurationMaintainerImpl::RunUpdateCheck() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  VLOG(1) << "[eyeo] Running update check";
+  LOG(INFO) << "[eyeo] Running update check";
 
   // Run recommended subscription update check first so
   // we don't update lists that would get removed.
@@ -313,7 +327,6 @@ void FilteringConfigurationMaintainerImpl::RunUpdateCheck() {
                                      AcceptableAdsUrl();
                             }) &&
       persistent_metadata_->IsExpired(AcceptableAdsUrl())) {
-    PingAcceptableAds();
   }
 }
 
@@ -405,15 +418,6 @@ void FilteringConfigurationMaintainerImpl::SubscriptionAddedToStorage(
   subscription_updated_callback_.Run(subscription->GetSourceUrl());
 }
 
-void FilteringConfigurationMaintainerImpl::PingAcceptableAds() {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  DCHECK(IsInitialized());
-  downloader_->DoHeadRequest(
-      AcceptableAdsUrl(),
-      base::BindOnce(&FilteringConfigurationMaintainerImpl::OnHeadRequestDone,
-                     weak_ptr_factory_.GetWeakPtr()));
-}
-
 void FilteringConfigurationMaintainerImpl::OnHeadRequestDone(
     const std::string version) {
   if (version.empty()) {
@@ -426,20 +430,20 @@ void FilteringConfigurationMaintainerImpl::OnHeadRequestDone(
 
 void FilteringConfigurationMaintainerImpl::UninstallSubscription(
     const GURL& subscription_url) {
-  DVLOG(1) << "[eyeo] Removing subscription " << subscription_url;
+  LOG(INFO) << "[eyeo] Removing subscription " << subscription_url;
   if (!UninstallSubscriptionInternal(subscription_url)) {
-    VLOG(1) << "[eyeo] Nothing to remove, subscription not installed "
+    LOG(INFO) << "[eyeo] Nothing to remove, subscription not installed "
             << subscription_url;
     return;
   }
-  if (subscription_url != AcceptableAdsUrl()) {
+  if ((true) || subscription_url != AcceptableAdsUrl()) {
     // Remove metadata associated with the subscription. Retain (forever)
     // metadata of the Acceptable Ads subscription even when it's no longer
     // installed, to allow continued HEAD-only pings for user counting purposes.
     persistent_metadata_->RemoveMetadata(subscription_url);
   }
   UpdatePreloadedSubscriptionProvider();
-  VLOG(1) << "[eyeo] Removed subscription " << subscription_url;
+  LOG(INFO) << "[eyeo] Removed subscription " << subscription_url;
 }
 
 bool FilteringConfigurationMaintainerImpl::UninstallSubscriptionInternal(
@@ -473,6 +477,8 @@ void FilteringConfigurationMaintainerImpl::SetCustomFilters() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
   std::vector<std::string> filters = configuration_->GetCustomFilters();
+  std::vector<std::string> temp_filters = configuration_->GetTemporaryCustomFilters();
+  filters.insert(filters.end(), temp_filters.begin(), temp_filters.end());
   std::ranges::transform(configuration_->GetAllowedDomains(),
                           std::back_inserter(filters),
                           &CreateDomainAllowlistingFilter);
diff --git a/components/adblock/core/subscription/filtering_configuration_maintainer_impl.h b/components/adblock/core/subscription/filtering_configuration_maintainer_impl.h
--- a/components/adblock/core/subscription/filtering_configuration_maintainer_impl.h
+++ b/components/adblock/core/subscription/filtering_configuration_maintainer_impl.h
@@ -61,6 +61,9 @@ class FilteringConfigurationMaintainerImpl
 
   void RemoveAutoInstalledSubscriptions() final;
 
+  void StartUpdate() final;
+  raw_ptr<SubscriptionPersistentMetadata> GetMetadata() final;
+
   // FilteringConfiguration::Observer:
   void OnFilterListsChanged(FilteringConfiguration* config) final;
   void OnAllowedDomainsChanged(FilteringConfiguration* config) final;
@@ -88,7 +91,6 @@ class FilteringConfigurationMaintainerImpl
   void SubscriptionAddedToStorage(
       scoped_refptr<OngoingInstallation> ongoing_installation,
       scoped_refptr<InstalledSubscription> subscription);
-  void PingAcceptableAds();
   void OnHeadRequestDone(const std::string version);
   void UninstallSubscription(const GURL& subscription_url);
   bool UninstallSubscriptionInternal(const GURL& subscription_url);
diff --git a/components/adblock/core/subscription/preloaded_subscription_provider_impl.cc b/components/adblock/core/subscription/preloaded_subscription_provider_impl.cc
--- a/components/adblock/core/subscription/preloaded_subscription_provider_impl.cc
+++ b/components/adblock/core/subscription/preloaded_subscription_provider_impl.cc
@@ -63,10 +63,10 @@ class PreloadedSubscriptionProviderImpl::SingleSubscriptionProvider {
           utils::MakeFlatbufferDataFromResourceBundle(
               info_.flatbuffer_resource_id),
           Subscription::InstallationState::Preloaded, base::Time());
-      VLOG(1) << "[eyeo] Preloaded subscription now in use: "
+      LOG(INFO) << "[eyeo] Preloaded subscription now in use: "
               << subscription_->GetSourceUrl();
     } else if (!needs_subscription && subscription_) {
-      VLOG(1) << "[eyeo] Preloaded subscription no longer in use: "
+      LOG(INFO) << "[eyeo] Preloaded subscription no longer in use: "
               << subscription_->GetSourceUrl();
       subscription_.reset();
     }
diff --git a/components/adblock/core/subscription/recommended_subscription_installer_impl.cc b/components/adblock/core/subscription/recommended_subscription_installer_impl.cc
--- a/components/adblock/core/subscription/recommended_subscription_installer_impl.cc
+++ b/components/adblock/core/subscription/recommended_subscription_installer_impl.cc
@@ -69,6 +69,7 @@ void RecommendedSubscriptionInstallerImpl::RunUpdateCheck() {
 }
 
 bool RecommendedSubscriptionInstallerImpl::IsUpdateDue() const {
+  if ((true)) return false;
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   return pref_service_->GetBoolean(
              common::prefs::kEnableAutoInstalledSubscriptions) &&
diff --git a/components/adblock/core/subscription/subscription.cc b/components/adblock/core/subscription/subscription.cc
--- a/components/adblock/core/subscription/subscription.cc
+++ b/components/adblock/core/subscription/subscription.cc
@@ -16,9 +16,29 @@
  */
 
 #include "components/adblock/core/subscription/subscription.h"
+#include "base/notreached.h"
 
 namespace adblock {
 
 Subscription::~Subscription() = default;
 
+// static
+const std::string Subscription::SubscriptionInstallationStateToString(
+    Subscription::InstallationState state) {
+  using State = Subscription::InstallationState;
+  switch (state) {
+    case State::Installed:
+      return "Installed";
+    case State::AutoInstalled:
+      return "AutoInstalled";
+    case State::Installing:
+      return "Installing";
+    case State::Preloaded:
+      return "Preloaded";
+    case State::Unknown:
+      return "Unknown";
+  }
+  NOTREACHED();
+}
+
 }  // namespace adblock
diff --git a/components/adblock/core/subscription/subscription.h b/components/adblock/core/subscription/subscription.h
--- a/components/adblock/core/subscription/subscription.h
+++ b/components/adblock/core/subscription/subscription.h
@@ -71,6 +71,9 @@ class Subscription : public base::RefCountedThreadSafe<Subscription> {
   // Typically, update checks are performed once per expiration interval.
   virtual base::TimeDelta GetExpirationInterval() const = 0;
 
+  const static std::string SubscriptionInstallationStateToString(
+    InstallationState state);
+
  protected:
   friend class base::RefCountedThreadSafe<Subscription>;
   virtual ~Subscription();
diff --git a/components/adblock/core/subscription/subscription_collection_impl.cc b/components/adblock/core/subscription/subscription_collection_impl.cc
--- a/components/adblock/core/subscription/subscription_collection_impl.cc
+++ b/components/adblock/core/subscription/subscription_collection_impl.cc
@@ -371,6 +371,7 @@ std::set<HeaderFilterData> SubscriptionCollectionImpl::GetHeaderFilters(
     ContentType content_type,
     FilterCategory category) const {
   std::set<HeaderFilterData> filters{};
+  if ((true)) return filters;
   for (const auto& subscription : subscriptions_) {
     subscription->FindHeaderFilters(
         request_url, content_type, DocumentDomain(request_url, frame_hierarchy),
diff --git a/components/adblock/core/subscription/subscription_config.cc b/components/adblock/core/subscription/subscription_config.cc
--- a/components/adblock/core/subscription/subscription_config.cc
+++ b/components/adblock/core/subscription/subscription_config.cc
@@ -19,6 +19,8 @@
 
 #include <map>
 
+#include "base/no_destructor.h"
+#include "base/strings/string_number_conversions.h"
 #include "base/strings/string_split.h"
 #include "base/strings/string_util.h"
 #include "components/adblock/core/common/adblock_constants.h"
@@ -29,7 +31,7 @@ namespace {
 int g_port_for_testing = 0;
 
 std::string GetHost() {
-  GURL url("https://easylist-downloads.adblockplus.org");
+  GURL url("https://www.cromite.org/filters/");
   if (!g_port_for_testing) {
     return url.spec();
   }
@@ -43,29 +45,29 @@ std::string GetHost() {
 namespace adblock {
 
 const GURL& AdblockBaseFilterListUrl() {
-  static GURL kAdblockBaseFilterListUrl(GetHost());
-  return kAdblockBaseFilterListUrl;
+  static const base::NoDestructor<GURL> kAdblockBaseFilterListUrl(GetHost());
+  return *kAdblockBaseFilterListUrl;
 }
 
 const GURL& AcceptableAdsUrl() {
-  static GURL kAcceptableAds(GetHost() + "exceptionrules.txt");
-  return kAcceptableAds;
+  static const base::NoDestructor<GURL> kAcceptableAds(GetHost() + "exceptionrules.txt");
+  return *kAcceptableAds;
 }
 
 const GURL& AntiCVUrl() {
-  static GURL kAntiCV(GetHost() + "abp-filters-anti-cv.txt");
-  return kAntiCV;
+  static const base::NoDestructor<GURL> kAntiCV(GetHost() + "abp-filters-anti-cv.txt");
+  return *kAntiCV;
 }
 
 const GURL& DefaultSubscriptionUrl() {
-  static GURL kEasylistUrl(GetHost() + "easylist.txt");
-  return kEasylistUrl;
+  static const base::NoDestructor<GURL> kEasylistUrl(GetHost() + "easylist.txt");
+  return *kEasylistUrl;
 }
 
 const GURL& RecommendedSubscriptionListUrl() {
-  static GURL kRecommendedSubscriptionListUrl(GetHost() +
+  static const base::NoDestructor<GURL> kRecommendedSubscriptionListUrl(GetHost() +
                                               "recommendations.json");
-  return kRecommendedSubscriptionListUrl;
+  return *kRecommendedSubscriptionListUrl;
 }
 
 KnownSubscriptionInfo::KnownSubscriptionInfo() = default;
@@ -103,12 +105,24 @@ const std::vector<KnownSubscriptionInfo>& config::GetKnownSubscriptions() {
   // The list isn't updated very often. If it starts to become a burden to
   // align the C++ representation, better to update it manually because it also
   // contains visibility and first run behavior options.
-  static std::vector<KnownSubscriptionInfo> recommendations = {
+  static const base::NoDestructor<std::vector<KnownSubscriptionInfo>> recommendations({
       {DefaultSubscriptionUrl(),
        "EasyList",
        {"en"},
        SubscriptionUiVisibility::Visible,
-       SubscriptionFirstRunBehavior::Subscribe,
+       SubscriptionFirstRunBehavior::SubscribeAtFirstRun,
+       SubscriptionPrivilegedFilterStatus::Forbidden},
+      {GURL(GetHost() + "badblock_lite.txt"),
+       "Celenity/BadBlock Lite",
+       {"en"},
+       SubscriptionUiVisibility::Visible,
+       SubscriptionFirstRunBehavior::SubscribeAtFirstRun,
+       SubscriptionPrivilegedFilterStatus::Forbidden},
+      {GURL(GetHost() + "badmojr-1Hosts-master-Pro-adblock.txt"),
+       "badmojr/1Hosts",
+       {"en"},
+       SubscriptionUiVisibility::Visible,
+       SubscriptionFirstRunBehavior::SubscribeAtFirstRun,
        SubscriptionPrivilegedFilterStatus::Forbidden},
       {GURL(GetHost() + "abpindo.txt"),
        "ABPindo",
@@ -262,17 +276,23 @@ const std::vector<KnownSubscriptionInfo>& config::GetKnownSubscriptions() {
        SubscriptionFirstRunBehavior::SubscribeIfLocaleMatch,
        SubscriptionPrivilegedFilterStatus::Forbidden},
       {AcceptableAdsUrl(),
-       "Acceptable Ads",
+       "Acceptable Ads",                      // Always disable
        {},
        SubscriptionUiVisibility::Invisible,
-       SubscriptionFirstRunBehavior::Subscribe,
+       SubscriptionFirstRunBehavior::Ignore,  // in bromite
        SubscriptionPrivilegedFilterStatus::Forbidden},
       {AntiCVUrl(),
        "ABP filters",
        {},
        SubscriptionUiVisibility::Visible,
-       SubscriptionFirstRunBehavior::Subscribe,
-       SubscriptionPrivilegedFilterStatus::Allowed},
+       SubscriptionFirstRunBehavior::SubscribeAtFirstRun,
+       SubscriptionPrivilegedFilterStatus::AllowedAndChecked},
+      {GURL("https://raw.githubusercontent.com/uazo/cromite/master/tools/filters/experimental-cromite-filters.txt"),
+       "Cromite experimental filters",
+       {},
+       SubscriptionUiVisibility::Visible,
+       SubscriptionFirstRunBehavior::SubscribeAtFirstRun,
+       SubscriptionPrivilegedFilterStatus::AllowedAndChecked},
       {GURL(GetHost() + "i_dont_care_about_cookies.txt"),
        "I don't care about cookies",
        {},
@@ -303,13 +323,13 @@ const std::vector<KnownSubscriptionInfo>& config::GetKnownSubscriptions() {
        {},
        SubscriptionUiVisibility::Invisible,
        SubscriptionFirstRunBehavior::Ignore,
-       SubscriptionPrivilegedFilterStatus::Allowed},
+       SubscriptionPrivilegedFilterStatus::AllowedAndChecked},
       {TestPagesSubscriptionUrl(),
        "ABP Test filters",
        {},
        SubscriptionUiVisibility::Invisible,
        SubscriptionFirstRunBehavior::Ignore,
-       SubscriptionPrivilegedFilterStatus::Allowed}
+       SubscriptionPrivilegedFilterStatus::Forbidden}
 
       // You can customize subscriptions available on first run and in settings
       // here. Items are displayed in settings in order declared here. See
@@ -329,9 +349,9 @@ const std::vector<KnownSubscriptionInfo>& config::GetKnownSubscriptions() {
       */
       // clang-format on
 
-  };
+  });
 
-  return recommendations;
+  return *recommendations;
 }
 
 bool config::AllowPrivilegedFilters(const GURL& url) {
@@ -346,7 +366,7 @@ bool config::AllowPrivilegedFilters(const GURL& url) {
   for (const auto& cur : GetKnownSubscriptions()) {
     if (cur.url == url) {
       return cur.privileged_status ==
-             SubscriptionPrivilegedFilterStatus::Allowed;
+             SubscriptionPrivilegedFilterStatus::AllowedAndChecked;
     }
   }
 
@@ -356,9 +376,7 @@ bool config::AllowPrivilegedFilters(const GURL& url) {
 const std::vector<PreloadedSubscriptionInfo>&
 config::GetPreloadedSubscriptionConfiguration() {
   static const std::vector<PreloadedSubscriptionInfo> preloaded_subscriptions =
-      {{"*easylist.txt", IDR_ADBLOCK_FLATBUFFER_EASYLIST},
-       {"*exceptionrules.txt", IDR_ADBLOCK_FLATBUFFER_EXCEPTIONRULES},
-       {"*abp-filters-anti-cv.txt", IDR_ADBLOCK_FLATBUFFER_ANTICV}};
+      {};
   return preloaded_subscriptions;
 }
 
@@ -368,10 +386,11 @@ void SetFilterListServerPortForTesting(int port_for_testing) {
 
 const std::vector<std::string_view>& config::MaybeSplitCombinedAdblockList(
     const GURL& filter_list) {
-  static std::vector<std::string_view> EMPTY_VALUE;
-  static std::string_view VALUE_EASYLIST_EN = "easylist.txt";
-  static std::map<std::string_view, std::vector<std::string_view>>
-      filter_lists_map = {
+  static const base::NoDestructor<std::vector<std::string_view>> EMPTY_VALUE;
+  static constexpr std::string_view VALUE_EASYLIST_EN = "easylist.txt";
+  static const base::NoDestructor<
+      std::map<std::string_view, std::vector<std::string_view>>>
+      filter_lists_map({
           {"abpindo+easylist.txt", {"abpindo.txt", VALUE_EASYLIST_EN}},
           {"abpvn+easylist", {"abpvn.txt", VALUE_EASYLIST_EN}},
           {"bulgarian_list+easylist.",
@@ -410,11 +429,11 @@ const std::vector<std::string_view>& config::MaybeSplitCombinedAdblockList(
           {"rolist+easylist.txt", {"rolist.txt", VALUE_EASYLIST_EN}},
           {"ruadlist+easylist.txt", {"ruadlist.txt", VALUE_EASYLIST_EN}},
           {"turkish+easylist.txt", {"turkish.txt", VALUE_EASYLIST_EN}},
-      };
+      });
   if (filter_list.host() != AdblockBaseFilterListUrl().host()) {
-    // This method works only for ad block maintained lists.
-    return EMPTY_VALUE;
+    return *EMPTY_VALUE;
   }
+
   auto path =
       base::TrimString(filter_list.path(), "/", base::TRIM_LEADING);
 
@@ -422,7 +441,8 @@ const std::vector<std::string_view>& config::MaybeSplitCombinedAdblockList(
   if (it == filter_lists_map->end()) {
     return *EMPTY_VALUE;
   }
-  return filter_lists_map[path];
+
+  return it->second;
 }
 
 }  // namespace adblock
diff --git a/components/adblock/core/subscription/subscription_config.h b/components/adblock/core/subscription/subscription_config.h
--- a/components/adblock/core/subscription/subscription_config.h
+++ b/components/adblock/core/subscription/subscription_config.h
@@ -39,7 +39,7 @@ enum class SubscriptionUiVisibility { Visible, Invisible };
 
 enum class SubscriptionFirstRunBehavior {
   // Download and install as soon as possible.
-  Subscribe,
+  SubscribeAtFirstRun,
   // Download and install as soon as possible but only if the device's region
   // matches one of the |languages| defined in KnownSubscriptionInfo.
   SubscribeIfLocaleMatch,
@@ -50,7 +50,7 @@ enum class SubscriptionFirstRunBehavior {
 // Privileged filters include:
 // - Snippet filters
 // - Header filters
-enum class SubscriptionPrivilegedFilterStatus { Allowed, Forbidden };
+enum class SubscriptionPrivilegedFilterStatus { AllowedAndChecked, Forbidden };
 
 // Description of a subscription that's known to exist in the Internet.
 // Can be used to populate a list of proposed or recommended subscriptions in
@@ -74,7 +74,7 @@ struct KnownSubscriptionInfo {
   std::vector<std::string> languages;
   SubscriptionUiVisibility ui_visibility = SubscriptionUiVisibility::Visible;
   SubscriptionFirstRunBehavior first_run =
-      SubscriptionFirstRunBehavior::Subscribe;
+      SubscriptionFirstRunBehavior::Ignore;
   SubscriptionPrivilegedFilterStatus privileged_status =
       SubscriptionPrivilegedFilterStatus::Forbidden;
 };
diff --git a/components/adblock/core/subscription/subscription_downloader_impl.cc b/components/adblock/core/subscription/subscription_downloader_impl.cc
--- a/components/adblock/core/subscription/subscription_downloader_impl.cc
+++ b/components/adblock/core/subscription/subscription_downloader_impl.cc
@@ -53,6 +53,7 @@ std::string BuildSubscriptionQueryParams(
     const GURL& subscription_url,
     const SubscriptionPersistentMetadata* persistent_metadata,
     const bool is_disabled) {
+  if ((true)) return subscription_url.spec();
   return base::StrCat(
       {"lastVersion=",
        base::EscapeQueryParamValue(
@@ -117,6 +118,8 @@ void SubscriptionDownloaderImpl::StartDownload(
 }
 
 void SubscriptionDownloaderImpl::CancelDownload(const GURL& subscription_url) {
+  LOG(WARNING) << "[eyeo] Download cancelled: "
+                << subscription_url;
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   ongoing_downloads_.erase(subscription_url);
 }
@@ -144,10 +147,6 @@ void SubscriptionDownloaderImpl::DoHeadRequest(
 
 bool SubscriptionDownloaderImpl::IsUrlAllowed(
     const GURL& subscription_url) const {
-  if (net::IsLocalhost(subscription_url)) {
-    // We trust all localhost urls, regardless of scheme.
-    return true;
-  }
   if (!subscription_url.SchemeIs("https") &&
       !subscription_url.SchemeIs("data")) {
     return false;
@@ -187,7 +186,7 @@ void SubscriptionDownloaderImpl::OnDownloadFinished(
 
   if (downloaded_file.empty()) {
     persistent_metadata_->IncrementDownloadErrorCount(subscription_url);
-    DLOG(WARNING) << "[eyeo] Failed to retrieve content for "
+    LOG(WARNING) << "[eyeo] Failed to retrieve content for "
                   << subscription_url << ", will abort";
     std::move(std::get<DownloadCompletedCallback>(download_it->second))
         .Run(nullptr);
@@ -203,8 +202,10 @@ void SubscriptionDownloaderImpl::OnDownloadFinished(
       TRACE_ID_LOCAL(GenerateTraceId(subscription_url)), "url",
       subscription_url.spec());
 
+  bool allow_privileged_filter =
+    persistent_metadata_->AllowPrivilegedFilters(subscription_url);
   conversion_executor_->ConvertFilterListFile(
-      subscription_url, downloaded_file,
+      subscription_url, downloaded_file, allow_privileged_filter,
       base::BindOnce(&SubscriptionDownloaderImpl::OnConversionFinished,
                      weak_ptr_factory_.GetWeakPtr(), subscription_url));
 }
@@ -218,14 +219,14 @@ void SubscriptionDownloaderImpl::OnConversionFinished(
       TRACE_ID_LOCAL(GenerateTraceId(subscription_url)));
   const auto download_it = ongoing_downloads_.find(subscription_url);
   if (download_it == ongoing_downloads_.end()) {
-    VLOG(1) << "[eyeo] Conversion result discarded, subscription download "
+    LOG(WARNING) << "[eyeo] Conversion result discarded, subscription download "
                "was cancelled.";
     return;
   }
 
   if (absl::holds_alternative<std::unique_ptr<FlatbufferData>>(
           converter_result)) {
-    VLOG(1) << "[eyeo] Finished converting " << subscription_url
+    LOG(WARNING) << "[eyeo] Finished converting " << subscription_url
             << " successfully";
     std::move(std::get<DownloadCompletedCallback>(download_it->second))
         .Run(std::move(
@@ -269,7 +270,7 @@ void SubscriptionDownloaderImpl::AbortWithWarning(
   if (ongoing_download_it == ongoing_downloads_.end()) {
     return;
   }
-  DLOG(WARNING) << "[eyeo] " << warning << " Aborting download of "
+  LOG(WARNING) << "[eyeo] " << warning << " Aborting download of "
                 << ongoing_download_it->first;
   std::move(std::get<DownloadCompletedCallback>(ongoing_download_it->second))
       .Run(nullptr);
diff --git a/components/adblock/core/subscription/subscription_persistent_metadata.h b/components/adblock/core/subscription/subscription_persistent_metadata.h
--- a/components/adblock/core/subscription/subscription_persistent_metadata.h
+++ b/components/adblock/core/subscription/subscription_persistent_metadata.h
@@ -74,6 +74,7 @@ class SubscriptionPersistentMetadata : public KeyedService {
   // Returns the number of successful downloads of this subscription in the
   // past.
   virtual int GetDownloadSuccessCount(const GURL& subscription_url) const = 0;
+  virtual bool AllowPrivilegedFilters(const GURL& subscription_url) = 0;
   // Returns number of consecutive download errors.
   virtual int GetDownloadErrorCount(const GURL& subscription_url) const = 0;
   // Mark the subscription as auto installed. Auto installed subscriptions have
diff --git a/components/adblock/core/subscription/subscription_persistent_metadata_impl.cc b/components/adblock/core/subscription/subscription_persistent_metadata_impl.cc
--- a/components/adblock/core/subscription/subscription_persistent_metadata_impl.cc
+++ b/components/adblock/core/subscription/subscription_persistent_metadata_impl.cc
@@ -24,6 +24,7 @@
 #include "base/time/time.h"
 #include "base/values.h"
 #include "components/adblock/core/common/adblock_prefs.h"
+#include "components/adblock/core/subscription/subscription_config.h"
 #include "components/prefs/scoped_user_pref_update.h"
 
 namespace adblock {
@@ -193,6 +194,12 @@ void SubscriptionPersistentMetadataImpl::UpdatePrefs() {
   prefs_->SetDict(common::prefs::kSubscriptionMetadata, std::move(dict));
 }
 
+bool SubscriptionPersistentMetadataImpl::AllowPrivilegedFilters(
+      const GURL& subscription_url) {
+  return prefs_ && prefs_->GetBoolean(common::prefs::kAllowPrivilegedFilters)
+          && config::AllowPrivilegedFilters(subscription_url);
+}
+
 void SubscriptionPersistentMetadataImpl::LoadFromPrefs() {
   const base::Value& dict =
       prefs_->GetValue(common::prefs::kSubscriptionMetadata);
diff --git a/components/adblock/core/subscription/subscription_persistent_metadata_impl.h b/components/adblock/core/subscription/subscription_persistent_metadata_impl.h
--- a/components/adblock/core/subscription/subscription_persistent_metadata_impl.h
+++ b/components/adblock/core/subscription/subscription_persistent_metadata_impl.h
@@ -44,6 +44,7 @@ class SubscriptionPersistentMetadataImpl final
   base::Time GetLastInstallationTime(const GURL& subscription_url) const final;
   std::string GetVersion(const GURL& subscription_url) const final;
   int GetDownloadSuccessCount(const GURL& subscription_url) const final;
+  bool AllowPrivilegedFilters(const GURL& subscription_url) final;
   int GetDownloadErrorCount(const GURL& subscription_url) const final;
 
   void SetAutoInstalledExpirationInterval(const GURL& subscription_url,
diff --git a/components/adblock/core/subscription/subscription_persistent_storage_impl.cc b/components/adblock/core/subscription/subscription_persistent_storage_impl.cc
--- a/components/adblock/core/subscription/subscription_persistent_storage_impl.cc
+++ b/components/adblock/core/subscription/subscription_persistent_storage_impl.cc
@@ -99,7 +99,7 @@ SubscriptionPersistentStorageImpl::ReadSubscriptionsFromDirectory(
     const base::FilePath& storage_dir,
     SubscriptionValidator::IsSignatureValidThreadSafeCallback
         is_signature_valid) {
-  DLOG(INFO) << "[eyeo] Reading subscriptions from directory";
+  LOG(INFO) << "[eyeo] Reading subscriptions from directory " << storage_dir;
   TRACE_EVENT0("eyeo", "ReadSubscriptionsFromDirectory");
   // Does nothing if directory already exists:
   base::CreateDirectory(storage_dir);
@@ -117,6 +117,8 @@ SubscriptionPersistentStorageImpl::ReadSubscriptionsFromDirectory(
     if (!base::ReadFileToString(flatbuffer_path, &contents)) {
       // File could not be read.
       base::DeleteFile(flatbuffer_path);
+      LOG(INFO) << "[eyeo] Deleting " << flatbuffer_path.BaseName().AsUTF8Unsafe()
+                << "reason: File could not be read";
       continue;
     }
     TRACE_EVENT_END1("eyeo", "ReadFileToString", "path",
@@ -124,6 +126,8 @@ SubscriptionPersistentStorageImpl::ReadSubscriptionsFromDirectory(
     TRACE_EVENT_BEGIN0("eyeo", "VerifySubscriptionBuffer");
     if (!is_signature_valid.Run(InMemoryFlatbufferData(std::move(contents)),
                                 flatbuffer_path)) {
+      LOG(INFO) << "[eyeo] Deleting " << flatbuffer_path.BaseName().AsUTF8Unsafe()
+                << "reason: This is not a valid subscription file";
       // This is not a valid subscription file, remove it.
       base::DeleteFile(flatbuffer_path);
       continue;
@@ -131,13 +135,16 @@ SubscriptionPersistentStorageImpl::ReadSubscriptionsFromDirectory(
     TRACE_EVENT_END0("eyeo", "VerifySubscriptionBuffer");
     auto buffer = std::make_unique<MemoryMappedFlatbufferData>(flatbuffer_path);
     if (!buffer->data()) {
+      LOG(INFO) << "[eyeo] Could not create mapped memory region to file content for "
+                << flatbuffer_path.BaseName().AsUTF8Unsafe();
       // Could not create mapped memory region to file content.
       // TODO(mpawlowski) revert to in-memory buffer?
       continue;
     }
+    LOG(INFO) << "[eyeo] Loaded " << flatbuffer_path.BaseName().AsUTF8Unsafe();
     result.emplace_back(std::move(buffer), std::move(flatbuffer_path));
   }
-  DLOG(INFO) << "[eyeo] Finished reading and validating subscriptions. Loaded "
+  LOG(INFO) << "[eyeo] Finished reading and validating subscriptions. Loaded "
              << result.size() << " subscriptions.";
   return result;
 }
diff --git a/components/adblock/core/subscription/subscription_service.h b/components/adblock/core/subscription/subscription_service.h
--- a/components/adblock/core/subscription/subscription_service.h
+++ b/components/adblock/core/subscription/subscription_service.h
@@ -38,6 +38,17 @@ namespace adblock {
 // FilteringConfigurations.
 class SubscriptionService : public KeyedService {
  public:
+  virtual void StartUpdate() = 0;
+  virtual raw_ptr<SubscriptionPersistentMetadata> GetMetadata() = 0;
+  virtual raw_ptr<SubscriptionPersistentMetadata> GetMetadataFor(
+    raw_ptr<FilteringConfiguration> configuration) = 0;
+  virtual void SetPrivilegedFiltersEnabled(bool enabled) = 0;
+  virtual bool IsPrivilegedFiltersEnabled() = 0;
+  virtual std::vector<scoped_refptr<Subscription>> GetCustomSubscriptions(
+    FilteringConfiguration* configuration) const = 0;
+  // Get default "adblock" filtering configuration.
+  virtual FilteringConfiguration* GetAdblockFilteringConfiguration() const = 0;
+
   using Snapshot = std::vector<std::unique_ptr<SubscriptionCollection>>;
   class SubscriptionObserver : public base::CheckedObserver {
    public:
diff --git a/components/adblock/core/subscription/subscription_service_impl.cc b/components/adblock/core/subscription/subscription_service_impl.cc
--- a/components/adblock/core/subscription/subscription_service_impl.cc
+++ b/components/adblock/core/subscription/subscription_service_impl.cc
@@ -34,9 +34,23 @@
 #include "components/adblock/core/subscription/filtering_configuration_maintainer.h"
 #include "components/adblock/core/subscription/subscription_collection.h"
 #include "components/adblock/core/subscription/subscription_service.h"
+#include "components/adblock/core/subscription/subscription_config.h"
 
 namespace adblock {
 
+namespace {
+
+bool IsKnownSubscription(
+    const std::vector<KnownSubscriptionInfo>& known_subscriptions,
+    const GURL& url) {
+  return std::ranges::any_of(known_subscriptions,
+                              [&](const auto& known_subscription) {
+                                return known_subscription.url == url;
+                              });
+}
+
+}
+
 class EmptySubscription : public Subscription {
  public:
   explicit EmptySubscription(const GURL& url) : url_(url) {}
@@ -162,6 +176,77 @@ void SubscriptionServiceImpl::UninstallFilteringConfiguration(
   }
 }
 
+void SubscriptionServiceImpl::StartUpdate() {
+  for (auto& entry : maintainers_) {
+    if (!entry.second) {
+      continue;  // Configuration is disabled
+    }
+    entry.second->StartUpdate();
+  }
+}
+
+bool SubscriptionServiceImpl::IsPrivilegedFiltersEnabled() {
+  auto* adblock_filtering_configuration = GetAdblockFilteringConfiguration();
+  return adblock_filtering_configuration->IsPrivilegedFiltersEnabled();
+}
+
+void SubscriptionServiceImpl::SetPrivilegedFiltersEnabled(bool enabled) {
+  auto* adblock_filtering_configuration = GetAdblockFilteringConfiguration();
+  adblock_filtering_configuration->SetPrivilegedFiltersEnabled(enabled);
+  auto known_subscriptions = adblock::config::GetKnownSubscriptions();
+  for (const auto& cur : known_subscriptions) {
+    if (config::AllowPrivilegedFilters(cur.url)) {
+      if (enabled)
+        adblock_filtering_configuration->AddFilterList(cur.url);
+      else
+        adblock_filtering_configuration->RemoveFilterList(cur.url);
+    }
+  }
+  StartUpdate();
+}
+
+std::vector<scoped_refptr<Subscription>>
+SubscriptionServiceImpl::GetCustomSubscriptions(
+              FilteringConfiguration* configuration) const {
+  std::vector<scoped_refptr<Subscription>> selected =
+    GetCurrentSubscriptions(configuration);
+
+  auto known_subscriptions = adblock::config::GetKnownSubscriptions();
+  selected.erase(std::remove_if(selected.begin(), selected.end(),
+                                [&known_subscriptions](const auto& subscription) {
+                                  return IsKnownSubscription(
+                                      known_subscriptions,
+                                      subscription->GetSourceUrl());
+                                }),
+                 selected.end());
+  return selected;
+}
+
+raw_ptr<SubscriptionPersistentMetadata> SubscriptionServiceImpl::GetMetadata() {
+  return GetMetadataFor(GetAdblockFilteringConfiguration());
+}
+
+raw_ptr<SubscriptionPersistentMetadata> SubscriptionServiceImpl::GetMetadataFor(
+    raw_ptr<FilteringConfiguration> configuration) {
+  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  auto it = std::ranges::find_if(maintainers_, [&](const auto& entry) {
+    return entry.first.get() == configuration;
+  });
+  if (it != maintainers_.end() && it->second) {
+    return it->second->GetMetadata();
+  }
+  return nullptr;
+}
+
+FilteringConfiguration*
+SubscriptionServiceImpl::GetAdblockFilteringConfiguration() const {
+  const auto it = std::ranges::find_if(maintainers_, [](const auto& pair) {
+    return pair.first->GetName() == kAdblockFilteringConfigurationName;
+  });
+  DCHECK(it != maintainers_.end());
+  return it->first.get();
+}
+
 std::vector<FilteringConfiguration*>
 SubscriptionServiceImpl::GetInstalledFilteringConfigurations() {
   std::vector<FilteringConfiguration*> result;
@@ -232,7 +317,7 @@ void SubscriptionServiceImpl::OnEnabledStateChanged(
   });
   DCHECK(it != maintainers_.end()) << "Received OnEnabledStateChanged from "
                                       "unregistered FilteringConfiguration";
-  VLOG(1) << "[eyeo] FilteringConfiguration " << config->GetName()
+  LOG(INFO) << "[eyeo] FilteringConfiguration " << config->GetName()
           << (config->IsEnabled() ? " enabled" : " disabled");
   if (config->IsEnabled()) {
     // Enable the configuration by creating a new
diff --git a/components/adblock/core/subscription/subscription_service_impl.h b/components/adblock/core/subscription/subscription_service_impl.h
--- a/components/adblock/core/subscription/subscription_service_impl.h
+++ b/components/adblock/core/subscription/subscription_service_impl.h
@@ -42,6 +42,16 @@ namespace adblock {
 class SubscriptionServiceImpl final : public SubscriptionService,
                                       public FilteringConfiguration::Observer {
  public:
+  void StartUpdate() override;
+  raw_ptr<SubscriptionPersistentMetadata> GetMetadata() override;
+  raw_ptr<SubscriptionPersistentMetadata> GetMetadataFor(
+    raw_ptr<FilteringConfiguration> configuration) final;
+  void SetPrivilegedFiltersEnabled(bool enabled) override;
+  bool IsPrivilegedFiltersEnabled() override;
+  std::vector<scoped_refptr<Subscription>> GetCustomSubscriptions(
+      FilteringConfiguration* configuration) const override;
+  FilteringConfiguration* GetAdblockFilteringConfiguration() const final;
+
   // Used to notify this about updates to installed subscriptions.
   using SubscriptionUpdatedCallback =
       base::RepeatingCallback<void(const GURL& subscription_url)>;
diff --git a/components/adblock/core/subscription/subscription_validator_impl.cc b/components/adblock/core/subscription/subscription_validator_impl.cc
--- a/components/adblock/core/subscription/subscription_validator_impl.cc
+++ b/components/adblock/core/subscription/subscription_validator_impl.cc
@@ -63,11 +63,11 @@ bool IsSignatureValidInternal(
   const auto* expected_hash = initial_subscription_signatures.FindString(
       path.BaseName().AsUTF8Unsafe());
   if (!expected_hash) {
-    DLOG(WARNING) << "[eyeo] " << path << " has no matching signature in prefs";
+    LOG(WARNING) << "[eyeo] " << path.BaseName().AsUTF8Unsafe() << " has no matching signature in prefs";
     return false;
   }
   if (*expected_hash != ComputeSubscriptionHash(data)) {
-    DLOG(WARNING) << "[eyeo] " << path << " has invalid signature in prefs";
+    LOG(WARNING) << "[eyeo] " << path.BaseName().AsUTF8Unsafe() << " has invalid signature in prefs";
     return false;
   }
   return true;
diff --git a/components/adblock/features.gni b/components/adblock/features.gni
--- a/components/adblock/features.gni
+++ b/components/adblock/features.gni
@@ -47,5 +47,5 @@ declare_args() {
   eyeo_disable_filtering_by_default = false
 
   # If true then acceptable ads is disabled by default (applies to 1st run scenario).
-  eyeo_disable_aa_by_default = false
+  eyeo_disable_aa_by_default = true
 }
diff --git a/components/blocked_content/popup_blocker.cc b/components/blocked_content/popup_blocker.cc
--- a/components/blocked_content/popup_blocker.cc
+++ b/components/blocked_content/popup_blocker.cc
@@ -20,6 +20,11 @@
 #include "third_party/blink/public/mojom/frame/frame.mojom-shared.h"
 
 namespace blocked_content {
+
+CROMITE_FEATURE(kStrictPopupBlocker,
+                "StrictPopupBlocker",
+                base::FEATURE_DISABLED_BY_DEFAULT);
+
 namespace {
 
 content::Page& GetSourcePageForPopup(
@@ -91,7 +96,9 @@ PopupBlockType ShouldBlockPopup(content::WebContents* web_contents,
           GetSourcePageForPopup(open_url_params, web_contents))) {
     return PopupBlockType::kAbusive;
   }
-  return PopupBlockType::kNotBlocked;
+  return base::FeatureList::IsEnabled(kStrictPopupBlocker)
+           ? PopupBlockType::kAbusive
+           : PopupBlockType::kNotBlocked;
 }
 
 }  // namespace
diff --git a/components/blocked_content/popup_blocker.h b/components/blocked_content/popup_blocker.h
--- a/components/blocked_content/popup_blocker.h
+++ b/components/blocked_content/popup_blocker.h
@@ -5,6 +5,7 @@
 #ifndef COMPONENTS_BLOCKED_CONTENT_POPUP_BLOCKER_H_
 #define COMPONENTS_BLOCKED_CONTENT_POPUP_BLOCKER_H_
 
+#include "base/feature_list.h"
 #include "components/content_settings/core/browser/host_content_settings_map.h"
 #include "third_party/blink/public/mojom/window_features/window_features.mojom-forward.h"
 #include "ui/base/window_open_disposition.h"
@@ -18,6 +19,8 @@ struct OpenURLParams;
 }  // namespace content
 
 namespace blocked_content {
+BASE_DECLARE_FEATURE(kStrictPopupBlocker);
+
 class PopupNavigationDelegate;
 
 // Classifies what caused a popup to be blocked.
diff --git a/components/content_settings/core/browser/bromite_content_settings/ads.inc b/components/content_settings/core/browser/bromite_content_settings/ads.inc
new file mode 100644
--- /dev/null
+++ b/components/content_settings/core/browser/bromite_content_settings/ads.inc
@@ -0,0 +1,3 @@
+  content_settings::WebsiteSettingsRegistry::GetInstance()
+    ->GetMutable(ContentSettingsType::ADS)
+    ->set_show_into_info_page();
diff --git a/components/error_page_strings.grdp b/components/error_page_strings.grdp
--- a/components/error_page_strings.grdp
+++ b/components/error_page_strings.grdp
@@ -263,6 +263,22 @@
     Your organization doesnt allow you to view this site
   </message>
 
+  <message name="IDS_ERRORPAGES_TITLE_BLOCKED_BY_ADMINISTRATOR" desc="Title in the error page when an administrator policy blocks a request.">
+    Blocked by Adblock
+  </message>
+  <message name="IDS_ERRORPAGES_HEADING_BLOCKED_BY_ADMINISTRATOR" desc="Heading in the error page when an administrator policy blocks a request.">
+    Blocked by Adblock
+  </message>
+  <message name="IDS_ERRORPAGES_PRIMARY_PARAGRAPH_BLOCKED_BY_ADMINISTRATOR" desc="Primary paragraph in the error page when an administrator policy blocks a request.">
+    Adblock doesnt allow you to view this site (subscription url <ph name="URL">&lt;strong&gt;$1&lt;/strong&gt;<ex>example.com/</ex></ph>)
+  </message>
+  <message name="IDS_ERRORPAGES_PRIMARYBUTTONTEXT_BLOCKED_BY_ADMINISTRATOR" desc="Primary button text in the error page when an administrator policy blocks a request.">
+    Allow navigation until restart
+  </message>
+  <message name="IDS_ERRORPAGES_PROCEEDBUTTONTEXT_BLOCKED_BY_ADMINISTRATOR" desc="Proceed button text in the error page when an administrator policy blocks a request.">
+    Add a custom persistent allow rule
+  </message>
+
   <message name="IDS_ERRORPAGES_SUMMARY_BLOCKED_BY_SECURITY" desc="Summary in the error page when the request has been blocked because of some security configuration of the site.">
     This content is blocked. Contact the site owner to fix the issue.
   </message>
diff --git a/components/security_interstitials/core/browser/resources/interstitial_enterprisewarn.css b/components/security_interstitials/core/browser/resources/interstitial_enterprisewarn.css
--- a/components/security_interstitials/core/browser/resources/interstitial_enterprisewarn.css
+++ b/components/security_interstitials/core/browser/resources/interstitial_enterprisewarn.css
@@ -14,3 +14,10 @@
     filter: invert(1);
   }
 }
+
+.enterprise-warn .interstitial-wrapper .nav-wrapper button {
+    float: none !important;
+    width: 100%;
+    margin-bottom: 20px;
+    padding: 14px;
+}
diff --git a/content/browser/websockets/websocket_connector_impl.cc b/content/browser/websockets/websocket_connector_impl.cc
--- a/content/browser/websockets/websocket_connector_impl.cc
+++ b/content/browser/websockets/websocket_connector_impl.cc
@@ -92,15 +92,15 @@ void WebSocketConnectorImpl::Connect(
   const uint32_t options =
       GetContentClient()->browser()->GetWebSocketOptions(frame);
 
-  if (GetContentClient()->browser()->WillInterceptWebSocket(frame)) {
+  if (GetContentClient()->browser()->WillInterceptWebSocket(frame, process, origin_)) {
     GetContentClient()->browser()->CreateWebSocket(
-        frame,
+        process, frame,
         base::BindOnce(ConnectCalledByContentBrowserClient, requested_protocols,
                        site_for_cookies, storage_access_api_status,
                        isolation_info_, process_id_, frame_id_, origin_,
                        client_security_state_->Clone(), options,
                        std::move(throttling_profile_id)),
-        url, site_for_cookies, user_agent, std::move(handshake_client));
+        url, origin_, site_for_cookies, user_agent, std::move(handshake_client));
     return;
   }
   std::vector<network::mojom::HttpHeaderPtr> headers;
diff --git a/content/public/browser/content_browser_client.cc b/content/public/browser/content_browser_client.cc
--- a/content/public/browser/content_browser_client.cc
+++ b/content/public/browser/content_browser_client.cc
@@ -1145,7 +1145,7 @@ void ContentBrowserClient::WillCreateURLLoaderFactory(
   DCHECK(browser_context);
 }
 
-bool ContentBrowserClient::WillInterceptWebSocket(RenderFrameHost*) {
+bool ContentBrowserClient::WillInterceptWebSocket(RenderFrameHost*, RenderProcessHost*, const url::Origin& origin) {
   return false;
 }
 
@@ -1154,9 +1154,11 @@ uint32_t ContentBrowserClient::GetWebSocketOptions(RenderFrameHost* frame) {
 }
 
 void ContentBrowserClient::CreateWebSocket(
+    RenderProcessHost* process,
     RenderFrameHost* frame,
     WebSocketFactory factory,
     const GURL& url,
+    const url::Origin& initiator_origin,
     const net::SiteForCookies& site_for_cookies,
     const std::optional<std::string>& user_agent,
     mojo::PendingRemote<network::mojom::WebSocketHandshakeClient>
diff --git a/content/public/browser/content_browser_client.h b/content/public/browser/content_browser_client.h
--- a/content/public/browser/content_browser_client.h
+++ b/content/public/browser/content_browser_client.h
@@ -2140,7 +2140,7 @@ class CONTENT_EXPORT ContentBrowserClient {
       scoped_refptr<base::SequencedTaskRunner> navigation_response_task_runner);
 
   // Returns true when the embedder wants to intercept a websocket connection.
-  virtual bool WillInterceptWebSocket(RenderFrameHost* frame);
+  virtual bool WillInterceptWebSocket(RenderFrameHost* frame, RenderProcessHost* process, const url::Origin& origin);
 
   // Returns the WebSocket creation options.
   virtual uint32_t GetWebSocketOptions(RenderFrameHost* frame);
@@ -2162,9 +2162,11 @@ class CONTENT_EXPORT ContentBrowserClient {
   // Always called on the UI thread and only when the Network Service is
   // enabled.
   virtual void CreateWebSocket(
+      RenderProcessHost* process,
       RenderFrameHost* frame,
       WebSocketFactory factory,
       const GURL& url,
+      const url::Origin& initiator_origin,
       const net::SiteForCookies& site_for_cookies,
       const std::optional<std::string>& user_agent,
       mojo::PendingRemote<network::mojom::WebSocketHandshakeClient>
diff --git a/content/public/common/isolated_world_ids.h b/content/public/common/isolated_world_ids.h
--- a/content/public/common/isolated_world_ids.h
+++ b/content/public/common/isolated_world_ids.h
@@ -21,7 +21,7 @@ enum IsolatedWorldIDs : int32_t {
   ISOLATED_WORLD_ID_GLOBAL = 0,
 
   // Isolated world for eyeo ad blocking (element hiding)
-  ISOLATED_WORLD_ID_ADBLOCK,
+  ISOLATED_WORLD_ID_ADBLOCK_VERIFIED,
 
   // Custom isolated world ids used by other embedders should start from here.
   ISOLATED_WORLD_ID_CONTENT_END,
diff --git a/cromite_flags/chrome/browser/about_flags_cc/Stricter-popup-blocker.inc b/cromite_flags/chrome/browser/about_flags_cc/Stricter-popup-blocker.inc
new file mode 100644
--- /dev/null
+++ b/cromite_flags/chrome/browser/about_flags_cc/Stricter-popup-blocker.inc
@@ -0,0 +1,14 @@
+#ifdef ABOUT_FLAG_INCLUDE_SECTION
+
+#include "components/blocked_content/popup_blocker.h"
+
+#endif
+
+#ifdef FLAG_SECTION
+
+    {"enable-stricter-popup-blocker",
+     "Enable Stricter popup blocker",
+     "Blocks all pop-ups, even those with user gestures.", kOsAll,
+     FEATURE_VALUE_TYPE(blocked_content::kStrictPopupBlocker)},
+
+#endif // ifdef FLAG_SECTION
diff --git a/third_party/blink/renderer/core/css/style_engine.cc b/third_party/blink/renderer/core/css/style_engine.cc
--- a/third_party/blink/renderer/core/css/style_engine.cc
+++ b/third_party/blink/renderer/core/css/style_engine.cc
@@ -652,6 +652,14 @@ void StyleEngine::PrepareUpdateActiveStyleSheetsInShadow(
   collection->PrepareUpdateActiveStyleSheets(medium);
 }
 
+bool StyleEngine::ActiveUserStyleSheetsContainsKey(const StyleSheetKey& injection_key) {
+  for (auto& sheet : injected_user_style_sheets_)
+    if (sheet.first == injection_key)
+      return true;
+
+  return false;
+}
+
 void StyleEngine::UpdateActiveUserStyleSheets() {
   DCHECK(user_style_dirty_);
 
diff --git a/third_party/blink/renderer/core/css/style_engine.h b/third_party/blink/renderer/core/css/style_engine.h
--- a/third_party/blink/renderer/core/css/style_engine.h
+++ b/third_party/blink/renderer/core/css/style_engine.h
@@ -289,6 +289,7 @@ class CORE_EXPORT StyleEngine final : public GarbageCollected<StyleEngine>,
       const ComputedStyle* embedder_style) const;
   void ViewportStyleSettingChanged();
 
+  bool ActiveUserStyleSheetsContainsKey(const StyleSheetKey& injection_key);
   void InjectSheet(const StyleSheetKey&,
                    StyleSheetContents*,
                    WebCssOrigin = WebCssOrigin::kAuthor);
diff --git a/third_party/blink/renderer/core/dom/events/event_target.cc b/third_party/blink/renderer/core/dom/events/event_target.cc
--- a/third_party/blink/renderer/core/dom/events/event_target.cc
+++ b/third_party/blink/renderer/core/dom/events/event_target.cc
@@ -855,10 +855,7 @@ bool EventTarget::dispatchEventForBindings(Event* event,
   if (!GetExecutionContext())
     return false;
 
-  auto* world = GetExecutionContext()->GetCurrentWorld();
-  // content::IsolatedWorldIDs::ISOLATED_WORLD_ID_ADBLOCK == 1
-  bool make_trusted = world && (world->GetWorldId() == 1);
-  event->SetTrusted(make_trusted);
+  event->SetTrusted(false);
 
   // Return whether the event was cancelled or not to JS not that it
   // might have actually been default handled; so check only against
diff --git a/third_party/blink/renderer/core/exported/web_document.cc b/third_party/blink/renderer/core/exported/web_document.cc
--- a/third_party/blink/renderer/core/exported/web_document.cc
+++ b/third_party/blink/renderer/core/exported/web_document.cc
@@ -300,6 +300,16 @@ WebStyleSheetKey WebDocument::InsertAbpElemhideStylesheet(
   Document* document = Unwrap<Document>();
   DCHECK(document);
 
+  const WebStyleSheetKey& injection_key =
+      key && !key->IsNull() ? *key : WebString::FromUTF8("abp");
+  DCHECK(!injection_key.IsEmpty());
+
+  // Check if the css in already present
+  if (document->GetStyleEngine().ActiveUserStyleSheetsContainsKey(injection_key)) {
+    DLOG(WARNING) << "[eyeo] Skip add css as already in collection";
+    return injection_key;
+  }
+
   auto* parsed_sheet = MakeGarbageCollected<StyleSheetContents>(
       MakeGarbageCollected<CSSParserContext>(*document));
   parsed_sheet->ParseString(source_code);
@@ -321,9 +331,6 @@ WebStyleSheetKey WebDocument::InsertAbpElemhideStylesheet(
         {SchedulingPolicy::DisableBackForwardCache()});
   }
 
-  const WebStyleSheetKey& injection_key =
-      key && !key->IsNull() ? *key : GenerateStyleSheetKey();
-  DCHECK(!injection_key.IsEmpty());
   document->GetStyleEngine().InjectSheet(injection_key, parsed_sheet, origin);
   return injection_key;
 }
diff --git a/third_party/blink/renderer/core/html/html_element.cc b/third_party/blink/renderer/core/html/html_element.cc
--- a/third_party/blink/renderer/core/html/html_element.cc
+++ b/third_party/blink/renderer/core/html/html_element.cc
@@ -2917,13 +2917,7 @@ void HTMLElement::setSpellcheck(bool enable) {
 }
 
 void HTMLElement::click() {
-  auto* world = GetExecutionContext() ? GetExecutionContext()->GetCurrentWorld()
-                                      : nullptr;
-  // content::IsolatedWorldIDs::ISOLATED_WORLD_ID_ADBLOCK == 1
-  bool make_trusted = world && (world->GetWorldId() == 1);
-  DispatchSimulatedClick(
-      nullptr, make_trusted ? SimulatedClickCreationScope::kFromUserAgent
-                            : SimulatedClickCreationScope::kFromScript);
+  DispatchSimulatedClick(nullptr, SimulatedClickCreationScope::kFromScript);
   if (IsA<HTMLInputElement>(this)) {
     UseCounter::Count(GetDocument(),
                       WebFeature::kHTMLInputElementSimulatedClick);
diff --git a/tools/typescript/definitions/adblock_private.d.ts b/tools/typescript/definitions/adblock_private.d.ts
--- a/tools/typescript/definitions/adblock_private.d.ts
+++ b/tools/typescript/definitions/adblock_private.d.ts
@@ -33,8 +33,22 @@ declare global {
         title: string;
         current_version: string;
         last_installation_time: string;
+        download_error_count: number;
+        download_success_count: number;
       }
 
+      export function startUpdate(): void;
+
+      export function setPrivilegedFiltersEnabled(
+        enabled: boolean,
+      ): void;
+
+      export function isPrivilegedFiltersEnabled(
+        callback: (
+          result: boolean,
+        ) => void,
+      ): void;
+
       export interface SessionStatsEntry {
         url: string;
         count: number;
--
