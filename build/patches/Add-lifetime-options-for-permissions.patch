From: uazo <uazo@users.noreply.github.com>
Date: Fri, 8 Apr 2022 11:04:04 +0000
Subject: Add lifetime options for permissions

Indicate the session mode for content-settings by using the constraint `content_settings::SessionModel` as
UserSession when setting the value, and also make use of an expiration time value.
This is used in Chromium for `ClientHints` but it is generally possible to use this functionality when a
specific value needs to be persisted by origin.
All content settings of this type are not saved on disk (except for the `Forever` option), allowing user to
reset the status each time application is restarted.

There are 4 main areas affected to introduce the functionality:
* components/content_settings
  A new `content_settings::LifetimeMode` enum value is defined to specify the user's
  choice (Always, OnlyThisTime, UntilOriginClosed, UntilBrowserClosed).
  Enumeration is also generated for java by adding it in `content_settings_enums_javagen` (gn).
  This is mainly used in `content_settings_utils.cc` to create a specialised `content_settings::ContentSettingConstraints`
  that is then used in `SetContentSettingDefaultScope()` by `PermissionContextBase::UpdateContentSetting`.
  Existing Chromium data structures do not provide a specific property to define a choice which is instead encoded through
  the `ContentSettingConstraints`; this approach is already used in other parts of the Chromium codebase so it is not
  novel here.
  Therefore, `content_settings::GetConstraintSessionExpiration()` and `content_settings::IsConstraintSessionExpiration()`
  manage the lifetime modes of the session content-settings.
  The modification also adds the session pattern to the ContentSettingPatternSource so that it is available for the UI.
* components/permissions
  Lifetime support is added to the permissions; most of the changes are caused by the fact that it is necessary to report
  the value selected by the user from the Java UI managed by `components/browser_ui` up to
  `PermissionContextBase::UpdateContentSetting()`,   without necessarily having to modify all requests that are not
  related to geolocation/camera/microphone. The approach used is a new
  `PermissionRequest::PermissionDecidedCallbackWithLifetime` used by an overload of
  `PermissionContextBase::CreatePermissionRequest` so that options are present only for the specific content-settings
  (see `PermissionDialogModel.java`).
  For other permissions no behaviour is changed (see `PermissionDialogDelegate::Accept`); for geolocation it was
  necessary to act directly in the specific context, because, unlike microphone/camera, the content-setting value is
  inserted in its specific method (`FinishNotifyPermissionSet`, that calls the callback), even if the class always
  derives from `PermissionContextBase`.
* components/page_info
  Some changes needed to see in the summary of the `page_info` the text "(only this session)"
  (aka `page_info_android_permission_session_permission`) through adding a new property "is_user_session" in
  `PageInfoPermissionEntry` (Java).
* components/browser_ui
  Changes to the Settings UI to show "(only this session)" in the specific content-setting.
  The same view is used both in the settings and in the page_info.

For the management of `UntilOriginClosed` the logic used by flag `kOneTimeGeolocationPermission` was used; this flag
is active only in the desktop (files `last_tab_standing_tracker_*`). It is a class that manages a list of the active
origins and allows to perform operations when all the tabs relating to that origin have been closed, in this case
deleting the session content settings of `UntilOriginClosed`.

See also: https://github.com/bromite/bromite/issues/1549

Original License: GPL-2.0-or-later - https://spdx.org/licenses/GPL-2.0-or-later.html
License: GPL-3.0-only - https://spdx.org/licenses/GPL-3.0-only.html
---
 .../permissions/last_tab_standing_tracker.cc  | 33 ++++++++
 .../one_time_permissions_tracker.cc           | 34 +++++++-
 .../one_time_permissions_tracker.h            |  5 +-
 .../one_time_permissions_tracker_factory.cc   |  2 +-
 .../views/permissions/chip/chip_controller.cc |  2 +-
 ...exclusive_access_permission_prompt_view.cc |  2 +-
 .../permission_prompt_bubble_base_view.cc     |  2 +-
 .../site_settings/SingleWebsiteSettings.java  |  9 ++
 .../android/website_preference_bridge.cc      |  2 +-
 .../strings/android/browser_ui_strings.grd    |  5 ++
 .../core/browser/content_settings_utils.cc    | 44 ++++++++--
 .../core/browser/content_settings_utils.h     |  6 ++
 .../core/common/content_settings_enums.mojom  |  9 ++
 .../page_info/PageInfoController.java         |  4 +-
 .../PermissionParamsListBuilder.java          | 13 ++-
 .../android/page_info_controller_android.cc   | 10 ++-
 components/page_info/page_info.cc             |  2 +
 components/page_info/page_info.h              |  1 +
 .../permissions/PermissionDialogDelegate.java | 13 +++
 .../PermissionDialogModelFactory.java         | 83 ++++++++++++++++++-
 .../embedded_permission_prompt_android.cc     |  3 +-
 .../embedded_permission_prompt_android.h      |  2 +-
 .../permission_dialog_delegate.cc             | 24 +++++-
 .../permission_dialog_delegate.h              |  1 +
 .../permission_prompt_android.cc              |  8 +-
 .../permission_prompt_android.h               |  3 +-
 .../android/permissions_android_strings.grd   | 17 ++++
 .../geolocation_permission_context_android.cc | 30 +++++--
 .../geolocation_permission_context_android.h  |  8 ++
 .../embedded_permission_prompt_flow_model.cc  |  2 +-
 .../permissions/permission_context_base.cc    | 64 ++++++++++++--
 .../permissions/permission_context_base.h     | 26 +++++-
 components/permissions/permission_prompt.h    |  3 +-
 components/permissions/permission_request.cc  | 34 +++++++-
 components/permissions/permission_request.h   | 18 +++-
 .../permissions/permission_request_manager.cc | 45 ++++++----
 .../permissions/permission_request_manager.h  | 11 ++-
 37 files changed, 507 insertions(+), 73 deletions(-)

diff --git a/chrome/browser/permissions/last_tab_standing_tracker.cc b/chrome/browser/permissions/last_tab_standing_tracker.cc
--- a/chrome/browser/permissions/last_tab_standing_tracker.cc
+++ b/chrome/browser/permissions/last_tab_standing_tracker.cc
@@ -7,6 +7,32 @@
 #include "base/observer_list.h"
 #include "url/gurl.h"
 
+#include "components/content_settings/core/browser/host_content_settings_map.h"
+#include "components/content_settings/core/common/content_settings_utils.h"
+#include "components/permissions/permissions_client.h"
+
+namespace {
+  // Remove all sessions content setting by origin and type
+  void RemoveSessionSettings(HostContentSettingsMap* content_settings,
+                             const url::Origin& origin,
+                             ContentSettingsType type) {
+    ContentSettingsForOneType session_settings =
+      content_settings->GetSettingsForOneType(
+          type, content_settings::mojom::SessionModel::USER_SESSION);
+
+    GURL url = origin.GetURL();
+    for (ContentSettingPatternSource& entry : session_settings) {
+      if (content_settings::IsConstraintSessionExpiration(entry,
+              content_settings::mojom::LifetimeMode::UNTIL_ORIGIN_CLOSED) &&
+          entry.primary_pattern.Matches(url)) {
+        content_settings->SetWebsiteSettingCustomScope(
+            entry.primary_pattern, entry.secondary_pattern,
+            type, base::Value());
+      }
+    }
+  }
+}
+
 LastTabStandingTracker::LastTabStandingTracker(content::BrowserContext* context)
     : context_(context) {}
 
@@ -56,4 +82,11 @@ void LastTabStandingTracker::WebContentsUnloadedOrigin(
     for (auto& observer : observer_list_) {
       observer.OnLastPageFromOriginClosed(origin);
     }
+    HostContentSettingsMap* content_settings =
+            permissions::PermissionsClient::Get()->GetSettingsMap(context_);
+    RemoveSessionSettings(content_settings, origin, ContentSettingsType::GEOLOCATION);
+    RemoveSessionSettings(content_settings, origin, ContentSettingsType::GEOLOCATION_WITH_OPTIONS);
+    RemoveSessionSettings(content_settings, origin, ContentSettingsType::MEDIASTREAM_MIC);
+    RemoveSessionSettings(content_settings, origin, ContentSettingsType::MEDIASTREAM_CAMERA);
+  }
 }
diff --git a/chrome/browser/permissions/one_time_permissions_tracker.cc b/chrome/browser/permissions/one_time_permissions_tracker.cc
--- a/chrome/browser/permissions/one_time_permissions_tracker.cc
+++ b/chrome/browser/permissions/one_time_permissions_tracker.cc
@@ -19,8 +19,34 @@
 #include "components/permissions/features.h"
 #include "content/public/browser/visibility.h"
 #include "url/gurl.h"
+#include "components/content_settings/core/browser/host_content_settings_map.h"
+#include "components/content_settings/core/common/content_settings_utils.h"
+#include "components/permissions/permissions_client.h"
+
+namespace {
+  // Remove all sessions content setting by origin and type
+  void RemoveSessionSettings(HostContentSettingsMap* content_settings,
+                             const url::Origin& origin,
+                             ContentSettingsType type) {
+    ContentSettingsForOneType session_settings =
+      content_settings->GetSettingsForOneType(
+          type, content_settings::mojom::SessionModel::USER_SESSION);
+
+    GURL url = origin.GetURL();
+    for (ContentSettingPatternSource& entry : session_settings) {
+      if (content_settings::IsConstraintSessionExpiration(entry,
+              content_settings::mojom::LifetimeMode::UNTIL_ORIGIN_CLOSED) &&
+          entry.primary_pattern.Matches(url)) {
+        content_settings->SetWebsiteSettingCustomScope(
+            entry.primary_pattern, entry.secondary_pattern,
+            type, base::Value());
+      }
+    }
+  }
+}
 
-OneTimePermissionsTracker::OneTimePermissionsTracker() = default;
+OneTimePermissionsTracker::OneTimePermissionsTracker(content::BrowserContext* context)
+    : context_(context) {}
 OneTimePermissionsTracker::~OneTimePermissionsTracker() = default;
 
 OneTimePermissionsTracker::OriginTrackEntry::OriginTrackEntry() = default;
@@ -254,6 +280,12 @@ void OneTimePermissionsTracker::NotifyLastPageFromOriginClosed(
   for (auto& observer : observer_list_) {
     observer.OnLastPageFromOriginClosed(origin);
   }
+  HostContentSettingsMap* content_settings =
+          permissions::PermissionsClient::Get()->GetSettingsMap(context_);
+  RemoveSessionSettings(content_settings, origin, ContentSettingsType::GEOLOCATION);
+  RemoveSessionSettings(content_settings, origin, ContentSettingsType::GEOLOCATION_WITH_OPTIONS);
+  RemoveSessionSettings(content_settings, origin, ContentSettingsType::MEDIASTREAM_MIC);
+  RemoveSessionSettings(content_settings, origin, ContentSettingsType::MEDIASTREAM_CAMERA);
 }
 
 bool OneTimePermissionsTracker::ShouldIgnoreOrigin(const url::Origin& origin) {
diff --git a/chrome/browser/permissions/one_time_permissions_tracker.h b/chrome/browser/permissions/one_time_permissions_tracker.h
--- a/chrome/browser/permissions/one_time_permissions_tracker.h
+++ b/chrome/browser/permissions/one_time_permissions_tracker.h
@@ -12,6 +12,7 @@
 #include "base/timer/timer.h"
 #include "chrome/browser/permissions/one_time_permissions_tracker_observer.h"
 #include "components/content_settings/core/common/content_settings_pattern.h"
+#include "chrome/browser/profiles/profile.h"
 #include "components/content_settings/core/common/content_settings_types.h"
 #include "components/keyed_service/core/keyed_service.h"
 #include "content/public/browser/visibility.h"
@@ -24,7 +25,7 @@ class OneTimePermissionsTracker : public KeyedService {
       void (OneTimePermissionsTracker::*)(const url::Origin&);
 
  public:
-  OneTimePermissionsTracker();
+  OneTimePermissionsTracker(content::BrowserContext* context);
   ~OneTimePermissionsTracker() override;
 
   OneTimePermissionsTracker(const OneTimePermissionsTracker&) = delete;
@@ -138,7 +139,7 @@ class OneTimePermissionsTracker : public KeyedService {
   base::ObserverList<OneTimePermissionsTrackerObserver> observer_list_;
 
   std::map<url::Origin, OriginTrackEntry> origin_tracker_;
-
+  raw_ptr<content::BrowserContext> context_;
   base::WeakPtrFactory<OneTimePermissionsTracker> weak_factory_{this};
 };
 
diff --git a/chrome/browser/permissions/one_time_permissions_tracker_factory.cc b/chrome/browser/permissions/one_time_permissions_tracker_factory.cc
--- a/chrome/browser/permissions/one_time_permissions_tracker_factory.cc
+++ b/chrome/browser/permissions/one_time_permissions_tracker_factory.cc
@@ -44,5 +44,5 @@ bool OneTimePermissionsTrackerFactory::ServiceIsCreatedWithBrowserContext()
 std::unique_ptr<KeyedService>
 OneTimePermissionsTrackerFactory::BuildServiceInstanceForBrowserContext(
     content::BrowserContext* context) const {
-  return std::make_unique<OneTimePermissionsTracker>();
+  return std::make_unique<OneTimePermissionsTracker>(context);
 }
diff --git a/chrome/browser/ui/views/permissions/chip/chip_controller.cc b/chrome/browser/ui/views/permissions/chip/chip_controller.cc
--- a/chrome/browser/ui/views/permissions/chip/chip_controller.cc
+++ b/chrome/browser/ui/views/permissions/chip/chip_controller.cc
@@ -228,7 +228,7 @@ void ChipController::OnWidgetDestroyed(views::Widget* widget) {
       active_chip_permission_request_manager_.value()->Accept();
       break;
     case permissions::PermissionAction::GRANTED_ONCE:
-      active_chip_permission_request_manager_.value()->AcceptThisTime();
+      active_chip_permission_request_manager_.value()->AcceptThisTime(content_settings::mojom::LifetimeMode::ONLY_THIS_TIME);
       break;
     case permissions::PermissionAction::DENIED:
       active_chip_permission_request_manager_.value()->Deny();
diff --git a/chrome/browser/ui/views/permissions/exclusive_access_permission_prompt_view.cc b/chrome/browser/ui/views/permissions/exclusive_access_permission_prompt_view.cc
--- a/chrome/browser/ui/views/permissions/exclusive_access_permission_prompt_view.cc
+++ b/chrome/browser/ui/views/permissions/exclusive_access_permission_prompt_view.cc
@@ -117,7 +117,7 @@ void ExclusiveAccessPermissionPromptView::RunButtonCallback(int button_id) {
       request_type(), GetPermissionActionString(button),
       record_browser_always_active_value());
   if (button == ButtonType::kAllowThisTime) {
-    delegate_->AcceptThisTime();
+    delegate_->AcceptThisTime(content_settings::mojom::LifetimeMode::ONLY_THIS_TIME);
   } else if (button == ButtonType::kAlwaysAllow) {
     delegate_->Accept();
   } else if (button == ButtonType::kNeverAllow) {
diff --git a/chrome/browser/ui/views/permissions/permission_prompt_bubble_base_view.cc b/chrome/browser/ui/views/permissions/permission_prompt_bubble_base_view.cc
--- a/chrome/browser/ui/views/permissions/permission_prompt_bubble_base_view.cc
+++ b/chrome/browser/ui/views/permissions/permission_prompt_bubble_base_view.cc
@@ -294,7 +294,7 @@ void PermissionPromptBubbleBaseView::RunButtonCallback(int button_id) {
       delegate_->Accept();
       return;
     case PermissionDialogButton::kAcceptOnce:
-      delegate_->AcceptThisTime();
+      delegate_->AcceptThisTime(content_settings::mojom::LifetimeMode::ONLY_THIS_TIME);
       return;
     case PermissionDialogButton::kDeny:
 #if BUILDFLAG(IS_CHROMEOS)
diff --git a/components/browser_ui/site_settings/android/java/src/org/chromium/components/browser_ui/site_settings/SingleWebsiteSettings.java b/components/browser_ui/site_settings/android/java/src/org/chromium/components/browser_ui/site_settings/SingleWebsiteSettings.java
--- a/components/browser_ui/site_settings/android/java/src/org/chromium/components/browser_ui/site_settings/SingleWebsiteSettings.java
+++ b/components/browser_ui/site_settings/android/java/src/org/chromium/components/browser_ui/site_settings/SingleWebsiteSettings.java
@@ -634,6 +634,11 @@ public class SingleWebsiteSettings extends BaseSiteSettingsFragment
     }
 
     @RequiresNonNull({"mSite"})
+    private boolean isSessionPermission(@ContentSettingsType.EnumType int type) {
+        return mSite.getPermissionInfo(type) != null &&
+               mSite.getPermissionInfo(type).getSessionModel() == SessionModel.USER_SESSION;
+    }
+
     private void setUpClearDataPreference() {
         ClearWebsiteStorage preference = findPreference(PREF_CLEAR_DATA);
         long usage = mSite.getTotalUsage();
@@ -1240,6 +1245,10 @@ public class SingleWebsiteSettings extends BaseSiteSettingsFragment
                                 .getDefaultColor());
             }
         }
+        if (preference instanceof ChromeSwitchPreference && isSessionPermission(contentType)) {
+            ((ChromeSwitchPreference)preference).setSummary(preference.getSummary() + " " +
+                getString(R.string.page_info_android_permission_session_permission));
+        }
     }
 
     /**
diff --git a/components/browser_ui/site_settings/android/website_preference_bridge.cc b/components/browser_ui/site_settings/android/website_preference_bridge.cc
--- a/components/browser_ui/site_settings/android/website_preference_bridge.cc
+++ b/components/browser_ui/site_settings/android/website_preference_bridge.cc
@@ -223,7 +223,7 @@ void GetOrigins(JNIEnv* env,
       seen_origins.push_back(origin);
       insertionFunc(env, static_cast<int>(content_type), list,
                     ConvertOriginToJavaString(env, origin), jembedder,
-                    /*is_embargoed=*/true, /*is_one_time=*/false);
+                    /*is_embargoed=*/true, 0);
     }
   }
 }
diff --git a/components/browser_ui/strings/android/browser_ui_strings.grd b/components/browser_ui/strings/android/browser_ui_strings.grd
--- a/components/browser_ui/strings/android/browser_ui_strings.grd
+++ b/components/browser_ui/strings/android/browser_ui_strings.grd
@@ -646,6 +646,11 @@
       <message name="IDS_PAGE_INFO_URL_TRUNCATED" desc="Accessibility announcement when the URL in PageInfo switches from full to truncated display">
         URL truncated
       </message>
+      <message name="IDS_PAGE_INFO_ANDROID_PERMISSION_SESSION_PERMISSION"
+               desc="The label used in the About Page dialog to indicate a session permission">
+        (only this session)
+      </message>
+
       <message name="IDS_PAGE_INFO_AD_PRIVACY_HEADER" desc="A label that represents the new ad-related settings. 1) Navigate to any site. 2) Click the icon (often a lock) to the left of the URL in the address bar. Information about the page you're viewing appears. The 'Ad privacy' label will appear above the 'Site settings' button.">
         Ad privacy
       </message>
diff --git a/components/content_settings/core/browser/content_settings_utils.cc b/components/content_settings/core/browser/content_settings_utils.cc
--- a/components/content_settings/core/browser/content_settings_utils.cc
+++ b/components/content_settings/core/browser/content_settings_utils.cc
@@ -182,6 +182,42 @@ bool IsConstraintPersistent(const ContentSettingConstraints& constraints) {
   return constraints.session_model() == mojom::SessionModel::DURABLE;
 }
 
+ContentSettingConstraints GetConstraintSessionExpiration(content_settings::mojom::LifetimeMode lifetime_mode) {
+  int lifetime;
+  base::Time now;
+  if (lifetime_mode == content_settings::mojom::LifetimeMode::ONLY_THIS_TIME) {
+    // note: this content settings will be discarded immediately
+    // 1h is used as a magic constant to identify the one-time lifetime mode
+    lifetime = 1;
+  } else if (lifetime_mode == content_settings::mojom::LifetimeMode::UNTIL_ORIGIN_CLOSED) {
+    now = base::Time::Now();
+    lifetime = 24;
+  } else {
+    lifetime = 0;
+  }
+  ContentSettingConstraints c(now);
+  c.set_lifetime(base::Hours(lifetime));
+  c.set_session_model(mojom::SessionModel::USER_SESSION);
+  return c;
+}
+
+bool IsConstraintSessionExpiration(const ContentSettingPatternSource& source,
+                                   content_settings::mojom::LifetimeMode lifetime_mode) {
+  if (source.metadata.session_model() != content_settings::mojom::SessionModel::USER_SESSION)
+    return false;
+
+  mojom::LifetimeMode type;
+  if (source.metadata.lifetime() == base::Hours(24)) {
+    type = content_settings::mojom::LifetimeMode::UNTIL_ORIGIN_CLOSED;
+  } else if (source.metadata.expiration() == (base::Time() + base::Hours(1))) {
+    type = content_settings::mojom::LifetimeMode::ONLY_THIS_TIME;
+  } else {
+    type = content_settings::mojom::LifetimeMode::UNTIL_BROWSER_CLOSED;
+  }
+
+  return lifetime_mode == type;
+}
+
 bool CanTrackLastVisit(ContentSettingsType type) {
   DCHECK(WebsiteSettingsRegistry::GetInstance()->Get(type)) << type;
 
@@ -273,10 +309,6 @@ const std::vector<ContentSettingsType>& GetTypesWithTemporaryGrants() {
       ContentSettingsType::CAPTURED_SURFACE_CONTROL,
 #endif
       ContentSettingsType::KEYBOARD_LOCK,
-      ContentSettingsType::GEOLOCATION,
-      ContentSettingsType::GEOLOCATION_WITH_OPTIONS,
-      ContentSettingsType::MEDIASTREAM_MIC,
-      ContentSettingsType::MEDIASTREAM_CAMERA,
       ContentSettingsType::HAND_TRACKING,
       ContentSettingsType::SMART_CARD_DATA,
       ContentSettingsType::AR,
@@ -292,10 +324,6 @@ const std::vector<ContentSettingsType>& GetTypesWithTemporaryGrantsInHcsm() {
       ContentSettingsType::CAPTURED_SURFACE_CONTROL,
 #endif
       ContentSettingsType::KEYBOARD_LOCK,
-      ContentSettingsType::GEOLOCATION,
-      ContentSettingsType::GEOLOCATION_WITH_OPTIONS,
-      ContentSettingsType::MEDIASTREAM_MIC,
-      ContentSettingsType::MEDIASTREAM_CAMERA,
       ContentSettingsType::HAND_TRACKING,
       ContentSettingsType::AR,
       ContentSettingsType::VR,
diff --git a/components/content_settings/core/browser/content_settings_utils.h b/components/content_settings/core/browser/content_settings_utils.h
--- a/components/content_settings/core/browser/content_settings_utils.h
+++ b/components/content_settings/core/browser/content_settings_utils.h
@@ -78,6 +78,12 @@ bool IsConstraintPersistent(const ContentSettingConstraints& constraints);
 // Returns whether the given type supports tracking last_visit timestamps.
 bool CanTrackLastVisit(ContentSettingsType type);
 
+ContentSettingConstraints GetConstraintSessionExpiration(mojom::LifetimeMode lifetime_mode);
+
+bool IsConstraintSessionExpiration(
+    const ContentSettingPatternSource& source,
+    mojom::LifetimeMode lifetime_mode);
+
 // Get a timestamp with week-precision.
 base::Time GetCoarseVisitedTime(base::Time time);
 
diff --git a/components/content_settings/core/common/content_settings_enums.mojom b/components/content_settings/core/common/content_settings_enums.mojom
--- a/components/content_settings/core/common/content_settings_enums.mojom
+++ b/components/content_settings/core/common/content_settings_enums.mojom
@@ -63,6 +63,15 @@ enum SessionModel {
   ONE_TIME = 3,
 };
 
+// GENERATED_JAVA_ENUM_PACKAGE: org.chromium.components.content_settings
+// GENERATED_JAVA_CLASS_NAME_OVERRIDE: LifetimeMode
+enum LifetimeMode {
+  ALWAYS = 99,
+  ONLY_THIS_TIME = 1,
+  UNTIL_ORIGIN_CLOSED = 2,
+  UNTIL_BROWSER_CLOSED = 0,
+};
+
 // Identifies the content settings provider of a content setting.
 // GENERATED_JAVA_ENUM_PACKAGE: org.chromium.components.content_settings
 // GENERATED_JAVA_CLASS_NAME_OVERRIDE: ProviderType
diff --git a/components/page_info/android/java/src/org/chromium/components/page_info/PageInfoController.java b/components/page_info/android/java/src/org/chromium/components/page_info/PageInfoController.java
--- a/components/page_info/android/java/src/org/chromium/components/page_info/PageInfoController.java
+++ b/components/page_info/android/java/src/org/chromium/components/page_info/PageInfoController.java
@@ -374,8 +374,8 @@ public class PageInfoController
      */
     @CalledByNative
     private void addPermissionSection(
-            String name, String nameMidSentence, int type, boolean allowed) {
-        mPermissionParamsListBuilder.addPermissionEntry(name, nameMidSentence, type, allowed);
+            String name, String nameMidSentence, int type, boolean allowed, boolean is_user_session) {
+        mPermissionParamsListBuilder.addPermissionEntry(name, nameMidSentence, type, allowed, is_user_session);
     }
 
     /** Update the permissions view based on the contents of mDisplayedPermissions. */
diff --git a/components/page_info/android/java/src/org/chromium/components/page_info/PermissionParamsListBuilder.java b/components/page_info/android/java/src/org/chromium/components/page_info/PermissionParamsListBuilder.java
--- a/components/page_info/android/java/src/org/chromium/components/page_info/PermissionParamsListBuilder.java
+++ b/components/page_info/android/java/src/org/chromium/components/page_info/PermissionParamsListBuilder.java
@@ -46,8 +46,9 @@ public class PermissionParamsListBuilder {
         mEntries = new ArrayList<>();
     }
 
-    public void addPermissionEntry(String name, String nameMidSentence, int type, boolean allowed) {
-        mEntries.add(new PageInfoPermissionEntry(name, nameMidSentence, type, allowed));
+    public void addPermissionEntry(String name, String nameMidSentence, int type, boolean allowed,
+            boolean is_user_session) {
+        mEntries.add(new PageInfoPermissionEntry(name, nameMidSentence, type, allowed, is_user_session));
     }
 
     public void clearPermissionEntries() {
@@ -84,6 +85,10 @@ public class PermissionParamsListBuilder {
                 } else {
                     warningTextResource = R.string.page_info_android_permission_blocked;
                 }
+                if (permission.is_user_session) {
+                    warningTextResource =
+                            R.string.page_info_android_permission_session_permission;
+                }
             }
         }
 
@@ -112,12 +117,14 @@ public class PermissionParamsListBuilder {
         public final String nameMidSentence;
         public final int type;
         public final boolean allowed;
+        public final boolean is_user_session;
 
-        PageInfoPermissionEntry(String name, String nameMidSentence, int type, boolean allowed) {
+        PageInfoPermissionEntry(String name, String nameMidSentence, int type, boolean allowed, boolean is_user_session) {
             this.name = name;
             this.nameMidSentence = nameMidSentence;
             this.type = type;
             this.allowed = allowed;
+            this.is_user_session = is_user_session;
         }
 
         @Override
diff --git a/components/page_info/android/page_info_controller_android.cc b/components/page_info/android/page_info_controller_android.cc
--- a/components/page_info/android/page_info_controller_android.cc
+++ b/components/page_info/android/page_info_controller_android.cc
@@ -199,6 +199,8 @@ void PageInfoControllerAndroid::SetPermissionInfo(
 
   std::map<ContentSettingsType, /*allowed*/ bool>
       user_specified_settings_to_display;
+  std::map<ContentSettingsType, bool>
+      user_specified_settings_is_user_session;
 
   for (const auto& permission : permission_info_list) {
     if (base::Contains(permissions_to_display, permission.type)) {
@@ -211,6 +213,8 @@ void PageInfoControllerAndroid::SetPermissionInfo(
 
         user_specified_settings_to_display[permission.type] =
             info->delegate().IsAnyPermissionAllowed(*setting_to_display);
+        user_specified_settings_is_user_session[permission.type] =
+            permission.is_user_session;
       }
     }
   }
@@ -227,7 +231,8 @@ void PageInfoControllerAndroid::SetPermissionInfo(
           ConvertUTF16ToJavaString(env, setting_title),
           ConvertUTF16ToJavaString(env, setting_title_mid_sentence),
           static_cast<jint>(permission),
-          user_specified_settings_to_display[permission]);
+          user_specified_settings_to_display[permission],
+          user_specified_settings_is_user_session[permission]);
     }
   }
 
@@ -240,7 +245,8 @@ void PageInfoControllerAndroid::SetPermissionInfo(
         env, controller_jobject_, ConvertUTF16ToJavaString(env, object_title),
         ConvertUTF16ToJavaString(env, object_title),
         static_cast<jint>(chosen_object->ui_info->content_settings_type),
-        static_cast<jint>(CONTENT_SETTING_ALLOW));
+        static_cast<jint>(CONTENT_SETTING_ALLOW),
+        /* is_user_session */ false);
   }
 
   Java_PageInfoController_updatePermissionDisplay(env, controller_jobject_);
diff --git a/components/page_info/page_info.cc b/components/page_info/page_info.cc
--- a/components/page_info/page_info.cc
+++ b/components/page_info/page_info.cc
@@ -1293,6 +1293,8 @@ void PageInfo::PopulatePermissionInfo(PermissionInfo& permission_info,
   permission_info.is_one_time =
       (info.metadata.session_model() ==
        content_settings::mojom::SessionModel::ONE_TIME);
+  permission_info.is_user_session =
+      (info.metadata.session_model() == content_settings::mojom::SessionModel::USER_SESSION);
 
   auto* setting_info =
       content_settings::PermissionSettingsRegistry::GetInstance()->Get(
diff --git a/components/page_info/page_info.h b/components/page_info/page_info.h
--- a/components/page_info/page_info.h
+++ b/components/page_info/page_info.h
@@ -151,6 +151,7 @@ class PageInfo : private content_settings::CookieControlsObserver,
         content_settings::SettingSource::kNone;
     // Whether the permission is a one-time grant.
     bool is_one_time = false;
+    bool is_user_session = false;
     // Only set for settings that can have multiple permissions for different
     // embedded origins.
     std::optional<url::Origin> requesting_origin;
diff --git a/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogDelegate.java b/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogDelegate.java
--- a/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogDelegate.java
+++ b/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogDelegate.java
@@ -16,6 +16,7 @@ import org.jni_zero.NativeMethods;
 import org.chromium.build.annotations.NullMarked;
 import org.chromium.build.annotations.Nullable;
 import org.chromium.ui.base.WindowAndroid;
+import org.chromium.components.content_settings.LifetimeMode;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -67,6 +68,9 @@ public class PermissionDialogDelegate {
     // Prompt(screen) variant we want to display on the dialog.
     private @EmbeddedPromptVariant int mEmbeddedPromptVariant;
 
+    /** Lifetime option selected by the user. */
+    private int mSelectedLifetimeOption = LifetimeMode.ALWAYS;
+
     /**
      * Defines a (potentially empty) list of ranges represented as pairs of <startIndex, endIndex>,
      * which shall be used by the UI to format the specified ranges as bold text.
@@ -139,6 +143,15 @@ public class PermissionDialogDelegate {
         PermissionDialogDelegateJni.get().acceptThisTime(mNativeDelegatePtr);
     }
 
+    public void setSelectedLifetimeOption(int idx) {
+        mSelectedLifetimeOption = idx;
+    }
+
+    @CalledByNative
+    public int getSelectedLifetimeOption() {
+        return mSelectedLifetimeOption;
+    }
+
     public void onDeny() {
         assert mNativeDelegatePtr != 0;
         PermissionDialogDelegateJni.get().deny(mNativeDelegatePtr);
diff --git a/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogModelFactory.java b/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogModelFactory.java
--- a/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogModelFactory.java
+++ b/components/permissions/android/java/src/org/chromium/components/permissions/PermissionDialogModelFactory.java
@@ -13,6 +13,18 @@ import org.chromium.ui.UiUtils;
 import org.chromium.ui.modaldialog.ModalDialogProperties;
 import org.chromium.ui.modelutil.PropertyModel;
 
+import java.util.Arrays;
+import java.util.List;
+import android.view.ViewGroup.LayoutParams;
+import android.widget.LinearLayout;
+import android.widget.RadioButton;
+import android.widget.RadioGroup;
+import android.widget.TextView;
+import org.chromium.base.ApiCompatibilityUtils;
+import org.chromium.ui.base.ViewUtils;
+import org.chromium.components.content_settings.ContentSettingsType;
+import org.chromium.components.content_settings.LifetimeMode;
+
 /** This class creates the model for the permission dialog. */
 @NullMarked
 class PermissionDialogModelFactory {
@@ -67,7 +79,76 @@ class PermissionDialogModelFactory {
                             ModalDialogProperties.ButtonStyles.PRIMARY_FILLED_NEGATIVE_OUTLINE)
                     .with(ModalDialogProperties.CHANGE_CUSTOM_VIEW_OR_BUTTONS, true);
         }
-        return builder.build();
+
+        PropertyModel pm = builder.build();
+        int[] types = delegate.getContentSettingsTypes();
+        if (contains(types, ContentSettingsType.GEOLOCATION) ||
+            contains(types, ContentSettingsType.GEOLOCATION_WITH_OPTIONS) ||
+            contains(types, ContentSettingsType.MEDIASTREAM_MIC) ||
+            contains(types, ContentSettingsType.MEDIASTREAM_CAMERA))
+        {
+            LinearLayout layout = (LinearLayout) customView;
+
+            // Create a text label before the lifetime selector.
+            TextView lifetimeOptionsText = new TextView(context);
+            lifetimeOptionsText.setText(context.getString(
+                        org.chromium.components.permissions.R.string.session_permissions_title));
+            lifetimeOptionsText.setTextAppearance(
+                    lifetimeOptionsText.getContext(), R.style.TextAppearance_TextMedium_Primary);
+
+            LinearLayout.LayoutParams lifetimeOptionsTextLayoutParams =
+                    new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
+            lifetimeOptionsTextLayoutParams.setMargins(0, 0, 0, ViewUtils.dpToPx(context, 8));
+            lifetimeOptionsText.setLayoutParams(lifetimeOptionsTextLayoutParams);
+            layout.addView(lifetimeOptionsText);
+
+            // Create radio buttons with lifetime options.
+            RadioGroup radioGroup = new RadioGroup(context);
+
+            RadioButton radioButton = new RadioButton(context);
+            radioButton.setText(context.getString(
+                        org.chromium.components.permissions.R.string.session_permissions_only_this_this));
+            radioButton.setId(LifetimeMode.ONLY_THIS_TIME);
+            radioGroup.addView(radioButton);
+
+            radioButton = new RadioButton(context);
+            radioButton.setText(context.getString(
+                        org.chromium.components.permissions.R.string.session_permissions_until_page_close));
+            radioButton.setId(LifetimeMode.UNTIL_ORIGIN_CLOSED);
+            radioGroup.addView(radioButton);
+
+            radioButton = new RadioButton(context);
+            radioButton.setText(context.getString(
+                        org.chromium.components.permissions.R.string.session_permissions_until_browser_close));
+            radioButton.setId(LifetimeMode.UNTIL_BROWSER_CLOSED);
+            radioGroup.addView(radioButton);
+
+            radioButton = new RadioButton(context);
+            radioButton.setText(context.getString(
+                        org.chromium.components.permissions.R.string.session_permissions_forever));
+            radioButton.setId(LifetimeMode.ALWAYS);
+            radioGroup.addView(radioButton);
+
+            radioGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {
+                @Override
+                public void onCheckedChanged(RadioGroup group, int checkedId) {
+                    delegate.setSelectedLifetimeOption(checkedId);
+                }
+            });
+            radioGroup.check(1);
+            layout.addView(radioGroup);
+        }
+
+        return pm;
+    }
+
+    private static boolean contains(final int[] array, final int key) {
+        int length = array.length;
+        for(int i = 0; i < length; i++) {
+            if (array[i] == key)
+                return true;
+        }
+        return false;
     }
 
     public static ModalDialogProperties.ModalDialogButtonSpec[] getButtonSpecs(
diff --git a/components/permissions/android/permission_prompt/embedded_permission_prompt_android.cc b/components/permissions/android/permission_prompt/embedded_permission_prompt_android.cc
--- a/components/permissions/android/permission_prompt/embedded_permission_prompt_android.cc
+++ b/components/permissions/android/permission_prompt/embedded_permission_prompt_android.cc
@@ -118,7 +118,8 @@ void EmbeddedPermissionPromptAndroid::Acknowledge() {
   delegate()->FinalizeCurrentRequests();
 }
 
-void EmbeddedPermissionPromptAndroid::AcceptThisTime() {
+void EmbeddedPermissionPromptAndroid::AcceptThisTime(
+        content_settings::mojom::LifetimeMode lifetimeOption) {
   prompt_model_->PrecalculateVariantsForMetrics();
   prompt_model_->RecordPermissionActionUKM(
       permissions::ElementAnchoredBubbleAction::kGrantedOnce);
diff --git a/components/permissions/android/permission_prompt/embedded_permission_prompt_android.h b/components/permissions/android/permission_prompt/embedded_permission_prompt_android.h
--- a/components/permissions/android/permission_prompt/embedded_permission_prompt_android.h
+++ b/components/permissions/android/permission_prompt/embedded_permission_prompt_android.h
@@ -45,7 +45,7 @@ class EmbeddedPermissionPromptAndroid : public PermissionPromptAndroid {
       const override;
   void Closing() override;
   void Accept() override;
-  void AcceptThisTime() override;
+  void AcceptThisTime(content_settings::mojom::LifetimeMode lifetimeOption) override;
   void Acknowledge() override;
   void Deny() override;
   void Resumed() override;
diff --git a/components/permissions/android/permission_prompt/permission_dialog_delegate.cc b/components/permissions/android/permission_prompt/permission_dialog_delegate.cc
--- a/components/permissions/android/permission_prompt/permission_dialog_delegate.cc
+++ b/components/permissions/android/permission_prompt/permission_dialog_delegate.cc
@@ -137,6 +137,11 @@ void PermissionDialogJavaDelegate::UpdateDialog() {
       static_cast<int>(permission_prompt_->GetEmbeddedPromptVariant()));
 }
 
+int PermissionDialogJavaDelegate::GetSelectedLifetimeOption() {
+  JNIEnv* env = base::android::AttachCurrentThread();
+  return Java_PermissionDialogDelegate_getSelectedLifetimeOption(env, j_delegate_);
+}
+
 // static
 std::unique_ptr<PermissionDialogDelegate> PermissionDialogDelegate::Create(
     content::WebContents* web_contents,
@@ -165,12 +170,22 @@ PermissionDialogDelegate::CreateForTesting(
 
 void PermissionDialogDelegate::Accept(JNIEnv* env) {
   CHECK(permission_prompt_);
+  content_settings::mojom::LifetimeMode lifetimeOption =
+    static_cast<content_settings::mojom::LifetimeMode>(
+      java_delegate_->GetSelectedLifetimeOption());
+  if (lifetimeOption != content_settings::mojom::LifetimeMode::ALWAYS) {
+    permission_prompt_->AcceptThisTime(lifetimeOption);
+    return;
+  }
   permission_prompt_->Accept();
 }
 
 void PermissionDialogDelegate::AcceptThisTime(JNIEnv* env) {
   CHECK(permission_prompt_);
-  permission_prompt_->AcceptThisTime();
+  content_settings::mojom::LifetimeMode lifetimeOption =
+    static_cast<content_settings::mojom::LifetimeMode>(
+      java_delegate_->GetSelectedLifetimeOption());
+  permission_prompt_->AcceptThisTime(lifetimeOption);
 }
 
 void PermissionDialogDelegate::Acknowledge(JNIEnv* env) {
@@ -180,6 +195,13 @@ void PermissionDialogDelegate::Acknowledge(JNIEnv* env) {
 
 void PermissionDialogDelegate::Deny(JNIEnv* env) {
   CHECK(permission_prompt_);
+  content_settings::mojom::LifetimeMode lifetimeOption =
+    static_cast<content_settings::mojom::LifetimeMode>(
+      java_delegate_->GetSelectedLifetimeOption());
+  if (lifetimeOption != content_settings::mojom::LifetimeMode::ALWAYS) {
+    permission_prompt_->DenyThisTime(lifetimeOption);
+    return;
+  }
   permission_prompt_->Deny();
 }
 
diff --git a/components/permissions/android/permission_prompt/permission_dialog_delegate.h b/components/permissions/android/permission_prompt/permission_dialog_delegate.h
--- a/components/permissions/android/permission_prompt/permission_dialog_delegate.h
+++ b/components/permissions/android/permission_prompt/permission_dialog_delegate.h
@@ -42,6 +42,7 @@ class PermissionDialogJavaDelegate {
       const favicon_base::FaviconRawBitmapResult& favicon_result);
 
   virtual void DismissDialog();
+  virtual int GetSelectedLifetimeOption();
 
   virtual void UpdateDialog();
 
diff --git a/components/permissions/android/permission_prompt/permission_prompt_android.cc b/components/permissions/android/permission_prompt/permission_prompt_android.cc
--- a/components/permissions/android/permission_prompt/permission_prompt_android.cc
+++ b/components/permissions/android/permission_prompt/permission_prompt_android.cc
@@ -85,8 +85,12 @@ void PermissionPromptAndroid::Accept() {
   delegate_->Accept();
 }
 
-void PermissionPromptAndroid::AcceptThisTime() {
-  delegate_->AcceptThisTime();
+void PermissionPromptAndroid::AcceptThisTime(content_settings::mojom::LifetimeMode lifetimeOption) {
+  delegate_->AcceptThisTime(lifetimeOption);
+}
+
+void PermissionPromptAndroid::DenyThisTime(content_settings::mojom::LifetimeMode lifetimeOption) {
+  delegate_->DenyThisTime(lifetimeOption);
 }
 
 void PermissionPromptAndroid::Deny() {
diff --git a/components/permissions/android/permission_prompt/permission_prompt_android.h b/components/permissions/android/permission_prompt/permission_prompt_android.h
--- a/components/permissions/android/permission_prompt/permission_prompt_android.h
+++ b/components/permissions/android/permission_prompt/permission_prompt_android.h
@@ -56,9 +56,10 @@ class PermissionPromptAndroid : public PermissionPrompt {
       const;
   virtual void Closing();
   virtual void Accept();
-  virtual void AcceptThisTime();
+  virtual void AcceptThisTime(content_settings::mojom::LifetimeMode lifetimeOption);
   virtual void Acknowledge() {}
   virtual void Deny();
+  virtual void DenyThisTime(content_settings::mojom::LifetimeMode lifetimeOption);
   virtual void Resumed() {}
   virtual void SystemSettingsShown() {}
   virtual void SystemPermissionResolved(bool accepted) {}
diff --git a/components/permissions/android/permissions_android_strings.grd b/components/permissions/android/permissions_android_strings.grd
--- a/components/permissions/android/permissions_android_strings.grd
+++ b/components/permissions/android/permissions_android_strings.grd
@@ -267,6 +267,23 @@
         Unknown or unsupported device (<ph name="DEVICE_ID">%1$s<ex>A1:B2:C3:D4:E5:F6</ex></ph>)
       </message>
 
+      <!-- Session permissions -->
+      <message name="IDS_SESSION_PERMISSIONS_TITLE" desc="Title for the session section in the permission request">
+        Remember my decision
+      </message>
+      <message name="IDS_SESSION_PERMISSIONS_ONLY_THIS_THIS" desc="Message indicating that the permission is only for this time">
+        Only this time
+      </message>
+      <message name="IDS_SESSION_PERMISSIONS_UNTIL_PAGE_CLOSE" desc="Message indicating that the permission is deleted after navigating away from the page">
+        Until all pages of this origin are closed
+      </message>
+      <message name="IDS_SESSION_PERMISSIONS_UNTIL_BROWSER_CLOSE" desc="Message indicating that the permission is for the session only">
+        Until Bromite is closed
+      </message>
+      <message name="IDS_SESSION_PERMISSIONS_FOREVER" desc="Message indicating that the permission is for all sessions">
+        Forever
+      </message>
+
       <!-- Item Chooser UI strings -->
       <message name="IDS_ITEM_CHOOSER_ITEM_NAME_WITH_ID" desc="To distinguish items with the same name, the item chooser shows the item name with id.">
         <ph name="ITEM_NAME">%1$s<ex>item_name</ex></ph> (<ph name="ITEM_ID">%2$s<ex>item id</ex></ph>)
diff --git a/components/permissions/contexts/geolocation_permission_context_android.cc b/components/permissions/contexts/geolocation_permission_context_android.cc
--- a/components/permissions/contexts/geolocation_permission_context_android.cc
+++ b/components/permissions/contexts/geolocation_permission_context_android.cc
@@ -194,7 +194,18 @@ void GeolocationPermissionContextAndroid::NotifyPermissionSet(
     PermissionDecision decision,
     bool is_final_decision) {
   DCHECK(is_final_decision);
+  NotifyPermissionSetWithLifetime(request_data,
+    std::move(callback), persist, decision, is_final_decision,
+    content_settings::mojom::LifetimeMode::ALWAYS);
+}
 
+void GeolocationPermissionContextAndroid::NotifyPermissionSetWithLifetime(
+    const PermissionRequestData& request_data,
+    BrowserPermissionCallback callback,
+    bool persist,
+    PermissionDecision decision,
+    bool is_final_decision,
+    content_settings::mojom::LifetimeMode lifetime_option) {
   bool is_default_search =
       IsRequestingOriginDSE(request_data.requesting_origin);
   if (decision == PermissionDecision::kAllow &&
@@ -209,7 +220,7 @@ void GeolocationPermissionContextAndroid::NotifyPermissionSet(
       FinishNotifyPermissionSet(request_data.id, request_data.requesting_origin,
                                 request_data.embedding_origin,
                                 std::move(callback), false /* persist */,
-                                PermissionDecision::kDeny,
+                                PermissionDecision::kDeny, lifetime_option,
                                 request_data.prompt_options);
       return;
     }
@@ -230,7 +241,7 @@ void GeolocationPermissionContextAndroid::NotifyPermissionSet(
       FinishNotifyPermissionSet(request_data.id, request_data.requesting_origin,
                                 request_data.embedding_origin,
                                 std::move(callback), false /* persist */,
-                                PermissionDecision::kDeny,
+                                PermissionDecision::kDeny, lifetime_option,
                                 request_data.prompt_options);
       return;
     }
@@ -243,14 +254,14 @@ void GeolocationPermissionContextAndroid::NotifyPermissionSet(
         base::BindOnce(
             &GeolocationPermissionContextAndroid::OnLocationSettingsDialogShown,
             weak_factory_.GetWeakPtr(), request_data.requesting_origin,
-            request_data.embedding_origin, persist, decision,
+            request_data.embedding_origin, persist, decision, lifetime_option,
             request_data.prompt_options));
     return;
   }
 
   FinishNotifyPermissionSet(request_data.id, request_data.requesting_origin,
                             request_data.embedding_origin, std::move(callback),
-                            persist, decision, request_data.prompt_options);
+                            persist, decision, lifetime_option, request_data.prompt_options);
 }
 
 content::PermissionResult
@@ -427,7 +438,7 @@ void GeolocationPermissionContextAndroid::OnLocationSettingsDialogShown(
     const GURL& requesting_origin,
     const GURL& embedding_origin,
     bool persist,
-    PermissionDecision decision,
+    PermissionDecision decision, content_settings::mojom::LifetimeMode lifetime_option,
     std::optional<PromptOptions> prompt_options,
     LocationSettingsDialogOutcome prompt_outcome) {
   bool is_default_search = IsRequestingOriginDSE(requesting_origin);
@@ -447,7 +458,7 @@ void GeolocationPermissionContextAndroid::OnLocationSettingsDialogShown(
   FinishNotifyPermissionSet(location_settings_dialog_request_id_,
                             requesting_origin, embedding_origin,
                             std::move(location_settings_dialog_callback_),
-                            persist, decision, prompt_options);
+                            persist, decision, lifetime_option, prompt_options);
 
   location_settings_dialog_request_id_ =
       PermissionRequestID(content::GlobalRenderFrameHostId(0, 0),
@@ -460,7 +471,7 @@ void GeolocationPermissionContextAndroid::FinishNotifyPermissionSet(
     const GURL& embedding_origin,
     BrowserPermissionCallback callback,
     bool persist,
-    PermissionDecision decision,
+    PermissionDecision decision, content_settings::mojom::LifetimeMode lifetime_option,
     std::optional<PromptOptions> prompt_options) {
   PermissionRequestData request_data(
       this, id,
@@ -469,9 +480,10 @@ void GeolocationPermissionContextAndroid::FinishNotifyPermissionSet(
               blink::PermissionType::GEOLOCATION)),
       requesting_origin, embedding_origin);
   request_data.prompt_options = prompt_options.value_or(std::monostate());
-  GeolocationPermissionContext::NotifyPermissionSet(
+  GeolocationPermissionContext::NotifyPermissionSetImpl(
      request_data,
-      std::move(callback), persist, decision, /*is_final_decision=*/true);
+      std::move(callback), persist, decision, /*is_final_decision=*/true,
+      /*use_lifetime_option*/ true, lifetime_option);
 }
 
 void GeolocationPermissionContextAndroid::SetLocationSettingsForTesting(
diff --git a/components/permissions/contexts/geolocation_permission_context_android.h b/components/permissions/contexts/geolocation_permission_context_android.h
--- a/components/permissions/contexts/geolocation_permission_context_android.h
+++ b/components/permissions/contexts/geolocation_permission_context_android.h
@@ -92,6 +92,12 @@ class GeolocationPermissionContextAndroid
                            bool persist,
                            PermissionDecision decision,
                            bool is_final_decision) override;
+  void NotifyPermissionSetWithLifetime(const PermissionRequestData& request_data,
+                           BrowserPermissionCallback callback,
+                           bool persist,
+                           PermissionDecision decision,
+                           bool is_final_decision,
+                           content_settings::mojom::LifetimeMode lifetime_option) override;
   content::PermissionResult UpdatePermissionStatusWithDeviceStatus(
       content::WebContents* web_contents,
       content::PermissionResult result,
@@ -136,6 +142,7 @@ class GeolocationPermissionContextAndroid
       const GURL& embedding_origin,
       bool persist,
       PermissionDecision decision,
+      content_settings::mojom::LifetimeMode lifetime_option,
       std::optional<PromptOptions> prompt_options,
       LocationSettingsDialogOutcome prompt_outcome);
 
@@ -145,6 +152,7 @@ class GeolocationPermissionContextAndroid
                                  BrowserPermissionCallback callback,
                                  bool persist,
                                  PermissionDecision decision,
+                                 content_settings::mojom::LifetimeMode lifetime_option,
                                  std::optional<PromptOptions> prompt_options);
 
   std::unique_ptr<LocationSettings> location_settings_;
diff --git a/components/permissions/embedded_permission_prompt_flow_model.cc b/components/permissions/embedded_permission_prompt_flow_model.cc
--- a/components/permissions/embedded_permission_prompt_flow_model.cc
+++ b/components/permissions/embedded_permission_prompt_flow_model.cc
@@ -294,7 +294,7 @@ void EmbeddedPermissionPromptFlowModel::SetDelegateAction(
       delegate_->Accept();
       break;
     case DelegateAction::kAllowThisTime:
-      delegate_->AcceptThisTime();
+      delegate_->AcceptThisTime(content_settings::mojom::LifetimeMode::ONLY_THIS_TIME);
       break;
     case DelegateAction::kDeny:
       delegate_->Deny();
diff --git a/components/permissions/permission_context_base.cc b/components/permissions/permission_context_base.cc
--- a/components/permissions/permission_context_base.cc
+++ b/components/permissions/permission_context_base.cc
@@ -267,6 +267,17 @@ PermissionContextBase::CreatePermissionRequest(
       std::move(request_finished_callback), UsesAutomaticEmbargo());
 }
 
+std::unique_ptr<PermissionRequest>
+PermissionContextBase::CreatePermissionRequest(
+    content::WebContents* web_contents,
+    std::unique_ptr<PermissionRequestData> request_data,
+    PermissionRequest::PermissionDecidedCallbackWithLifetime permission_decided_callback,
+    base::OnceClosure request_finished_callback) const {
+  return std::make_unique<PermissionRequest>(
+      std::move(request_data), std::move(permission_decided_callback),
+      std::move(request_finished_callback), UsesAutomaticEmbargo());
+}
+
 bool PermissionContextBase::UsesAutomaticEmbargo() const {
   return true;
 }
@@ -571,7 +582,8 @@ void PermissionContextBase::DecidePermission(
 void PermissionContextBase::PermissionDecided(
     PermissionDecision decision,
     bool is_final_decision,
-    const PermissionRequestData& request_data) {
+    const PermissionRequestData& request_data,
+    content_settings::mojom::LifetimeMode lifetime_option) {
   UserMadePermissionDecision(request_data.id, request_data.requesting_origin,
                              request_data.embedding_origin, decision);
 
@@ -584,11 +596,12 @@ void PermissionContextBase::PermissionDecided(
   // missing if a permission prompt was preignored and we already notified an
   // origin about it.
   if (request->second.second) {
-    NotifyPermissionSet(request_data, std::move(request->second.second),
-                        persist, decision, is_final_decision);
+    NotifyPermissionSetWithLifetime(request_data, std::move(request->second.second),
+                        persist, decision, is_final_decision,
+                        lifetime_option);
   } else {
-    NotifyPermissionSet(request_data, base::DoNothing(), persist, decision,
-                        is_final_decision);
+    NotifyPermissionSetWithLifetime(request_data, base::DoNothing(), persist, decision,
+                        is_final_decision, lifetime_option);
   }
 }
 
@@ -673,6 +686,30 @@ void PermissionContextBase::NotifyPermissionSet(
     bool persist,
     PermissionDecision decision,
     bool is_final_decision) {
+  NotifyPermissionSetImpl(request_data, std::move(callback),
+     persist, decision, is_final_decision, /*use_lifetime_option*/ false,
+     content_settings::mojom::LifetimeMode::ALWAYS);
+}
+
+void PermissionContextBase::NotifyPermissionSetWithLifetime(
+    const PermissionRequestData& request_data,
+    BrowserPermissionCallback callback,
+    bool persist,
+    PermissionDecision decision,
+    bool is_final_decision,
+    content_settings::mojom::LifetimeMode lifetime_option) {
+  NotifyPermissionSetImpl(request_data, std::move(callback),
+     persist, decision, is_final_decision, /*use_lifetime_option*/ true,
+     lifetime_option);
+}
+
+void PermissionContextBase::NotifyPermissionSetImpl(
+    const PermissionRequestData& request_data,
+    BrowserPermissionCallback callback,
+    bool persist,
+    PermissionDecision decision,
+    bool is_final_decision, bool use_lifetime_option,
+    content_settings::mojom::LifetimeMode lifetime_option) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   // Note that rfh may be null, see crbug.com/426909787.
@@ -688,8 +725,8 @@ void PermissionContextBase::NotifyPermissionSet(
 
   if (persist) {
     // Clone new value, because we need it again for the callback.
-    UpdateSetting(request_data, new_value,
-                  decision == PermissionDecision::kAllowThisTime);
+    UpdateSettingImpl(request_data, new_value,
+                  decision == PermissionDecision::kAllowThisTime, use_lifetime_option, lifetime_option);
   }
 
   if (is_final_decision) {
@@ -727,6 +764,17 @@ void PermissionContextBase::UpdateSetting(
     const PermissionRequestData& request_data,
     PermissionSetting setting,
     bool is_one_time) {
+  UpdateSettingImpl(request_data, std::move(setting),
+    is_one_time,
+    /*use_lifetime_option*/ false,
+    content_settings::mojom::LifetimeMode::ALWAYS);
+}
+
+void PermissionContextBase::UpdateSettingImpl(const PermissionRequestData& request_data,
+                                              PermissionSetting setting,
+                                              bool is_one_time,
+                                              bool use_lifetime_option,
+                                              content_settings::mojom::LifetimeMode lifetime_option) {
   DCHECK_EQ(request_data.requesting_origin,
             request_data.requesting_origin.DeprecatedGetOriginAsURL());
   DCHECK_EQ(request_data.embedding_origin,
@@ -736,6 +784,8 @@ void PermissionContextBase::UpdateSetting(
   constraints.set_session_model(
       is_one_time ? content_settings::mojom::SessionModel::ONE_TIME
                   : content_settings::mojom::SessionModel::DURABLE);
+  if (use_lifetime_option)
+    constraints = content_settings::GetConstraintSessionExpiration(lifetime_option);
 
   // The unused permissions module in Safety check will revoke unused site
   // permissions after a finite amount of time if the permission can be revoked.
diff --git a/components/permissions/permission_context_base.h b/components/permissions/permission_context_base.h
--- a/components/permissions/permission_context_base.h
+++ b/components/permissions/permission_context_base.h
@@ -192,6 +192,18 @@ class PermissionContextBase : public content_settings::Observer {
 
   // Updates stored setting if persist is set, updates tab indicators
   // and runs the callback to finish the request.
+  void NotifyPermissionSetImpl(const PermissionRequestData& request_data,
+                               BrowserPermissionCallback callback,
+                               bool persist,
+                               PermissionDecision decision,
+                               bool is_final_decision, bool use_lifetime_option,
+                               content_settings::mojom::LifetimeMode lifetime_option);
+  virtual void NotifyPermissionSetWithLifetime(const PermissionRequestData& request_data,
+                                               BrowserPermissionCallback callback,
+                                               bool persist,
+                                               PermissionDecision decision,
+                                               bool is_final_decision,
+                                               content_settings::mojom::LifetimeMode lifetime_option);
   virtual void NotifyPermissionSet(const PermissionRequestData& request_data,
                                    BrowserPermissionCallback callback,
                                    bool persist,
@@ -209,6 +221,11 @@ class PermissionContextBase : public content_settings::Observer {
 
   // Store the decided permission state. Virtual since the permission might be
   // stored with different restrictions (for example for desktop notifications).
+  void UpdateSettingImpl(const PermissionRequestData& request_data,
+                         PermissionSetting setting,
+                         bool is_one_time,
+                         bool use_lifetime_option,
+                         content_settings::mojom::LifetimeMode lifetime_option);
   virtual void UpdateSetting(const PermissionRequestData& request_data,
                              PermissionSetting setting,
                              bool is_one_time);
@@ -238,6 +255,12 @@ class PermissionContextBase : public content_settings::Observer {
       PermissionRequest::PermissionDecidedCallback permission_decided_callback,
       base::OnceClosure request_finished_callback) const;
 
+  virtual std::unique_ptr<PermissionRequest> CreatePermissionRequest(
+      content::WebContents* web_contents,
+      std::unique_ptr<PermissionRequestData> request_data,
+      PermissionRequest::PermissionDecidedCallbackWithLifetime permission_decided_callback,
+      base::OnceClosure request_finished_callback) const;
+
   // Implementors can override this method to avoid using automatic embargo.
   virtual bool UsesAutomaticEmbargo() const;
 
@@ -271,7 +294,8 @@ class PermissionContextBase : public content_settings::Observer {
   // allows/blocks/dismisses a permission prompt.
   void PermissionDecided(PermissionDecision decision,
                          bool is_final_decision,
-                         const PermissionRequestData& request_data);
+                         const PermissionRequestData& request_data,
+                         content_settings::mojom::LifetimeMode lifetime_option);
 
   void NotifyObservers(const ContentSettingsPattern& primary_pattern,
                        const ContentSettingsPattern& secondary_pattern,
diff --git a/components/permissions/permission_prompt.h b/components/permissions/permission_prompt.h
--- a/components/permissions/permission_prompt.h
+++ b/components/permissions/permission_prompt.h
@@ -70,8 +70,9 @@ class PermissionPrompt {
     virtual GURL GetEmbeddingOrigin() const = 0;
 
     virtual void Accept() = 0;
-    virtual void AcceptThisTime() = 0;
+    virtual void AcceptThisTime(content_settings::mojom::LifetimeMode lifetime_option) = 0;
     virtual void Deny() = 0;
+    virtual void DenyThisTime(content_settings::mojom::LifetimeMode lifetime_option) = 0;
     virtual void Dismiss() = 0;
     virtual void Ignore() = 0;
 
diff --git a/components/permissions/permission_request.cc b/components/permissions/permission_request.cc
--- a/components/permissions/permission_request.cc
+++ b/components/permissions/permission_request.cc
@@ -36,6 +36,16 @@ PermissionRequest::PermissionRequest(
       request_finished_callback_(std::move(request_finished_callback)),
       uses_automatic_embargo_(uses_automatic_embargo) {}
 
+PermissionRequest::PermissionRequest(
+    std::unique_ptr<PermissionRequestData> request_data,
+    PermissionDecidedCallbackWithLifetime permission_decided_callback,
+    base::OnceClosure request_finished_callback,
+    bool uses_automatic_embargo)
+    : data_(std::move(request_data)),
+      permission_decided_callback_withlifetime_(std::move(permission_decided_callback)),
+      request_finished_callback_(std::move(request_finished_callback)),
+      uses_automatic_embargo_(uses_automatic_embargo) {}
+
 PermissionRequest::~PermissionRequest() {
   std::move(request_finished_callback_).Run();
 }
@@ -424,20 +434,40 @@ bool PermissionRequest::ShouldUseTwoOriginPrompt() const {
   return request_type() == RequestType::kStorageAccess;
 }
 
-void PermissionRequest::PermissionGranted(bool is_one_time) {
+void PermissionRequest::PermissionGranted(bool is_one_time,
+                            content_settings::mojom::LifetimeMode lifetime_option) {
+  if (permission_decided_callback_withlifetime_) {
+    std::move(permission_decided_callback_withlifetime_)
+        .Run(is_one_time ? PermissionDecision::kAllowThisTime
+                         : PermissionDecision::kAllow,
+             /*is_final_decision=*/true, *data_, lifetime_option);
+    return;
+  }
   std::move(permission_decided_callback_)
       .Run(is_one_time ? PermissionDecision::kAllowThisTime
                        : PermissionDecision::kAllow,
            /*is_final_decision=*/true, /*request_data=*/*data_);
 }
 
-void PermissionRequest::PermissionDenied() {
+void PermissionRequest::PermissionDenied(bool is_one_time,
+                            content_settings::mojom::LifetimeMode lifetime_option) {
+  if (permission_decided_callback_withlifetime_) {
+    std::move(permission_decided_callback_withlifetime_)
+        .Run(PermissionDecision::kDeny, /*is_final_decision=*/true, *data_, lifetime_option);
+    return;
+  }
   std::move(permission_decided_callback_)
       .Run(PermissionDecision::kDeny,
            /*is_final_decision=*/true, /*request_data=*/*data_);
 }
 
 void PermissionRequest::Cancelled(bool is_final_decision) {
+  if (permission_decided_callback_withlifetime_) {
+    std::move(permission_decided_callback_withlifetime_)
+        .Run(PermissionDecision::kNone, is_final_decision, *data_,
+             content_settings::mojom::LifetimeMode::ALWAYS);
+    return;
+  }
   if (permission_decided_callback_) {
     permission_decided_callback_.Run(PermissionDecision::kNone,
                                      is_final_decision,
diff --git a/components/permissions/permission_request.h b/components/permissions/permission_request.h
--- a/components/permissions/permission_request.h
+++ b/components/permissions/permission_request.h
@@ -52,6 +52,12 @@ class PermissionRequest {
       bool /*is_final_decision*/,
       const PermissionRequestData& /*request_data*/)>;
 
+  using PermissionDecidedCallbackWithLifetime = base::RepeatingCallback<void(
+      PermissionDecision /*decision*/,
+      bool /*is_final_decision*/,
+      const PermissionRequestData& /*request_data*/,
+      content_settings::mojom::LifetimeMode /*lifetime_option*/)>;
+
   // `permission_decided_callback` is called when the permission request is
   // resolved by the user (see comment on PermissionDecidedCallback above).
   // `request_finished_callback` is called when the permission request is being
@@ -66,6 +72,11 @@ class PermissionRequest {
       base::OnceClosure request_finished_callback = base::DoNothing(),
       bool uses_automatic_embargo = true);
 
+  PermissionRequest(std::unique_ptr<PermissionRequestData> request_data,
+                    PermissionDecidedCallbackWithLifetime permission_decided_callback,
+                    base::OnceClosure request_finished_callback = base::DoNothing(),
+                    bool uses_automatic_embargo = true);
+
   PermissionRequest(const PermissionRequest&) = delete;
   PermissionRequest& operator=(const PermissionRequest&) = delete;
 
@@ -172,10 +183,10 @@ class PermissionRequest {
   // If |is_one_time| is true the permission will last until all tabs of
   // |origin| are closed or navigated away from, and then the permission will
   // automatically expire after 1 day.
-  void PermissionGranted(bool is_one_time);
+  void PermissionGranted(bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option);
 
   // Called when the user has denied the requested permission.
-  void PermissionDenied();
+  void PermissionDenied(bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option);
 
   // Called when the user has cancelled the permission request. This
   // corresponds to a denial, but is segregated in case the context needs to
@@ -237,6 +248,9 @@ class PermissionRequest {
   // Called once a decision is made about the permission.
   PermissionDecidedCallback permission_decided_callback_;
 
+  // Called once a decision is made about the permission (with lifetime option).
+  PermissionDecidedCallbackWithLifetime permission_decided_callback_withlifetime_;
+
   // Called when the request is finished to perform bookkeeping tasks.
   base::OnceClosure request_finished_callback_;
 
diff --git a/components/permissions/permission_request_manager.cc b/components/permissions/permission_request_manager.cc
--- a/components/permissions/permission_request_manager.cc
+++ b/components/permissions/permission_request_manager.cc
@@ -201,7 +201,7 @@ void PermissionRequestManager::AddRequest(
 
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kDenyPermissionPrompts)) {
-    request->PermissionDenied();
+    request->PermissionDenied(/*is_one_time*/false, content_settings::mojom::LifetimeMode::ALWAYS);
     return;
   }
 
@@ -270,7 +270,7 @@ void PermissionRequestManager::AddRequest(
 
   if (should_auto_approve_request) {
     if (should_auto_approve_request == PermissionAction::GRANTED) {
-      request->PermissionGranted(/*is_one_time=*/true);
+      request->PermissionGranted(/*is_one_time=*/true, content_settings::mojom::LifetimeMode::UNTIL_ORIGIN_CLOSED);
     }
     return;
   }
@@ -597,7 +597,8 @@ void PermissionRequestManager::Accept() {
                                 (*requests_iter)->request_type(),
                                 PermissionAction::GRANTED);
     PermissionGrantedIncludingDuplicates(requests_iter->get(),
-                                         /*is_one_time=*/false);
+                                         /*is_one_time=*/false,
+                                         content_settings::mojom::LifetimeMode::ALWAYS);
 
 #if !BUILDFLAG(IS_ANDROID)
     std::optional<ContentSettingsType> content_settings_type =
@@ -615,7 +616,7 @@ void PermissionRequestManager::Accept() {
   CurrentRequestsDecided(PermissionAction::GRANTED);
 }
 
-void PermissionRequestManager::AcceptThisTime() {
+void PermissionRequestManager::AcceptThisTime(content_settings::mojom::LifetimeMode mode) {
   if (ignore_callbacks_from_prompt_) {
     return;
   }
@@ -629,7 +630,8 @@ void PermissionRequestManager::AcceptThisTime() {
                                 (*requests_iter)->request_type(),
                                 PermissionAction::GRANTED_ONCE);
     PermissionGrantedIncludingDuplicates(requests_iter->get(),
-                                         /*is_one_time=*/true);
+                                         /*is_one_time=*/true,
+                                         mode);
   }
 
   NotifyRequestDecided(PermissionAction::GRANTED_ONCE);
@@ -637,6 +639,15 @@ void PermissionRequestManager::AcceptThisTime() {
 }
 
 void PermissionRequestManager::Deny() {
+  Deny_(/*is_one_time*/ false, content_settings::mojom::LifetimeMode::ALWAYS);
+}
+
+void PermissionRequestManager::DenyThisTime(content_settings::mojom::LifetimeMode mode) {
+  Deny_(/*is_one_time*/ true, mode);
+}
+
+void PermissionRequestManager::Deny_(bool is_one_time,
+                                     content_settings::mojom::LifetimeMode lifetime_option) {
   if (ignore_callbacks_from_prompt_) {
     return;
   }
@@ -659,7 +670,7 @@ void PermissionRequestManager::Deny() {
     StorePermissionActionForUMA((*requests_iter)->requesting_origin(),
                                 (*requests_iter)->request_type(),
                                 PermissionAction::DENIED);
-    PermissionDeniedIncludingDuplicates(requests_iter->get());
+    PermissionDeniedIncludingDuplicates(requests_iter->get(), is_one_time, lifetime_option);
   }
 
   NotifyRequestDecided(PermissionAction::DENIED);
@@ -1283,32 +1294,32 @@ PermissionRequestManager::VisitDuplicateRequests(
 
 void PermissionRequestManager::PermissionGrantedIncludingDuplicates(
     PermissionRequest* request,
-    bool is_one_time) {
+    bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option) {
   CHECK(RequestExistsExactlyOnce(request, pending_permission_requests_,
                                  requests_))
       << "Only requests in [pending_permission_]requests_ can have duplicates";
-  request->PermissionGranted(is_one_time);
+  request->PermissionGranted(is_one_time, lifetime_option);
   VisitDuplicateRequests(
       base::BindRepeating(
-          [](bool is_one_time,
+          [](bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option,
              const std::unique_ptr<PermissionRequest>& request) {
-            request->PermissionGranted(is_one_time);
+            request->PermissionGranted(is_one_time, lifetime_option);
           },
-          is_one_time),
+          is_one_time, lifetime_option),
       request);
 }
 
 void PermissionRequestManager::PermissionDeniedIncludingDuplicates(
-    PermissionRequest* request) {
+    PermissionRequest* request, bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option) {
   CHECK(RequestExistsExactlyOnce(request, pending_permission_requests_,
                                  requests_))
       << "Only requests in [pending_permission_]requests_ can have duplicates";
-  request->PermissionDenied();
+  request->PermissionDenied(is_one_time, lifetime_option);
   VisitDuplicateRequests(
       base::BindRepeating(
-          [](const std::unique_ptr<PermissionRequest>& request) {
-            request->PermissionDenied();
-          }),
+          [](bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option, const std::unique_ptr<PermissionRequest>& request) {
+            request->PermissionDenied(is_one_time, lifetime_option);
+          }, is_one_time, lifetime_option),
       request);
 }
 
@@ -1578,7 +1589,7 @@ void PermissionRequestManager::DoAutoResponseForTesting() {
   }
   switch (auto_response_for_test_) {
     case ACCEPT_ONCE:
-      AcceptThisTime();
+      AcceptThisTime(content_settings::mojom::LifetimeMode::ONLY_THIS_TIME);
       break;
     case ACCEPT_ALL:
       Accept();
diff --git a/components/permissions/permission_request_manager.h b/components/permissions/permission_request_manager.h
--- a/components/permissions/permission_request_manager.h
+++ b/components/permissions/permission_request_manager.h
@@ -168,8 +168,10 @@ class PermissionRequestManager
   GURL GetRequestingOrigin() const override;
   GURL GetEmbeddingOrigin() const override;
   void Accept() override;
-  void AcceptThisTime() override;
+  void AcceptThisTime(content_settings::mojom::LifetimeMode lifetime_option) override;
   void Deny() override;
+  void Deny_(bool is_one_time, content_settings::mojom::LifetimeMode lifetime_option);
+  void DenyThisTime(content_settings::mojom::LifetimeMode lifetime_option) override;
   void Dismiss() override;
   void Ignore() override;
   void FinalizeCurrentRequests() override;
@@ -419,9 +421,12 @@ class PermissionRequestManager
 
   // Calls PermissionGranted on a request and all its duplicates.
   void PermissionGrantedIncludingDuplicates(PermissionRequest* request,
-                                            bool is_one_time);
+                                            bool is_one_time,
+                                            content_settings::mojom::LifetimeMode lifetime_option);
   // Calls PermissionDenied on a request and all its duplicates.
-  void PermissionDeniedIncludingDuplicates(PermissionRequest* request);
+  void PermissionDeniedIncludingDuplicates(PermissionRequest* request,
+                                           bool is_one_time,
+                                           content_settings::mojom::LifetimeMode lifetime_option);
   // Calls Cancelled on a request and all its duplicates.
   void CancelRequestIncludingDuplicates(PermissionRequest* request,
                                         bool is_final_decision = true);
--
